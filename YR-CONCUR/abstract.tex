\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thmtools}
\declaretheorem{theorem}
\usepackage{xcolor}
\usepackage{hyperref}

%\usepackage[notion, quotation, silent]{knowledge}
%remove silent to have knowledge warnings
%\input{kl}


\newcommand{\nats}{\mathbb{N}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\GH}{\mathcal{GH}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\size}[1]{|#1|}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem*{metaproblem}{Meta Problem}
\newtheorem{realproblem}[theorem]{Problem}
\newtheorem{invariant}{Invariant}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}

\title{Reconfigurable broadcast networks with registers}
\author{Lucie Guillou, Corto Mascle, Nicolas Waldburger}
\date{}

\begin{document}
	
	\maketitle
	
	\section{Introduction}
	
	
%	In broadcast networks, first introduced in [ref], processes of the networks all have the same internal finite-state automaton. Transitions of the automaton model either an internal action, the broadcast, or the reception of a message. The network is parameterized by the number of processes. The coverability problem (given a special state, can we reach a configuration in which one process is in this special state?) is undecidable in broadcast networks [ref]. 
	
	In reconfigurable broadcast nerworks, first introduced in [ref], each node of the network is modelled with a finite-state automaton. Transitions of the automaton model either an internal action, the broadcast, or the reception of a message taken from a finite alphabet. When a node broadcasts a message, it is received by all its neigbors, and its set of neighbors evolve in an uncontrollable fashion during the execution (unlike in broadcast networks [ref] in which the set of neighbors remains the same throughout the execution). The network is parameterized by the number of processes. Reconfigurable broadcast networks have been widely studied in the past years [refs], and it is well known that the coverability problem (which asks: given a special state, can we reach a configuration in which one process is in this special state?) is in \textsc{Ptime}.
	
	One weakness is that agents are not identified, for this reasons in [ref], they introduced a new model extending reconfigurable broadcast networks: in this model, nodes also have a set of internal registers. Each register can contain any value of an \emph{infinite} alphabet (which can be seen as a set of identifiers). Along with a message, they can now also send one of their register's value. Upon reception, they can now store or compare the received value attached with the message.
	
	\begin{definition}
		A \emph{Broadcast network with registers} is ... + ref
	\end{definition}
	
	\textbf{EXAMPLES}
	
	We can check that several messages come from the same agent, we can get confirmations that a message was received.
	We can form chains of agents echoing a flow of information.
	
	\begin{theorem}
		There is a PTIME reduction from LCS to BNRA.
	\end{theorem}
	
	\begin{definition}
		The coverability problem is...
	\end{definition}
	
	\section{With one register per agent}
	
	When an agent stores a new value it forgets its identity and becomes "copycatable"
	
	In NP by a clique abstraction, NP-complete by a 3SAT reduction
	
	\section{With more than one register per agent}
	
	\textbf{To simplify, we assume that agents only broadcast with their original identifiers}
	
	\begin{definition}
		(Informal def) Tree unfolding -> Figure ! (only boss nodes)
		Nodes = local runs
		Children = sources of messages received
	\end{definition} 
	
	\begin{lemma}
		There exists a run covering $q_f$ if and only if there exists a finite tree unfolding whose root covers $q_f$
	\end{lemma}
	
	We want to bound the size of a tree unfolding.
	
	\begin{remark}
		If a descendant broadcasts more than an ancestor, we can shorten the tree.
	\end{remark}
	
	WQO theory tells us that the subword ordering is a wqo and thus that we can bound the size of a tree branch if we can bound its nth node by a function of $n$.
	
	\begin{lemma}
		Local bound + figure
	\end{lemma}
	
	We get the result, but the general case is harder
	
	(Decidability comes from Cover + Parameterized +  Unreliable broadcasts => Copycat. Target is undecidable)
	
\end{document}