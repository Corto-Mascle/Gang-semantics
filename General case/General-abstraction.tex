\section{Bounded witnesses for reachability}

\ifintuition
\subsection{Intuition}

Our aim is to prove the decidability of the coverability problem for BNRA which can only send a single value in each broadcast. The constructions will actually lead us to a decidability proof for specifications of two different types, both subsuming the coverability specification.

\paragraph*{Step 1 : simplification} In Lemma~\ref{lem:simple-reduction} we prove that all protocols, even those which can apply several operations when receiving a broadcast, can be simulated by a protocol with a single operation upon reception of a message and no $*$ operation. A previous lemma already allowed us to remove $\diseqtestact$, thus we only have to prove decidability for systems with one operation per reception and only $\enregact$ and $\eqtestact$ operations.

Lemma~\ref{lem:simple-reduction} is placed within the decidability proof as the constructions defined there may simplify the proof of the lemma (they allow us to prove that BRNA can simulate each other simply by proving that their local runs have the same behaviour).

\paragraph*{Step 2 : run decomposition} Say we have a global run $\rho$ in which an agent broadcasts a message $m_f$. We isolate the local run $u$ of the first agent $a$ broadcasting $m_f$.
In order to execute $u$, we need to receive a sequence of broadcast that matches the sequence of receive transitions in $u$. Let $v$ be a value appearing in $u$.

\begin{itemize}
	\item 
	Say $v$ is not an initial value of $u$, let $w \in \messages^*$ be the sequence of broadcasts received by $a$ with value $v$ in $u$. Then the exact value $v$ does not matter, all $a$ needs is to receive a series of broadcasts with the messages of $w$ all with the same value. This is possible if and only if there exists a global run $\run'$ and a value $v'$ such that $w$ is a subword of the series of broadcasts made in that run with value $v'$. Indeed, if there exists such a run, then $u$ can receive selected broadcasts from $\rho'$ (happening in parallel) in order to get the sequence $w$ of messages with the same value. Conversely, if $u$ receives a sequence $w$ all with the same value in $\rho$, then the prefix of $\rho$ ending just before the broadcast of $m_f$ by $u$ is a fitting candidate for $\rho'$.
	We do not take $\rho$ directly as witness as we want the runs to get shorter as we make the recursive calls.
	
	Here we have our first type of specification, given as a word $w \in \messages^*$. We ask that there exists a global run and a value $v'$ such that $w$ is a subword of the sequence of broadcasts made in the global run with value $v'$.
	
	
	\item 	
	Now suppose $v$ is an initial value of $u$. This situation is very different as other processes need $a$ to send some messages with this value in order to be able to send it back to him.
	The key observation is that once an agent $a'$ other than $a$ has managed to broadcast some message $m$ with value $v$, we have an unlimited supply of such broadcasts:
	Let $w$ be the series of messages broadcast by $a$ with value $v$ before $a'$ makes that broadcast, we now know that there is a global run which, if presented with an external series of broadcasts $w$ with the same value, can then broadcast $m$ with that value.
	We then extend this reasoning and consider the series of broadcast made with value $v$ through $\run$. It can be decomposed as  $(w_0, m_1, w_1, \ldots, m_\ell, w_\ell)$ where $w_0 \cdots w_\ell$ is the sequence of broadcasts made by $a$ with that value and the $m_j$ are placed at the moments where another agent manages for the first time to broadcast that message (from then on we have unlimited supplies of broadcasts with that value and message $m_j$). In particular $\ell \leq \size{\messages}$.
	
	All we have to do is to check for all $j$ that there exists a global run in which some agent broadcasts $m_j$ with a value $v$ that is not one of its initial ones, while having received a series of external broadcasts $w'$ which is of the form $w'_0\cdots w'_{j-1}$ where each $w'_i$ is obtained by adding some letters from $\set{m_0, \ldots, m_i}$ in $w_i$.
	If we have such a run, then with the copycat property we can add an  agent that copies 
	
	This forms our second type of specification, given by a decomposition $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}, m_j)$, which asks for a run that broadcasts $m_j$ with some value $v'$ which it does not have initially, while receiving a series of  external broadcasts with value $v'$ that match $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
\end{itemize}   

We can decompose any run satisfying one of those specifications into a local run (the one of the agent having the value initially in the first case, the one of the first agent which manages to broadcast $m_j$ while not having the value initially in the second case) and some number of specifications satisfied by smaller runs.

Hence we can turn a global run satisfying a given specification into a finite tree where nodes are labelled by local runs and specifications of one of the two types above.

\subsection{Bounds on the size of the minimal decomposition}

The previous section provides witnesses for the satisfiability of specifications, in the form of a tree decomposition.

However it is not clear that there is any bound on the size of those trees.

To provide such bounds, we need several observations.
We say that a local run is cheaper than another one if the set of children it spawns in the decomposition tree is easier to achieve: every child of the first run is a subword of a child of the second one.

 First of all we use Lemma~\ref{lem:short-local-runs}, essentially stating that we can reduce any section of a local run of length more than $f(|\prot|)$, where $f$ is a primitive recursive function, to obtain a shorter and cheaper local run.
 This new run may broadcast less messages, thus we cannot say that every local run can be reduced to one of size $f(\size{\prot})$.
 However, we can say that if there exists a local run making some sequence of $N$ broadcasts, then there is one of size at most $Nf(\size{\prot})$, as we can reduce the sections of runs between those broadcasts.
 
 We now define a notion of altitude of a node, which is not the same as its depth in the tree. Intuitively we put the children of a node $n$ below it if $n$ has to receive messages from them (first case in the previous subsection) and above it if $n$ has to send messages to them (second case).
 The altitude of the root is $0$, and the altitude of a child of a node $n$  is  the one of $n$ minus one if it is of the first type of specification, plus one otherwise.
 
 Nodes of minimal altitude (except maybe the root) are nodes of the second type which only have children of the first type, hence all they have to do is broadcast one single message (given by their father). Hence their length is at most $f(\size{\prot})$. 
 
 Now assume we have a bound $M$ on runs of altitude $h$. A run of altitude $h-1$ sees at most $r$ different initial values. Hence it has at most $\size{\messages}r$ children of the second type, and for each corresponding specification it has to make at most $M$ broadcasts, as each of those children makes at most $M$ receiving actions.
 Moreover, if it is of the first type, it also has to provide broadcasts for its father, but again his father has altitude $h$, thus will require at most $M$ broadcasts.
 
 Overall a local run at altitude $h-1$ needs to make a series of at most $M(\size{\messages} r +1)$ broadcasts. If that can be done, it can be done by a local run of length at most $[M(\size{\messages} r +1)](f(\size{\prot})+1)$.
 
 As a result, we can bound the size of a node of altitude $h$ by $g(\size{\prot}, hmax-h)$, where $hmax$ is the maximal altitude of the tree and $g$ is a primitive recursive function.
 
 This allows us to bound $hmax$: indeed consider the branch reaching the highest point in the tree. Along that branch we can extract a sequence of nodes of the second type $\mu_0, \ldots, \mu_{hmax}$ such that $\mu_i$ has altitude $i$ for all $i$. If there are some $i<j$ such that $\mu_i$ and $\mu_j$ produce the same broadcast but $\mu_j$ is cheaper then we can reduce the branch.
 The bounds on the lengths of the $\mu_i$ and the latter property allow us to bound $hmax$ with a function from the class $F_{\omega^k}$ with $k = \size{\Sigma} +1$ (see, for instance, \cite{SchmitzS2011upperHigman}).
 
 This also gives us a bound on the size of the root (which is also in $F_{\omega^k}$). From there we bound the minimal altitude of a node of this tree. The argument is that in order to reach a minimal altitude $hmin$ with a branch, we need to have along that branch a subsequence of nodes of the first type $\mu_0, \ldots, \mu_{-hmin}$ such that $\mu_i$ has altitude $-i$. If there exist $i<j$ such that $\mu_i$ broadcasts a subword of $\mu_j$ we can reduce the branch. Otherwise, the same results on bad sequences of words  for the subword order allow us to bound the minimal altitude of a node in that tree with a function of $F_{\omega^k}$.
 As both the minimal and maximal altitudes in the tree are bounded by such functions, the size of a node of that tree is also bounded by such a function (using the bound on nodes based on their altitude). This is also a bound on the branching of the tree, as the number of children of a node is bounded by the number of values seen in its local run, thus by the size of that run.
 
 The number of different nodes along a branch is also bounded, hence also the size of that branch (if the same node appears twice we can reduce the branch).
 This lets us bound the overall size of the tree with a function of $F_{\omega^k}$, yielding decidability and complexity of the problem.

\subsection{Formal proof}
\fi


\textbf{For now we assume that the BRNA do not contain $*$ operations and apply only one operation for each message received. The general case reduces to this one (lemma \ref{lem:simple-reduction}).}

\begin{definition}
	An ""external broadcast"" is a transition between two configurations $\config \partstep{m, v} \config'$ such that $m \in \messages$, $v \in \nats$ and for all $a \in \agents$, either $\config'(a) = \config(a)$ or there exists a transition $(\st{\config}(a),\rec{m}{j}{\anact},\st{\config'}(a))$
	such that $\data{\config'}(a, j') = \data{\config}(a, j')$ for all $j' \neq j$ and one of the following cases holds:
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\data{\config'}(a,j) = \data{\config}(a,j)$
			\item $\anact = \quotemarks{\enregact}$ and $\data{\config'}(a,j) = v$
			\item $\anact = \quotemarks{\eqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) =v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) \ne v$
		\end{itemize}
		
		
	A ""partial run"" is a sequence of configurations $\config_0 \cdots \config_k$  such that for all $i \in [1, k]$, either $\config_{i-1} \step{} \config_{i}$ or $\config_{i-1} \partstep{m, v} \config_{i}$ for some $m \in \messages$, $v\in \nats$. 
	
	A ""local configuration"" is a pair $(q, \nu) \in Q \times ([1,r] \to \nats)$.
	A ""local run"" is a sequence of local steps $(q_0, \nu_0) \xrightarrow{op_1} (q_1, \nu_1) \xrightarrow{op_2} \cdots \xrightarrow{op_k} (q_k, \nu_k)$ with $op_1, \ldots, op_k \in Op_r^\messages$. 
	
	Given a value $v \in \nats$, the ""input"" of a partial run $\run$, which we denote by $\extinput{\run} \in (\messages \times \nats)^*$, is the sequence of external broadcasts through $\run$ with value $v$.
	Its ""output"", which we denote by $\extoutput{u} \in (\messages \times \nats)^*$, is the sequence of messages of broadcasts made in $\run$. 
	
	Given a value $v \in \nats $he $v$-input (resp. $v$-output) of $\run$ is defined as the projection of $\extinput{\run}$ (resp. $\extoutput{\run}$) on $\messages \times \set{v}$.
	

	The ""input"" of a "local run" $\localrun$ is the sequence $\Input{\localrun}$ of messages received in $\localrun$. 
	Similarly, its ""output"" is the sequences $\Output{\localrun}$ of messages broadcasted in $\localrun$.

	Given a value $v \in \nats$, the $v$-input of a local run $u$, which we denote by $\vinput{v}{\localrun}$, is the sequence of messages received in  $\localrun$ with value $v$. Said otherwise, it is the subsequence of $\Input{\localrun}$ containing only messages with value $v$.
	Similarly, its $v$-output $\voutput{v}{u}$ is the sequence of messages with value $v$ broadcasted in $\localrun$.
	
%	Its ""trace"" $\trace{u} \in Op^\messages_r$ is the sequence of operations executed by $u$.
	
	We define a preorder on "partial runs":
	Given $\run, \run'$, $\run \unlhd \run'$ if for all $v \in \nats$, there exists $v' \in \nats$ such that $\vinput{v}{\run}$ is a subword of $\vinput{v}{\run'}$.
	\cortoin{TO READ OVER}
\end{definition}

A key ingredient of our construction is the decomposition of words of messages. Say we have an execution and a value $v$ such that the sequence of messages broadcast in that execution with value $v$ is $w$. Then we can distinguish in $w$ the messages sent by the agent $a$ which had that value originally. This forms a subword $w'$ of $w$. Let $m$ be the first message sent by another agent with value $v$. This means that from the messages sent by $a$ before there is a set of agents that receives some of these messages and eventually sends back message $m$ with value $v$. An important remark is that we can copy this set of agents many times to obtain as many broadcasts with message $m$ and value $v$ as we want from this point in the run.

In general, if an agent other than $a$ sends a message with value $v$ then we can add agents to obtain that message with that value as many times as we want.
Therefore, we will describe the sequences of messages sent with a value $v$ as tuples $(w_0, m_1, \ldots, m_\ell, w_\ell)$, where $w_0\cdots w_\ell$ is the sequence of messages sent by the agent $a$ which has that value initially and the $m_i$ mark, for every message of $\messages$ the first moment at which some agent other than $a$ broadcasts it with value $v$ (if that happens).

\begin{definition}
	A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. The set of decompositions over $\messages$ is denoted $\decset{\messages}$.
	
	We say that a word $w \in \messages^*$ ""decomposes as"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w = w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding some letters from $\set{m_1, \ldots, m_{j-1}}$.
	
	The language $\langdec{\decsymb}$ of $\decsymb$ is the set of words that decompose as $\decsymb$. We write $\langdecdown{\decsymb}$ for the subword closure of $\langdec{\decsymb}$.
	
	We define a preorder on decompositions:
	$\decsymb \subword \decsymb'$ if $\langdecdown{\decsymb} \subseteq \langdecdown{\decsymb'}$.
\end{definition}


\begin{definition}
	A ""tree unfolding"" is
	a finite tree where each node has three labels:
	\begin{itemize}
		\item The first one is a local run of $\prot$. 
		
		\item The second one is a value $v \in \nats$.
		
		\item The third one is a ""specification"", which is either a word $w \in \messages^*$ or a pair $(\decsymb, m)$ with $m \in \messages$ and $\decsymb \in \decset{\messages\setminus\set{m}}$ a "decomposition". In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"". 
	\end{itemize} 
	
	It must satisfy the following conditions:
	Let $\mu$ be a node of that tree, and $u$ and $v$ the local run and value labelling it. The following conditions must hold:
	
	\begin{itemize}
		\item[C1] If it is a "boss node" labelled by $w \in \messages^*$ then $v$ is an initial value of $u$ and there exists a decomposition $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$ such that
	 $w_0 \cdots w_\ell$ is the $v$-output of $u$, $w \in \langdec{\decsymb}$, and for all $j \in [1,\ell]$, $\mu$ has a child which is a "follower node" with a label $\decsymb \subword ((w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j)$.
		
		\item[C2] If it is a "follower node" labelled $(\decsymb, m)$ then $v$ is not an initial value of $u$, the $v$-input of $u$ is in $\langdec{\decsymb}$, and $m$ is broadcast at some point in $u$ with value $v$.
		
		\item[C3] In both cases, for all $v' \neq v$ broadcast or received at some point in $u$,
		\begin{itemize}
			\item[C3.1] If $v'$ is an initial value of $u$ then there exists a "decomposition" $\decsymb' = (w'_0, m'_1, w'_1, \ldots, m'_k, w'_k)$ where $w'_0 w'_1 \ldots w'_k$ is the $v'$-output of $u$, for all $j \in [1,k]$ all receptions of $m_j$ with value $v'$ in $u$ happen after the broadcasts of $w'_0\cdots w'_{j-1}$ with value $v'$, and for all $j \in [1,k]$ $\mu$ has a child which is a "follower node" with a label $\decsymb \subword ((w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j)$.  
			
			\item[C3.2] If $v'$ is not an initial value of $u$ then $\mu$ has a child which is a "boss node" labelled by $w'$ such that $\vinput{v}{u}$ is a subword of $w'$.
		\end{itemize}
	\end{itemize}
	
	
\end{definition}


% Old definition

%\begin{definition}
%	We define two types of specifications for runs of a given "protocol" $\prot$:
%	
%	\begin{itemize}
%		\item The first one is the ""boss type"", and is given by a word $w$ over $\messages$. There should exist some value $v \in \nats$ such that the $v$-output of the run has $w$ as a subword.
%		
%		\item The second one is the ""follower type"". It is given by sequences of letters $m_1, \ldots, m_\ell \in \messages$ and words $w_0, \ldots, w_\ell$ over $\messages$, and a letter $m \in \messages$, such that all $m_j$ are distinct from $m$ and from each other.
%		There should exist some value $v$ such that the run takes as input a word $w'$ that "decomposes as" $(w_0, m_1, \ldots, m_\ell, w_\ell)$, and whose $v$-output contains an $m$.
%	\end{itemize}
%\end{definition}

%\begin{definition}
%	A ""tree decomposition"" of a run $\run$ with respect to a "specification" is
%	a tree whose nodes are labelled by local runs $u$ of $\prot$ and either by "boss specifications" $w$ ("boss nodes") or by "follower specifications" $(w_0, m_1, w_1, \ldots, m_\ell, w_\ell, m)$ ("follower nodes"). 
%	
%	It must satisfy the following conditions:
%	Let $\mu$ be a node of that tree, and $u$ the local run labelling it.
%	
%	If it is a "boss node" labelled by some $w$ then there must exist $v \in \nats$ an initial value of $u$ such that
%	\begin{itemize}
%		\item $w$ "decomposes as" $(w_0, m_1, w_1, \ldots, m_\ell, w_\ell)$ with $w_0 \cdots w_\ell$ the $v$-input of $u$, and for all $1 \leq j \leq \ell$ $\mu$ has a child which is an "follower node" labelled $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j$.
%		
%		\item For all $v' \neq v$ appearing in $u$,
%		\begin{itemize}
%		\item If $v'$ is an initial value of $u$ then the $v'$-vision of $u$ "decomposes as"  $(w'_0, m'_1, w'_1, \ldots, m'_k, w'_k)$ where $w'_0 w'_1 \ldots w'_k$ is the $v'$-output of $u$ and for all $1 \leq j \leq k$ $\mu$ has a child which is an "follower node" labelled $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j$.  
%			
%		\item If $v'$ is not an initial value then $\mu$ has a child which is a "boss node" labelled by $w'$ the $v'$-input of $u$.
%		\end{itemize}
%	\end{itemize}
%
%	If it is an "follower node" labelled by some $(w_0, m_1, w_1, \ldots, m_\ell, w_\ell, m)$ then there must exist $v \in \nats$ an initial value of $u$ such that
%	\begin{itemize}
%		\item $u$ ends with a broadcast of $m$ with value $v$.
%		
%		\item The $v$-input of $u$ is a subword of some $w' = w'_0\cdots w'_\ell$ where, for all $j$, $w'_j$ can be obtained by adding some $m_1, \ldots, m_{j}$ to $w_j$.
%		
%		\item For all $v' \neq v$ appearing in $u$,
%		\begin{itemize}
%			\item If $v'$ is an initial value of $u$ then the $v'$-vision of $u$ "decomposes as"  $(w'_0, m'_1, w'_1, \ldots, m'_k, w'_k)$ where $w'_0 w'_1 \ldots w'_k$ is the $v'$-output of $u$ and for all $1 \leq j \leq k$ $\mu$ has a child which is an "follower node" labelled $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j$.  
%			
%			\item If $v'$ is not an initial value then $\mu$ has a child which is a "boss node" labelled by $w'$ the $v'$-input of $u$.
%		\end{itemize}
%	\end{itemize}
%\end{definition}

\begin{definition}
	A "run" $\run$ satisfies a boss specification $w$ if there exists $v \in \nats$ such that $w$ is the sequence of messages sent with value $v$ through $\run$.
	
	A "run" $\run$ satisfies a follower specification $(\decsymb, m)$ if there exists a value $v$ and an agent $a$ such that $v$ is not an initial value of $a$, the $v$-input of $a$ in $\run$ is in $\langdecdown{\decsymb}$ and agent $a$ broadcasts $m$ with value $v$ at some point.
	
	A "tree unfolding" satisfies a boss specification $w$ if its root is a "boss node" and $w$ is a subword of its specification label.
	A "tree unfolding" satisfies a follower specification $(\decsymb ,m)$ if its root is an "follower node" labelled with $(\decsymb',m')$ such that $m'=m$ and  $\decsymb' \subword \decsymb$.
\end{definition}

We will now prove that there exists a finite run satisfying a specification if and only if there exists a finite tree satisfying that same specification.
We first decompose a run into a tree, then we build a run from a tree. Note that by applying consecutively these two transformations we obtain in general a much larger run than the initial one. That is because each node of the tree is associated with a part played in the run by some agent. In the initial run, the same agent may play many different parts, while in the run we construct from the tree we use different agents for each node of the tree.

Also note that the interpretation of the "follower nodes" changes between the two directions: When building the tree a follower node labelled $(\decsymb ,m)$ means that there exists a global run in which some agent receives a sequence of messages which decomposes as  $\decsymb$ and broadcasts $m$, all with a value $v$ that is not one of its initial ones.

When building the run a follower node means that there exists a global run which receives a series of external broadcasts which decomposes as $\decsymb$, with a value $v$ that it initially does not contain, and eventually broadcasts $m$ with that value.

\begin{lemma}
	If there exists a finite run $\rho$ satisfying some "specification" then there exists a finite "tree unfolding" satisfying that "specification".
\end{lemma}

\ifproofs
\begin{proof}
	
	We proceed by strong induction on the lexicographic order on $\nats \times \set{boss, follower}$ with the length of $\run$ as the first component and the type of specification as the second, "boss" being considered higher than "follower". 
	
	Let $\run$ be a run, $spec \in \messages^* \cup \decset{\messages}$ a specification, assume the property is satisfied for all lower pairs of runs and specifications. We construct a root and attach subtrees to it so that conditions (C1) to (C3) are satisfied 
	
	We split our construction in four parts. The first part applies if $spec$ is a "boss specification", the second one if $spec$ is a "follower specification". 
	Those parts construct a local run $u$ and a value $v$, as well as the root and some children so that conditions (C1) and (C2) are satisfied.
	
	The third and fourth part construct children so that (C3.1) and (C3.2) are satisfied, respectively.
	
	\textbf{Case 1: The specification is a "boss specification"}
	
	Assume $spec$ is a "boss specification" $spec = w \in \messages^*$.
	There exists a value $v$ such that $w$ is a subword of the sequence of messages broadcast with value $v$ through $\run$. Let $w'$ be the latter sequence.
	If $w$ is empty then the tree decomposition with one node labelled with an empty local run, any value and $w$ satisfies $w$.	
	
	Otherwise let $a$ be the agent which has $v$ as an initial value, let $u$ be its local run in $\run$. We set $u$, $v$ and $w'$ to be the labels of the root of the tree unfolding we are constructing.
	We decompose $w'$ as $(w'_0, m_1, w'_1, \ldots, m_\ell, w'_\ell)$, where $w'_0\cdots w'_\ell$ is the sequence of messages broadcast by $a$ with value $v$, and the $(m_j)_{1\leq j\leq \ell}$ are the elements of $\messages$, placed at the times at which they are first broadcast by an agents other than $a$ with value $v$. If there is no such broadcast of a message $m$, then it does not appear as an $m_j$. This forms a "decomposition" of $w'$.
		
	For all $1 \leq j \leq \ell$ let us write $\decsymb_j$ for the "decomposition" $(w'_0, m_1, w'_1, \ldots, m_{j-1}, w'_{j-1})$. Let $\run_j$ be the prefix of $\run$ up until the first broadcast of $m_j$ with $v$ by some agent $a$ that does not have $v$ as an initial value, and let $\run'_j$ be $\run_j$ without that last step. By definition of $\decsymb$, the sequence of broadcasts with value $v$ in $\run'_j$ "decomposes as" $\decsymb_j$.
	In particular, the $v$-input of $a$ before it broadcasts $m_j$ with $v$ must decompose as $\decsymb_j$.
	 
	Hence $(\decsymb_j, m_j)$ is a "follower specification" satisfied by $\run_j$, which has a length smaller or equal to the one of $\run$. By induction hypothesis (recall that we make our induction on the length of $\run$ and on the type of specification), there is a "tree unfolding" satisfying it.
	
	We put that "tree unfolding" as a child of our root, hence we satisfy (C1). We satisfy (C2) as the root we constructed is not a "follower node".
	
	\textbf{Case 2: The specification is a "follower specification"} 
	
	Assume $spec$ is a "follower specification" $spec = \decsymb \in \decset{\messages}$. 
	There exists a value $v$, an agent $a$ and a decomposition $\decsymb' \in \decset{\messages}$ such that $\decsymb \subword \decsymb'$ and the $v$-input of the local run $u$ of $a$ decomposes as $\decsymb'$. 
	
	We set our root to have as labels $u$, $v$ and $\decsymb'$, thus satisfying (C2). We satisfy (C1) as the root is not a "boss node".
	
	\textbf{In both cases}
	
	We have constructed an agent $a$ and a value $v$ and set our root to be labelled by the local run $u$ of $a$ and $v$, and added children to that root so that conditions (C1) and (C2) are satisfied. We will now add some more children to satisfy condition (C3).
	
	We can assume that the last step of $\run$ is a broadcast of a message with value $v$, as otherwise we can erase its last step to get a run that still satisfies the specification, but has a smaller length than $\run$, hence we can apply the induction hypothesis.
	
	Let $v' \neq v$ be a value broadcast or received in $u$. 
	
	\begin{itemize}
		\item If $v'$ is an initial value of $u$ then let $w'$ be the $v'$-"output" of $u$. Let $\decsymb' = (w'_0, m_1, w_1, \ldots, w'_k)$ be such that $w' = w'_0 \cdots w'_k$ and the $m_i$ mark the first time another agent sends each message of $\messages$ with value $v'$ in $\run$.  
		
		For all $j \in [1,k]$, all receptions of $m_j$ with value $v'$ in $u$ must happen after another agent has managed to broadcast it, hence after broadcasts of $w'_0 \cdots w'_{j-1}$ with value $v'$ have happened in $u$, by definition of $\decsymb'$.
		
		Let $j \in [1,k]$, let $a_j$ be the first agent other than $a$ to broadcast $m_j$ with value $v'$, and let $\run_j$ be the prefix of $\run$ up until that broadcast. The $v'$-input of $a_j$ in $\run_j$ is a subword of the sequence of messages broadcast with value $v'$ in $\run_j$, which decomposes as $\decsymb_j = (w'_0, m_1, w_1, \ldots, w'_{j-1})$.
		
		As the last step of $\run$ is a broadcast of $v$ and $v' \neq v$, all $\run_j$ are shorter than $\run$. Furthermore for all $j$, $\run_j$ satisfies the specification $(\decsymb_j, m_j)$.		
		
		By induction hypothesis, for all $j$ there exists a "tree unfolding" satisfying $(\decsymb_j, m_j)$. We add all those trees as children of our root.
		
		\item If $v'$ is not an initial value of $u$ then let $w'$ be the $v'$-input of $u$. 
		 As $\run$ ends with a broadcast of $v$ and $v' \neq v$, we can remove the last step of $\run$ to obtain a run $\run'$. As $w'$ is a subword of the sequence of messages broadcast in $\run$ with value $v'$, it is also the case for $\run'$.
		 Hence $\run'$ satisfies $w'$ as a specification, and has smaller length than $\run$. By induction hypothesis, there is a "tree unfolding" satisfying $w'$. We add it as a child of our root.
	\end{itemize}
	
	We added some "tree unfoldings" as children of the root so that conditions (C1) to (C3) are satisfied. We obtain a "tree unfolding" satisfying the specification.
\end{proof}
\fi



\begin{lemma}
	If there exists a finite "tree unfolding" whose root is labelled with some "specification" then there exists  a finite run $\rho$ satisfying that specification.
\end{lemma}

\ifproofs
\begin{proof}
	We prove the following statement by strong induction on the "tree unfolding". \corto{notation for t.u.}
	
	For all "tree unfolding" $\tau$, 
	
	\begin{itemize}
		\item if $\tau$ satisfies a "boss specification" $w \in \messages^*$, then there exists a run $\run$ satisfying $w$.
		
		\item if $\tau$ satisfies a "follower specification" $(\decsymb, m)$ then there exists a word $w \in \langdecdown{\decsymb}$, a "partial run" $\run$ and a value $v$ such that $\extinput{\run} \in (\messages\times \set{v})^*$, $\vinput{v}{\run} \in \langdecdown{\decsymb}$, and $\voutput{v}{\run}$ contains a $m$.
	\end{itemize}
	
	Let $\tau$ be a "tree unfolding", let $\mu$ be its root, let $u$ be the local run labelling it. 
	We distinguish two cases depending on the type of specification.
	
	\textbf{Case 1: The specification is a "boss specification" $spec \in \messages^*$}
	
	Then $\mu$ is a "boss node", labelled by $u$ and by a word $w$ of which $spec$ is a subword. 
	By definition of a "tree unfolding", there exists a value $v$ and a decomposition $\decsymb = (w_0, m_1, \ldots, w_\ell) \in \decset{\messages}$ such that $\voutput{v}{u} = w_0\cdots w_\ell$ and $w \in \langdecdown{\decsymb}$.
	Furthermore for all $j \in [1,\ell]$, $\mu$ has a child labelled $(\decsymb_j, m_j)$ with $\decsymb_j = (w_0, m_1, \ldots, w_{j-1})$. 	By induction hypothesis, there exists a partial run $\run_{v, \decsymb_j}$ in which there is a broadcast of $m_j$ with value $v$ 
\end{proof}
\fi


\begin{lemma}
	If two protocols $\prot, \prot'$ are such that for all local run $u$ of one of them, the other has a local run with the same inputs and outputs, then their runs satisfy the same specifications. 
\end{lemma}
\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi


\begin{lemma}
	\label{lem:simple-reduction}
	For all "protocol" $\prot$ there is a "simple protocol" $\prot'$ with one more register satisfying the same queries.
\end{lemma}
\ifproofs
\begin{proof}
	\cortoin{Ancienne preuve, à adapter ou réécrire}
	
	We construct $\prot'$ as follows: It has one more register than $\prot$, but stores in its state the current state of $\prot$ and a mapping $map : [1,r] \to [1,r+1]$ from registers of $\prot$ to its own registers.
	
	Intuitively, it is going to use its registers to store the different values that are in the registers of $\prot$, and the mapping to keep track of which registers contain which values.
	When a value is received it guesses whether it is one of the existing values or a fresh one, and updates the registers and the mapping accordingly.
	The extra register of $\prot'$ is not necessary, but simplifies the proof.
	
	Formally, we set $\prot = (Q, \messages, \Delta, q_0)$. The set of states of $\prot'$ is $Q \times ([1,r] \to [1,r])$. 
	There is a transition $(q, map) \xrightarrow{\br{m}{i}} (q', map')$ if and only if $map = map'$ and $\prot$ has a transition $q \xrightarrow{\br{m}{j}} q'$ with $map(j) = i$.
	
	There is a transition $(q, map) \xrightarrow{\rec{m}{j}{\enregact}} (q', map')$ if and only if there is a transition $q \xrightarrow{\recmulti{m}{op_1\cdots op_r}} q'$ in $\prot$ such that $op_i \neq \eqtestact$ for all $i$ and $map^{-1}(j) =\emptyset$ and for all $i \in [1,r]$, $map'(i) = map(i)$ if $op_i = *$ and $map'(i) = j$ if $op_i = \enregact$.
	
	There is a transition $(q, map) \xrightarrow{\rec{m}{j}{\eqtestact}} (q', map')$ if and only if there is a transition $q \xrightarrow{\recmulti{m}{op_1\cdots op_r}} q'$ in $\prot$ such that for all $i\in [1,r]$,
	\begin{itemize}
		\item If $op_i = \eqtestact$ then $map(i) = map'(i) = j$
		
		\item If $op_i = \enregact$ then $map'(i) = j$
		
		\item If $op_i = *$ then $map'(i)= map(i)$
	\end{itemize}
	
	
	We prove by induction on $\size{u}$ that for all "local run" $u$ of $\prot$ there exists a "local run" $u'$ of $\prot'$ with the same "trace" and such that if the last configuration of $u$ is $(q,f)$ and the last configuration of $u'$ is $((q',map), f')$ then $q=q'$ and for all $i$, $f(i) = f'(map(i))$.  
	
	\cortoin{TODO}
	
	We prove by induction on $\size{u'}$ that for all "local run" $u'$ of $\prot'$ there exists a "local run" $u$ of $\prot$ with the same "trace" and such that if the last configuration of $u$ is $(q,f)$ and the last configuration of $u'$ is $((q',map), f')$ then $q=q'$ and for all $i$, $f(i) = f'(map(i))$.
	
	\cortoin{TODO}  
\end{proof}
\fi

\begin{lemma}
	Let $\tau$ be a "tree unfolding" satisfying a specification $spec$.
	Let $\mu, \mu'$ be two "boss nodes" of $\tau$, $w$ and $w'$ their specification labels.
	
	If $\mu$ is an ancestor of $\mu'$ and $w$ is a subword of $w'$ then there exists a smaller "tree unfolding" satisfying $spec$.  
\end{lemma}

\ifproofs
\begin{proof}
	Let $\tau_{\mu}$, $\tau_{\mu'}$ be the subtrees rooted in $\mu$, $\mu'$ respectively. 
	Let $\tau'$ be the tree obtained by replacing $\tau_{\mu}$ with $\tau_{\mu'}$. The size of $\tau'$ is smaller than the one of $\tau$, as $\tau_{\mu'}$ is a strict subtree of $\tau_{\mu}$.
	
	If $\mu$ is the root of $\tau$, then $\tau'$ is a "tree unfolding" with $\mu'$ as root. As $\mu$ is a "boss node" and $\tau$ satisfies $spec$, $spec$ is a "boss specification", and a subword of $w$. 
	As $w$ is a subword of $w'$, $spec$ is a subword of $w'$ and thus $\tau'$ satisfies $spec$.
	
	If  $\mu'$ is not the root of $\tau'$ then let $\mu''$ be the father of $\mu$. We have to check that $\tau'$ is a "tree unfolding". 
	All nodes other than $\mu''$ have the same children as before, thus the conditions of "tree unfoldings" are still respected for them.
	As for $\mu''$, it has the same "follower" children, hence conditions (C1) and (C3.1) are respected. Condition (C2) only depends on its label, which hasn't changed.
	
	Finally, let $u''$ be the "local run" labelling $\mu''$ and let $v'$ be a value that is not initial in $u''$. Either $\mu''$ has a "boss" child other than $\mu'$ such that $\vinput{v'}{u''}$ is a subword of its label, or $\vinput{v'}{u''}$ is a subword of $w$, which is a subword of $w'$, hence condition (C3.2) is satisfied. 
	
	As a result, in both cases $\tau'$ is a "tree unfolding" smaller than $\tau$ that satisfies $spec$. 
\end{proof}
\fi

\begin{lemma}
	Let $\tau$ be a "tree unfolding" satisfying a specification $spec$.
	Let $\mu, \mu'$ be two "follower nodes" of $\tau$, $(\decsymb,m)$ and $(\decsymb',m')$ the associated specifications.
	If $\mu$ is an ancestor of $\mu'$, $\decsymb' \subword \decsymb$ and $m=m'$ then there exists a smaller "tree unfolding" satisfying $spec$. 
\end{lemma}

\ifproofs
\begin{proof}
		Let $\tau_{\mu}$, $\tau_{\mu'}$ be the subtrees rooted in $\mu$, $\mu'$ respectively. 
	Let $\tau'$ be the tree obtained by replacing $\tau_{\mu}$ with $\tau_{\mu'}$. The size of $\tau'$ is smaller than the one of $\tau$, as $\tau_{\mu'}$ is a strict subtree of $\tau_{\mu}$.
	
	If $\mu$ is the root of $\tau$, then $\tau'$ is a "tree unfolding" with $\mu'$ as root. As $\mu$ is a "follower node" and $\tau$ satisfies $spec$, $spec$ is a "follower specification". Let $(\decsymb_{spec}, m_{spec}) = spec$, we have $\decsymb \preceq \decsymb_{spec}$ and $m = m_{spec}$. 
	Hence we have $\decsymb' \preceq \decsymb \preceq \decsymb_{spec}$ and $m' = m = m_{spec}$, thus $\tau'$ satisfies $spec$.
	
	If  $\mu'$ is not the root of $\tau'$ then let $\mu''$ be the father of $\mu$. We have to check that $\tau'$ is a "tree unfolding". 
	All nodes other than $\mu''$ have the same children as before, thus the conditions of "tree unfoldings" are still respected for them.
	As for $\mu''$, it has the same "boss" children, hence condition (C3.2) is respected. Condition (C2) only depends on its label, which hasn't changed.
	
	Let $u''$ and $v''$ be the local run and value labelling $\mu''$.
	For condition (C1), suppose $\mu''$ is a "boss node" labelled by a word $w''$, then $v''$ is an initial value in $u''$. There exists a decomposition $\decsymb'' = (w_0, m_1, \ldots, w_\ell)$ such that $\voutput{v''}{u''} = w_0\cdots w_\ell$, $w''\in \langdecdown{\decsymb}$ and for all $j \in [1,\ell]$, $\mu''$ has a child labelled $(\decsymb,m_j)$ with $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$ in $\tau$.
	For all $j$, either $\mu''$ has a child labelled $(\decsymb,m_j)$ with $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$ in $\tau$ besides $\mu$, in which case this child is still there in $\tau'$, or $\mu$ is labelled $(\decsymb,m_j)$ for some $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$, in which case $\mu'$ is labelled $(\decsymb', m_j)$ with  $\decsymb' \subword \decsymb \subword (w_0, m_1, \ldots, w_{j-1})$.
	Condition (C1) is still satisfied.
	
	Finally, let $v' \neq v''$ an initial value of $u$ broadcast or received at some point.
	Then there exists a decomposition $\decsymb'' = (w'_0, m'_1, \ldots, w'_\ell)$ such that $\voutput{v''}{u''} = w'_0\cdots w'_\ell$, and for all $j \in [1,\ell]$, all receptions of $m'_j$ with value $v'$ in $u''$ happen after the broadcasts of $w'_0\cdots w'_{j-1}$ with value $v'$, and for all $j \in [1,\ell]$ $\mu$ has a child in $\tau$ which is a "follower node" with a label $\decsymb \subword (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
	If that child is not $\mu$ then it is still there in $\tau'$. If it is $\mu$, in $\tau'$ $\mu''$ has $\mu'$ as child, with a label $\decsymb' \subword \decsymb \subword (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
	In both cases condition (C3.1) is satisfied.
	
	As a result, in both cases $\tau'$ is a "tree unfolding" smaller than $\tau$ that satisfies $spec$. 
\end{proof}
\fi
%\begin{lemma}
%	Let $u_1$, $u_2$ be two local runs of a protocol $\prot$ with the same sequence of transitions, $(q_1, \nu_1)$ the first local configuration of $u_1$, $(q_2, \nu_2)$ the last one of $u_2$. Then there is a local run $u$ with the same sequence of transitions as $u_1$ and $u_2$ from $(q_1, \nu_1)$ to $(q_2, \nu_2)$. 
%\end{lemma}

\begin{figure}
	\input{../Figures/fig-illustration-pumping}
	\caption{Illustration of the proof of Lemma~\ref{lem:short-local-runs}. Lines correspond to registers, and vertical separations are times at which the value of that register changes. If one register $i$ keeps the same value for a long enough time (on the left), we apply the induction hypothesis to shorten the projection of the run on the other registers. As the value of $i$ does not change, the resulting run is still valid. If all registers change values often (on the right), then if the run is long enough we can find two identical sequences of transitions during which all values are renewed. We can then obtain a shorter run by glueing them together as in the picture.}
\end{figure}


\begin{remark}
	The tower bound of Lemma~\ref{lem:short-local-runs} is tight, in the sense that some local runs may need to have length a tower of exponentials of height the number of registers.
	It also holds for pushdown automata, and for all transition systems which have some kind of pumping lemma.
\end{remark}

\begin{lemma}
	\label{lem:short-local-runs}
	There exists a function $\towerfun(n, e)$ in $O(\repexp{n}{e})$ such that, for every protocol $\prot$ with $r$ registers per process, for every "local run" $\localrun: (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ in $\prot$, there exists $\localrun': (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ such that $\length{\localrun'} \leq \towerfun(\size{\prot})(r)$ and $\Input{\localrun'} \subword \Input{\localrun}$. 
%  with an "input" $I$.
% 	Let $u_1, u_2, u_3$ be such that $u=u_1u_2u_3$.
% 	If $\size{u_2} > TOWER$, then there exists $u'_2$ with $|u_2'| \leq \towerfun(\prot)$ such that $u_1u'_2u_3$ is a local run of $\prot$ with smaller "input" than $u$. 
\end{lemma}

\ifproofs
\begin{proof}

% In the following proof, we consider for simplicity protocols with internal transitions, \emph{i.e.}, transitions with no labeled action that can be taken without condition. 
Given a "local run", register $i$ is ""active"" in $\localrun$ if at least one $\quotemarks{\enregact}$ step on register $i$ is performed in $\localrun$. Also, let $n:=\size{\prot}$.

We prove the following statement:
for every $\localrun: (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ with $k$ "active registers" such that $\length{\localrun} > \towerfun(|\prot|,k)$, $\localrun$ can be shortened into a local run $\localrun': (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ whose sequence of transitions is a strict subsequence of the one of $\localrun$. 
\nicoin{si le protocole n'est pas simple, cela n'implique pas l'inclusion  $\Input{\localrun'} \subword \Input{\localrun}$, il faut supposer que simple ou changer la def de local run pour qu'il inclut la séquence des messages reçus}

We proceed by induction on the number $k$ of "active registers" in the "local run". If $k=0$, then registers keep their values throughout $\localrun$. Therefore, if $\localrun$ goes through the same state once, all steps in between may be removed, and it suffices to take $\towerfun(\size{\prot}, 0) := |\prot| + 1 \geq |Q| +1$.  

Suppose that the property is true for any protocol with $\leq k$ "active registers", and consider a run $\localrun: (q_i,\localdata_i) \step{*} (q_f,\localdata_f)$ with $k+1$ "active registers" such that $\length{\localrun} > \towerfun(n)(k+1)$.

First, if there exists an infix "local run" $\localrun': (q_1, \localdata_1), (q_2, \localdata_2)$ of $\localrun$ of length $\towerfun(n)(k)+1$ with only $k$ active registers, then by induction hypothesis $\localrun'$ can be shortened thus $\localrun$ can be shortened as well.

Suppose now that there exists no such infix "local run".
Let $I \subseteq \nset{1}{r}$ the set of "active registers" in $\localrun$, $|I| = k+1$. 
In any sequence of $\towerfun(n)(k)+1$ transitions performed in a row in $\localrun$, 
there is a $\quotemarks{\enregact}$ transition on every register in $I$. Let $\towerfun{n}{k+1} := n^{\towerfun{n}{k}+1}+\towerfun{n}{k} +1$ and suppose that $\length{\localrun} > \towerfun{n}{k+1}$. 
There exist $n^{\towerfun{n}{k}+1}+1$ sequences of transitions of length $\towerfun(n)(k)+1$ in $\localrun$, 
therefore by Pigeonhole principle two of these sequences are equal (there are $|\transitions|^{\towerfun(n)(k)+1}$ such sequences and $|\transitions| \leq n$). 
There exist $(q_1, \localdata_1)$, $(q_2, \localdata_2)$ appearing in $\localrun$ in this order such that both configurations are followed by the same sequence $s$ of transitions in $\localrun$. We write $\localrun_1: (q_1, \localdata_1) \step{s} (q_1', \localdata_1')$ and $\localrun_2: (q_2, \localdata_2) \step{s} (q_2', \localdata_2')$. Morally, we can remove all transitions between $(q_1, \localdata_1)$ and $(q_2, \localdata_2)$. However, we do not have \nico{il faut pouvoir parler explicitement de la séquence de messages ici}

 Note that we cannot directly cut this part out of the "local run" and concatenate the two ends, because messages received after $(q_2, \localdata_2)$
Let $m_1$ the sequence of messages received when $s$ is performed from $(q_1, \localdata_1)$ and 

	We will show the following result, which directly implies the lemma:
	Let $\prot$ be a protocol with $r$ registers, let $u$ be a "local run" of $\prot$ from "local configuration" $(q_0, \nu_0)$ to $(q_{end}, \nu_{end})$ with an input $I$. If $\size{u} \geq TOWER$, then there exists a shorter local run $u'$ from $(q_0, \nu_0)$ to $(q_{end}, \nu_{end})$, with a smaller "input" and such that the sequence of local actions in $u'$ is a subword of the one in $u$.
	We proceed by induction on $r$.
	
	If $r=0$ then if $\size{u} > TOWER = \size{Q}$ then $u$ visits twice the same state, hence the same local configuration as there are no registers, and the sequence between those two moments can be deleted, yielding the result.
	
	Let $r>0$, suppose the proposition holds for $r-1$.
	Let $u$ be a run of $\prot$, a protocol with $r$ registers, with $\size{u} > TOWER$.
	
	\begin{itemize}
		\item If there exists $i \in [1,r]$ such that $u$ has a factor $u_f$ in which the value of register $i$ does not change and with $\size{u_f} > TOWER$, then let $\Tilde{\prot}$ be $\prot$ where every operation $op$ over $i$ has been replaced with a local action $a_{op}$. Note that $\Tilde{\prot}$ only uses $r-1$ registers. 
		Let $\Tilde{u_f}$ be the run following $u_f$ in $\prot$, where every transition $q \xrightarrow{op} q'$ with an operation on $i$ has been replaced with $q \xrightarrow{a_{op}} q'$.
		
		By induction hypothesis we have that there exists $\Tilde{u'_f}$ shorter than $\Tilde{u_f}$, with the same start and end local configurations, a smaller input, and a sequence of local actions that is a subword of the one of $\Tilde{u_f}$.
		
		We conclude that the corresponding sequence of transitions $u_f'$ in $\prot$ is a local run with the same initial and final local configurations as $u_f$, as the value of register $i$ stays the same throughout both runs. By replacing $u_f$ with $u_f'$ in $u$, we obtain a shorter local run $u'$ of $\prot$. Let $v$ be the value that register $i$ keeps through $u_f$, the $v$-input of $u'$ 
		
		\item If no register keeps the same value for more than $TOWER$ steps, then any run $u$ of length at least $M_{r-1} ((\size{\Delta})^{M_{r-1}} +1)$ can be split into $(\size{\Delta})^{M_{r-1}} +1$ segments of size $M_{r-1}$. There are $\size{\Delta}^{M_{r-1}}$ different sequences of transitions, thus by the pigeonhole principle we have $u = \pi_1 \sigma_1 \pi_2 \sigma_2 \pi_3$ with $\size{\sigma_1} = \size{\sigma_2} = M_{r-1}$ and such that  $\sigma_1$ and $\sigma_2$ have the same sequence of transitions.
		
		Furthermore as all registers change their values every $M_{r-1}$ steps, we know that $\sigma_1$ and $\sigma_2$ contain operations of the form $\rec{m}{i}{\enregact}$ for all $i \in [1,r]$.
		
		Let $(q_1, \nu_1)$ be the local configuration at the beginning of $\sigma_1$, $(q_2, \nu_2)$ the one at the end of $\sigma_2$.
		\cortoin{TO FINISH}
	\end{itemize}
	
\end{proof}
\fi 

\iffalse
\begin{proof}
	For this proof we will allow our protocols to execute local actions from a finite alphabet $\Sigma$.
	We proceed by induction on $r$.
	
	If $r=0$ then if $\size{u} > Tower_{\size{Q}}(r+1) = \size{Q}$ then $u$ visits twice the same local configuration, and can thus be decomposed as $u_1 u_2 u_3$ where $u_2$ starts and ends in the same state, yielding the result. 
	
	Let $r>0$, suppose the proposition holds for $r-1$.
	Let $u$ be a run of $\prot$, a protocol with $r$ registers, with $\size{u} > Tower_{\size{Q}}(r+1)$.
	
	\begin{itemize}
		\item If there exists $i \in [1,r]$ such $u$ has a factor $u_f$ in which the value of register $i$ does not change and with $\size{u_f} > Tower_{\size{Q}}(r)$, then let $\Tilde{\prot}$ be $\prot$ where every operation $op$ over $i$ has been replaced with a local action $a_{op}$. Note that $\Tilde{\prot}$ only uses $r-1$ registers. 
		Let $\Tilde{u_f}$ be the run following $u_f$ in $\prot$, where every transition $q \xrightarrow{op} q'$ with an operation on $i$ has been replaced with $q \xrightarrow{a_{op}} q'$.
		
		By induction hypothesis we have that $\Tilde{u_f} = \Tilde{u_{f,1}} \Tilde{u_{f,2}}\Tilde{u_{f,3}}$ such that  $\Tilde{u_{f,1}}\Tilde{u_{f,3}}$ is a run of $\Tilde{\prot}$ with the same initial and final local configurations as $\Tilde{u_f}$. 
		
		We conclude that the corresponding sequence of transitions $u_{f,1}u_{f,3}$ in $\prot$ is a local run with the same initial and final local configurations as $u_f$, as the value of register $i$ stays the same throughout both runs.
		
		\item If no register keeps the same value for more than $M_{r-1}$ steps, then any run $u$ of length at least $M_{r-1} ((\size{\Delta})^{M_{r-1}} +1)$ can be split into $(\size{\Delta})^{M_{r-1}} +1$ segments of size $M_{r-1}$. There are $\size{\Delta})^{M_{r-1}}$ different sequences of transitions, thus by the pigeonhole principle we have $u = \pi_1 \sigma_1 \pi_2 \sigma_2 \pi_3$ with $\size{\sigma_1} = \size{\sigma_2} = M_{r-1}$ and such that  $\sigma_1$ and $\sigma_2$ have the same sequence of transitions.
		
		Furthermore as all registers change their values every $M_{r-1}$ steps, we know that $\sigma_1$ and $\sigma_2$ contain operations of the form $\rec{m}{i}{\enregact}$ for all $i \in [1,r]$.   
	\end{itemize}
\end{proof}
\fi

\begin{lemma}
	Let $\mu$ be a node of a "tree unfolding", $u_\mu$ its local run.
	Let $u$ be the local run of its father, and $u_1, \ldots, u_\ell$ the runs of its "follower" children.
	Then if $\size{u_\mu} \geq TOWER \cdot (1+ \size{u}+ \sum_{j=1}^{\ell} \size{u_j})$ then there exists a smaller tree unfolding with the same root specification label.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

\begin{definition}
	We define the ""altitude"" of a node in a "tree unfolding" recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$
		
		\item The altitude of a "boss node" is the altitude of its father minus one
		
		\item The altitude of a "follower node" is the altitude of its father plus one.
	\end{itemize}
\end{definition}

\begin{lemma}
	\label{lem:bound-length-at-height-h}
	In a minimal "tree unfolding" satisfying a given specification, the length of a local run associated with a node $\mu$ of altitude $h$ is bounded by $(TOWER (|\messages|+1))^{hmax-h+1}$
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

\begin{lemma}
	\label{lem:bound-max-height}
	The maximal altitude in a minimal tree unfolding is bounded by $f_1(\size{\prot})$ where $f_1$ is a function of the class $F_{\omega^\omega}$.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

\begin{corollary}
	The local run associated with the root of a minimal tree unfolding is bounded by $f_2(\size{\prot})$ where $f_2$ is a function of the class $F_{\omega^\omega}$.
\end{corollary}

\ifproofs
\begin{proof}
	Consequence of Lemmas~\ref{lem:bound-length-at-height-h} and~\ref{lem:bound-max-height} as $F_{\omega^\omega}$ is closed by composition with primitive recursive functions.
\end{proof}
\fi

\begin{lemma}
	\label{lem:bound-min-height}
	The absolute value of the minimal altitude in a minimal tree unfolding is bounded by $f_3(\size{\prot})$ where $f_3$ is a function of the class $F_{\omega^\omega}$.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi


\begin{corollary}
	\label{lem:bound-node-size}
	The length of a local run associated with a node of a minimal tree unfolding is bounded by $f_4(\size{\prot})$ where $f_4$ is a function of the class $F_{\omega^\omega}$.
\end{corollary}

\ifproofs
\begin{proof}
	Consequence of Lemmas~\ref{lem:bound-length-at-height-h}, \ref{lem:bound-max-height} and \ref{lem:bound-min-height} as $F_{\omega^\omega}$ is closed by composition with primitive recursive functions.
\end{proof}
\fi


\begin{proposition}
	In a minimal "tree unfolding" satisfying a given specification, the length of a branch is bounded by a function of $F_{\omega^\omega}$.
\end{proposition}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi
%\begin{lemma}
%	Given a protocol $\prot$, one can construct in polynomial time a protocol $\prot'$ with no $*$ operation satisfying the same specifications as $\prot$.
%\end{lemma}
%
%\begin{proof}
%	Let $r$ be the number of registers of $\prot$.
%	We simply add a register $r+1$ to $\prot$ and turn all $\rec{m}{i}{*}$ transitions into $\rec{m}{r+1}{\enregact}$. 
%	An easy induction shows that for all local run of $\prot$ there exists a local run of $\prot'$ with the same input and output, and vice-versa.
%\end{proof}





\begin{theorem}
	The BNRA coverability problem is decidable in $F_{\omega^\omega}$ and there is no $\alpha < \omega^\omega$ such that this problem ca be solved in $F_{\alpha}$.
	The upper bound holds even with multiple operations on messages.
	The lower bound holds even with two registers.
\end{theorem}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

