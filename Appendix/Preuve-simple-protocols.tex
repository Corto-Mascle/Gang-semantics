\section{Proof of Lemma~\ref{lem:simple-reduction}}
\label{sec:proof-simple}

\SimpleReduction*


%old statement to go from local to global, no longer useful 
% \begin{lemma}
% 	\label{lem:local-to-global}
% 	If two protocols $\prot_1, \prot_2$ are such that for all local run $u_1$ of $\prot_1$, there is a local run $u_2$ of $\prot_2$ with the same initial values as $u_1$ and such that $\Input{u_1} = \Input{u_2}$ and $\Output{u_1} = \Output{u_2}$, then for all "boss specification" $bw \in \messages^*$, if $\prot_1$ has a run satisfying $\spec$ then so does $\prot_2$.
% \end{lemma}

% \cortoin{Only useful for the local equality test elimination}
% \ifproofs
% \begin{proof}
% 	We infer this statement from the "tree unfoldings".
	
% 	Suppose $\prot_1$ satisfies a specification $\spec$, then by Lemma~\ref{lem:run-to-tree} there exists a "tree unfolding" $\tree_1$ labelled by local runs of $\prot_1$ satisfying $\spec$. 
	
% 	Let $\node$ be a node of $\tree_1$ labelled by a "local run" $u_1$ of $\prot_1$, a value $v$ and a "specification" $\spec$.  
	
% 	There exists a "local run" $u_2$ of $\prot_2$ with the same initial values, "input" and "output" as $u_1$. In particular they have the same $v$-input and $v$-output.
	
% 	We define $\tree_2$ as the tree obtained by replacing in the label of each node the local run of $\prot_1$ by a local run of $\prot_2$ with the same initial values, "input" and "output". The rest of the labels stays the same.
	
% 	Conditions \ref{unfoldingC1}, \ref{unfoldingC2} and \ref{unfoldingC3} are still satisfied on every node as they only talk about the initial values, "input" and "output" of each local run label, and the value and specification labels. None of those things have changed.
% 	Furthermore as the specification label of the root is the same for $\tree_1$ and $\tree_2$, $\tree_2$ satisfies $\spec$.
	
% 	By Lemma~\ref{lem:tree-to-run}, as $\spec$ is a "boss specification", there exists a "run" of $\prot_2$ satisfying $\spec$.
% \end{proof}
% \fi

\begin{proof}
	We construct a "protocol" $\prot'$ with no "local equality tests" so that any "run" in $\prot$ may be turned into an execution in $\prot'$ and vice-versa. 
	The intuition is as followed. $\prot'$ fundamentally encodes the same behavior as $\prot$; the only difference being how registers are treated. In $\prot'$, we abstract registers by remembering equality relations between them, so that a value shared by several registers is only stored once. We dub registers of $\prot'$ ""memory slots"" to distinguish them from the registers of $\prot$. A "memory slot" will be used to store a value shared between registers. 
	We will need $\regnum$ "memory slots" to do so. Moreover, we will need a mapping $\map : \nset{1}{r} \to \nset{1}{r}$ that tells, for each "register", in which "memory slot" its value is stored. This mapping will be directly encoded in the set of states of $\prot'$, which causes an exponential blowup in the size of the protocol.
	
	For simplicity, we allow our system to have internal transitions with no effect (such transitions could be encoded using broadcasts with a dummy message type). 
	
	Let $\prot = (Q, \messages, \transitions', q_0, \regnum)$. 
	We define $\prot' := (Q', \messages, \transitions', q_0', \regnum +1)$ as follows. The set of states is $Q' := Q \times (\nset{1}{r} \to \nset{1}{r})$, its initial state is $q_0' := (q_0, \idmap)$ where $\idmap(i) = i$ for all $i \in \nset{1}{r}$. 
	
	The set of transitions $\transitions'$ is defined as follows.
	For all $q,q' \in Q$ and $\map, \map' \in \nset{1}{r} \to \nset{1}{r}$, we have $((q, \map), \op, (q', \map')) \in \transitions'$ in the following cases:
	
	\begin{itemize}
		\item $\op = \br{m}{j}$, 
		$\map = \map'$ and $(q, \br{m}{i}, q') \in \transitions$ for some $i$ such that $\map(i) = j$ (we broadcast the value stored in the corresponding "memory slot").
		
		\item $\op=\rec{m}{j}{\enregact}$, there is a transition $(q, \rec{m}{i_0}{\enregact}, q') \in \transitions$ with $\map^{-1}(j) \subseteq \set{i_0}$ and for all $i \in \nset{1}{r}$, if $i \ne i_0$ then $\map'(i) = \map(i)$ and $\map'(i_0) = j$ (the received value is stored into a fresh "memory slot").
		
		\item $\op = \rec{m}{j}{\eqtestact}$ and either
		\begin{itemize}
			\item there is a transition $(q, \rec{m}{i}{\eqtestact}, q') \in \transitions$ such that $\map(i)=j$ and $\map'=\map$ (to test equality with register $i$, we test equality with the "memory slot" containing value of register $i$), or
			
			\item there is a transition $(q, \rec{m}{i_0}{\enregact}, q') \in \transitions$ such that $\map'(i_0)=j$ and $\map'(i) = \map(i)$ for every $i \neq i_0$ (register $i_0$ stores a value that is already in a "memory slot" hence we simply modify the mapping).
		\end{itemize} 
		
		\item $\op = \rec{m}{j}{\diseqtestact}$ and there is a transition $(q, \rec{m}{i}{\diseqtestact}, q') \in \transitions$ such that $\map(i)=j$ (to test disequality with register $i$, we test disequality with the "memory slot" containing value of register $i$).
		

		\item $\op=\loc{j_1}{j_2}{\diseqtestact}$ and there is a transition $(q, \loc{i_1}{i_2}{\diseqtestact}, q')$ such that $\map(i_1)=j_1$ and $\map(i_2) = j_2$ (to implement a local disequality test, we do the corresponding test on "memory slots"; this test always fails if $j_1 = j_2$).
		
		
		\item $\op = \rec{m}{j}{\dummyact}$ and there is a transition $(q, \rec{m}{i}{\dummyact}, q') \in \transitions$ for some $i \in \nset{1}{r}$.
	\end{itemize}
	
	Additionally, there is an internal transition between $(q,\map)$ and $(q',\map')$ whenever there exist $i_1, i_2$ such that $(q, \loc{i_1}{i_2}{\eqtestact}, q') \in \transitions$ and $\map(i_1) = \map(i_2)$ (an equality test on two registers mapped to the same memory slot automatically succeeds).

	Note that we cannot in fact guarantee that values stored in the "memory slots" are all distinct, because, upon reception of a value, we may only do one test and therefore cannot test that it is different from all other values. This is why we still need disequality tests in our new protocol. In practice, when a agent in $\prot$ performs a $\quotemarks{\enregact}$ reception of a broadcast with a value that is already in one of its "memory slots", the corresponding agent in $\prot'$ may non-deterministically notice that it already has this value in a "memory slot" (corresponds to a $\rec{\amessage}{j}{\eqtestact}$ transition), but it may also store it in a fresh "memory slot" (corresponds to a $\rec{\amessage}{j}{\enregact}$ transition). This will not be an issue because storing a value $\aval$ into several "memory slots" will allow less behaviors than noticing the equality upon reception and updating $\map$ accordingly.

	We now prove that, for a given state $q_f \in Q$, $q_f$ may be covered in $\prot$ if and only if $Q_f' := \set{(q_f, \map) \mid \map \in \nset{1}{r} \to \nset{1}{r}}$ may be covered. To do so, we will prove that any run of $\prot$ may be turned into a run of $\prot'$ and vice-versa. Observe that the last condition could be converted to a single-state \COVER condition by adding a final state and, from every state in $Q_f'$, an internal transition to this final state.
  
	Let $\agents \subseteq \nats$.
	Given a configuration $\config$ of $\prot$, we denote by \AP $\intro*\memoryproj{\config}$ 
	the set of states $\config' \in Q'$ over set of agents $\agents$ such that:
	 for all $a \in \agents$, by denoting $(q, \localdata):= \config(a)$, one has $\config'(a) = ((q, \map), \localdata')$ where, for every $i \in \nset{1}{r}$, $\localdata'(\map(i)) = \localdata(i)$. 
	Moreover, we denote by \AP $\intro*\perfproj{\config}$ 
	the subset of $\memoryproj{\config}$ containing configurations 
	$\config'$ that additionally satisfy that, for every $j \ne j' \in \nset{1}{r}$, $\localdata'(j) \ne \localdata(j')$ (we call those ""perfect configurations"" of $\prot'$).

	Let $\run: \config_0 \step{*} \config_f$ a run on $\prot$ over some set of agents $\agents$. We prove by induction on the length of $\run$ that there exists a run $\run': \config_0' \step{*} \config_f'$ on $\prot'$ such that $\config_f' \in \perfproj{\config_f}$. This property is trivially true for $\run$ of length $0$. It therefore suffices to prove that if $\config_1 \step{} \config_2$ and given $\config_1' \in \perfproj{\config_1}$, there exists $\config_2' \in \perfproj{\config_1}$ such that $\config_1 \step{} \config_2$. We denote by $s$ the step $\config_1 \step{} \config_2$; and by $s'$ the step $\config'_1 \step{} \config'_2$ that we are trying to build. 
	Let $a \in \agents$ that performs a transition in $s$.
	\begin{itemize}
	\item If $a$ performs a local test $\loc{i_1}{i_2}{\diseqtestact}$ in $s$, then it may perform the correspondign local test in $s'$ because $\config_1' \in \perfproj{\config_1}$ hence $\config_1'(a)$ maps $i_1$ and $i_2$ to "memory slots" of distinct values. 
	\item If $a$ performs a local test  $\loc{i_1}{i_2}{\eqtestact}$, then because $\config_1'\in \perfproj{\config_1}$, it maps $i_1$ and $i_2$ to the same "memory slot" and $a$ may performs the corresponding internal transition in $\prot'$.  
	\item If $a$ performs a broadcast in $s$, then we make it perform the corresponding broadcast in $s'$. Note that, because $\config_1' \in \memoryproj{\config_1}$, the broadcasted value is the same in $s$ and $s'$. 
	\item 
	Suppose now that $a$ performs a reception $\rec{\amessage}{i}{\anact}$ in $s$. Let $\aval$ the value of the message. By above, the corresponding broadcast is performed in $s'$ with the same value $\aval$. 
		\begin{itemize}
		\item If $\anact = \quotemarks{\dummyact}$, then we can without condition make $a$ perform the corresponding transition in $s'$. 
		\item If $\anact = \quotemarks{\eqtestact}$, then if $\aval$ appears in some "memory slot" in $\aval$, we make $a$ perform the corresponding $\rec{\amessage}{j}{\eqtestact}$ transition in $s'$ with $j$ the index of the "memory slot". 
		If $\aval$ does not appear in any "memory slot", then we make $a$ take the $\rec{\amessage}{j}{\enregact}$ transition with $j$ a "memory slot" that did not store the value of any register other that $i$. This case disjunction guarantees guarantees that $\config_2'(a)$ does not have twice the same value in its "memory slots".
		\item If $\anact = \quotemarks{\diseqtestact}$, then we make $a$ perform the corresponding transition in $s'$; the disequality tests passes because, since $\config_1' \in \memoryproj{\config_1}$, the values of the "memory slots" of $i_1$ and $i_2$ in $\config_1'(a)$ are not equal.
		\end{itemize}
	\end{itemize}

	Overall, we have built $\config_2' \in \perfproj{\config_2}$ such that $\config_1' \step{} \config_2'$ in $\prot'$, which concludes the induction. We have proven that for every $\run: \config_0 \step{*} \config_f$ there exists $\run': \config_0' \step{*} \config_f'$ on $\prot'$ such that $\config_f' \in \perfproj{\config_f}$. This proves that if $q_f$ may be covered in $\prot$, then $Q_f'$ may be covered in $\prot'$. 
% 	We prove by induction on $\size{u}$ that for all "local run" $u$ of $\prot$ there exists a "local run" $u'$ of $\prot'$ with the same "trace" and such that if the last configuration of $u$ is $(q,\nu)$ and the last configuration of $u'$ is $((q',map), \nu')$ then $(q', map') \xrightarrow{\varepsilon}^* (q, map')$, for all $i$, $\nu(i) = \nu'(map(i))$ and for all $i_1, i_2$, if $\nu(i_1)=\nu_{i_2}$ then $map(i_1) = map(i_2)$.  
	
% 	If $\size{u} = 0$, let $(q_0, \nu_0)$ be its initial configuration, then we simply set $u'$ as an empty "local run" with the initial configuration $((q_0, id), \nu'_0)$ where $\nu'_0(i) = \nu_0(i)$ for all $i \in \nset{1}{r}$ and $\nu_0(r+1)$ is a fresh value.
	
% 	If $\size{u}>0$, let $\Tilde{u}$ be $u$ without its last step. Let $(q, \nu)$ be the last "local configuration" of $u$, $(\Tilde{q}, \Tilde{\nu})$ the one of $\Tilde{u}$.
	
% 	By induction hypothesis there exists $\Tilde{u}'$ a local run of $\prot'$ with the same "trace" to a "local configuration" $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$ such that $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and for all $i \in \nset{1}{r}$, $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i)$.
	
% 	\begin{itemize}
% 		\item 
% 		If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\br{m}{i}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\br{m}{j}} (q, \Tilde{map}')$ with $j=\Tilde{map}'(i)$.
		
% 		We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\br{m}{j}} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$, $map' = \Tilde{map}'$ and $\nu' = \Tilde{\nu}'$. 
% 		This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\br{m}{j}} (q, \Tilde{map}')$.   
		
% 		The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, $\Tilde{map'} = map'$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,\Tilde{\nu}'(\Tilde{map}'(i)),out) = \trace{\Tilde{u}} (m,\Tilde{\nu}(i),out) = \trace{u}$.
		
% 		\item 
% 		If the last step of $u$ is an "external message" $(\Tilde{q}, \Tilde{\nu}) \extbr{m, v} (q, \nu)$ then let $j\in \nset{1}{r+1}$ be such that $\Tilde{map}'^{-1}(j) = \emptyset$ (such a $j$ exists as $\size{map(\nset{1}{r})} = r < r+1$). There is a transition $\Tilde{q} \xrightarrow{\rec{m}{i_0}{\alpha}} q$ in $\prot$ such that $\nu(i)=\Tilde{\nu}(i)$ for all $i\neq i_0$ and we are in one of the following cases:
		
% 		\begin{itemize}
% 			\item $\alpha=\enregact$, $\nu(i_0) = v$ and there exists $i_1 \neq i_0$ such that $\nu(i_1) = v$. Let $j_1=\Tilde{map}'(i_1)$
% 			There is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j_1}{\eqtestact}} (q, map')$ in $\prot'$ with $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and $map'(i_0) = j_1$.
			
% 			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
% 			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j_1}{\eqtestact}} (q', map')$. 
			
% 			We have $(q', map') = (q, map')$, $\nu'(map'(i_0)) = v = \nu(i_0)$ and $\nu'(map'(i)) = \Tilde{\nu}'(map'(i)) = \Tilde{\nu}(i) = \nu(i)$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
% 			Furthermore for all $i', i'' \in \nset{1}{r}\setminus\set{i_0}$, if $\nu(i') = \nu(i'')$ then $map'(i') = \Tilde{map}'(i') = \Tilde{map}'(i'') = map'(i'')$, and for all $i' \in \nset{1}{r}$, if $\nu(i')=\nu(i_0)$ then $\nu(i')=\nu(i_1)$ and thus $map'(i') = map'(i_1) = map'(i_0)$.
% 			Thus the resulting $u'$ satisfies the conditions
			
% 			\item $\alpha=\enregact$, $\nu(i_0) = v$ and for all $i_1 \neq i_0$, $\nu(i_1) \neq v$. 
% 			There is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q, map')$ in $\prot'$ with $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and $map'(i_0) = j$.
			
% 			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu'(j') = \Tilde{\nu}'(j')$ for all $j' \neq j$ and $\nu'(j) = v$.
			
% 			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q', map')$. 
			
% 			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, we have $\nu'(map'(i_0)) = v = \nu(i_0)$ and $\nu'(map'(i)) = \Tilde{\nu}'(map'(i)) = \Tilde{\nu}(i) = \nu(i)$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
% 			\item $\alpha = \eqtestact$, $\nu(i_0) = \Tilde{\nu}(i_0) = v$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\eqtestact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$ and $j = \Tilde{map}'(i_0)$.
			
% 			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
% 			This step can be taken as $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i) = v$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\eqtestact}} (q', map')$.
			
% 			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
% 			\item $\alpha = \diseqtestact$ and $\nu(i_0) = \Tilde{\nu}(i_0) \neq v$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\diseqtestact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$ and $j = \Tilde{map}'(i_0)$.
			
% 			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
% 			This step can be taken as $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i) \neq v$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\diseqtestact}} (q', map')$.
			
% 			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
% 			\item $\alpha = \dummyact$ and $\nu(i_0) = \Tilde{\nu}(i_0)$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$.
			
% 			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
% 			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q', map')$.
			
% 			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$. 
% 		\end{itemize}
		
% 		\item 
% 		If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\eqtestact}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\varepsilon} (q, \Tilde{map}')$.
		
% 		We set $u' = \Tilde{u}'$. The last configuration of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$. It satisfies the conditions as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}') \xrightarrow{\varepsilon} (q, \Tilde{map}')$ and the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$.
		
% 		\item 
% 		If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} (q, \Tilde{map}')$ with $j_1=\Tilde{map}'(i_1)$ and $j_2=\Tilde{map}'(i_2)$.
		
% 		We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$, $map' = \Tilde{map}'$ and $\nu' = \Tilde{\nu}'$. 
% 		This step can be taken as $\Tilde{\nu}'(j_1) = \Tilde{\nu}(i_1) \neq \Tilde{\nu}(i_2) = \Tilde{\nu}'(j_2)$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} (q, \Tilde{map}')$.   
		
% 		The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$ and the "traces" and final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$.
% 	\end{itemize}
	
% 	This concludes our first induction.
	
% 	We now prove by induction on $\size{u'}$ that for all "local run" $u'$ of $\prot'$ there exists a "local run" $u$ of $\prot$ with the same "trace" and such that if the last configuration of $u$ is $(q,\nu)$ and the last configuration of $u'$ is $((q',map), \nu')$ then $q=q'$ and for all $i$, $\nu(i) = \nu'(map(i))$.  
	
% 	If $\size{u'} = 0$, let $(q_0, \nu'_0)$ be its initial configuration, then we  set $u$ as an empty "local run" with the initial configuration $((q_0, id), \nu_0)$ where $\nu_0(i) = \nu'_0(i)$ for all $i \in \nset{1}{r}$.
	
% 	If $\size{u}>0$, let $\Tilde{u}'$ be $u'$ without its last step. Let $((q', map'), \nu')$ be the last "local configuration" of $u'$, $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$ the one of $\Tilde{u}'$.
	
% 	By induction hypothesis there exists $\Tilde{u}$ a local run of $\prot$ with the same "trace" as $u'$ to a "local configuration" $(\Tilde{q}, \Tilde{\nu})$ such that $\Tilde{q}'=\Tilde{q}$ and for all $i \in \nset{1}{r}$, $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i)$.
	
% 	\begin{itemize}
% 		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\br{m}{j}} ((q', map'), \nu')$, then $\Tilde{map}' = map'$ and there exists $q \in Q$ and $i \in \nset{1}{r}$ such that $map'(i)=j$ and $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\br{m}{i}} q'$ is a transition of $\prot$.
		
% 		As $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, there is a path in $\prot$ from $\Tilde{q}$ to $q$ consisting only of transitions labelled by operations of the form $\loc{i_1}{i_2}{\eqtestact}$ with $\Tilde{map}'(i_1) = \Tilde{map}'(i_2)$ and thus $\Tilde{\nu}(i_1) = \Tilde{\nu}(i_2)$.
% 		As a result, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
		
% 		We then append a step $(q, \Tilde{\nu}) \xrightarrow{\br{m}{i}} (q', \nu)$ at the end of that local run to obtain $u$. As $j = map(i)$, we have $\Tilde{\nu}(i) = \Tilde{\nu}'(j)$ and thus $\trace{u} = \trace{\Tilde{u}}(m, \Tilde{\nu}(i), out) = \trace{\Tilde{u}'}(m, \Tilde{\nu}'(j), out) = \trace{u'}$.
		
% 		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$, then there exists a transition  $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j_0}{\alpha}} (q', map')$ and $i_0 \in \nset{1}{r}$ such that $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and we are in one of the following cases:
		
% 		\begin{itemize}
% 			\item $\alpha = \enregact$ and $\nu'(j_0)=v$. Then there exists $q \in Q$ and $i \in \nset{1}{r}$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\beta}} q'$ is a transition of $\prot$
			
% 			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
			
% 			We have either
% 			\begin{itemize}
% 				\item $\beta=\enregact$ and $map'(i_0) = j_0$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu(i_0)=v$ and $\nu(i) = \Tilde{\nu}(i)$ for all $i \neq i_0$.
				
% 				\item $\beta=\dummyact$ and $map' = \Tilde{map}'$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu = \Tilde{\nu}$.
% 			\end{itemize}
			
% 			\item $\alpha = \eqtestact$ and $map'(i_0)=\Tilde{map}'(i_0)$ and $\nu'(j_0) = \Tilde{\nu}'(j_0) = v$. Then there exists $q \in Q$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\beta}} q'$ is a transition of $\prot$.
			
% 			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
			
% 			We have either
% 			\begin{itemize}
% 				\item $\beta=\eqtestact$ and $map' = \Tilde{map}'$ and $\Tilde{\nu}(i_0) = v$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu = \Tilde{\nu}$.
				
% 				\item $\beta=\enregact$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu(i_0) = v$ and $\nu(i)=\Tilde{\nu}(i)$ for all $i \neq i_0$.
% 			\end{itemize}
			
% 			\item $\alpha = \diseqtestact$ and $map'(i_0)=\Tilde{map}'(i_0) \neq v$. Then there exists $q \in Q$ and $i_0 \in \nset{1}{r}$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\diseqtestact}} q'$ is a transition of $\prot$.
			
% 			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same "trace" as $\Tilde{u}$.
			
% 			We add a step $(\Tilde{q}, \Tilde{\nu}) \extbr{m,v} (q, \nu)$ at the end to obtain $u$, with $\nu = \nu'$.
% 		\end{itemize}
		
% 		In all cases, the conditions are respected, as $\trace{u} = \trace{\Tilde{u}} (m,v, in) = \trace{\Tilde{u}'} (m,v, in) = \trace{u'}$.
		
% 		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} ((q', map'), \nu')$ then $map'=\Tilde{map}'$, $\nu' = \Tilde{\nu}'$, $\nu'(j_1) \neq \nu'(j_2)$ and there exists $q \in Q$ and $i_1, i_2 \in \nset{1}{r}$ such that $map'(i_1)=j_1$, $map'(i_2)=j_2$ and $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} q'$ is a transition of $\prot$.
		
% 		Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same "trace" as $\Tilde{u}$.
		
		
% 		We append a step $(q, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} (q', \nu)$ at the end of that local run to obtain $u$, with $\nu = \Tilde{\nu}$. We have $\Tilde{\nu}(i_1) = \Tilde{\nu}'(j_1) \neq \Tilde{\nu}'(j_2) = \Tilde{\nu}(i_2)$ and thus $\trace{u} = \trace{\Tilde{u}} = \trace{\Tilde{u}'} = \trace{u'}$.
% 	\end{itemize}
	
% 	We have shown that $\prot$ and $\prot'$ produce the same set of "traces" from their "local runs". As the "input" and "output" of a local run depend only on its "trace", we obtain the result by Lemma~\ref{lem:local-to-global}.
\end{proof}
