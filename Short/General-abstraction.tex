\section{Coverability Decidability for Signature Protocols}
\label{sec:cover-decidability}

This section and the next one are dedicated to the proof of the main result of this paper:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for BNRA is decidable and $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

For the sake of clarity, in this section, we will first focus on the case of "signature BNRA". 
As a preliminary, we start by defining a notion of "local run" meant to represent the projection of a run onto a given agent.

\subsection{Local runs}
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$ and $\atrans =(q, \br{m}{i}, q')$ is a "broadcast".  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and one of the following holds:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either a "reception step" or an "internal step". 
	\AP A ""local run"" $\localrun$ is a sequence of "local steps" denoted $(q_0, \nu_0) \step{*} (q, \nu)$. %where $\nu_0$ has distinct values.
	A value $\aval \in \nats$ appearing in $\localrun$ is ""initial"" if it appears in $\nu_0$ and ""non-initial"" otherwise. 
	The ""input"" of $\localrun$, written $\intro*\Input{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of its "reception steps", its ""output"", written $\intro*\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages broadcast in $\localrun$. 
	% The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. 
	For $\aval \in \nats$, the $\aval$-""input"" $\intro*\vinput{\aval}{\localrun}$ (resp. $\val$-""output"" $\intro*\voutput{\aval}{\localrun}$) is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ (resp. $\Output{\localrun}$) on $\messages \times \set{\aval}$.

\subsection{Unfolding Trees}
\label{sec:unfolding_tree_signature}

We first prove decdability of \COVER for "signature BNRA". Note that, in "signature protocols", the initial values of "reception-only" registers are not relevant as they can never be shared with other agents. When an agent receives a message, it can compare the value of the message only with the ones of previously received messages, \emph{i.e.}, check whether the sender is the same. Therefore, we describe what an agent $a$ needs from other agents as a set of ""specifications@@signature"" which are words of $\messages^*$. A "specification@@sg" $m_1 \dots m_k \in \messages^*$ is accomblished by an agent if it broadcasts message types $m_1, \dots, m_k$ in this order. To represent runs, we consider "unfolding trees@@signature" that represent such specifications, dependencies between them and how they are carried out. Because of copycat arguments, we will in fact be able to clone agents so that each agent only accomplishes one task, hence the tree structure.
An ""unfolding tree@@sg"" is an abstraction of a "run" into a tree where each node is assigned a "local run" and the "specification" that it carries out. 

\begin{definition}
\label{def:unfolding_tree_signature}
\AP An ""unfolding tree@@sg"" $\tree$ over $\prot$ is
a finite tree where nodes $\node$ have three labels:
\begin{itemize}
	\item a "local run" of $\prot$, written $\intro*\localrunlabel{\node}$;
	
	\item a value in $\nats$, written $\intro*\valuelabel{\node}$;
	
	\item a ""specification"" $\intro*\speclabel{\node} \in \messages^*$.
\end{itemize} 
Moreover, all nodes $\node$ in $\tree$ must satisfy the three following conditions:
\begin{enumerate}[label= (\roman*), ref=(\roman*)]
	\item \label{item:condition1_initial_value_sg} Initial values of $\localrunlabel{\node}$ are never received in $\localrunlabel{\node}$,
	\item \label{item:condition2_non_initial_value_sg} For each value $\aval$ received in $\localrunlabel{\node}$, $\node$ has a child $\node'$ s.t. $\vinput{\aval}{\localrunlabel{\node}} \subword \speclabel{\node'}$,
	\item \label{item:condition3_boss_node_sg} $\speclabel{\node} \subword \voutput{\valuelabel{\node}}{\localrunlabel{\node}}$.
\end{enumerate}

\AP Lastly, given $\tree$ an "unfolding tree@@sg", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\node}$ where $\size{\node} := \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@tree" of $\tree$ takes into account the size of its nodes, so that a tree $\tree$ can be stored in space polynomial in $\size{\tree}$ (renaming the values appearing in $\tree$ if needed). 
\end{definition}
% subword explaination
Let $\node$ a "node@@sg" of an "unfolding tree@@sg" $\tree$. Condition \ref{item:condition2_non_initial_value_sg} enforces that the "local run" is cannot cheat by receving its "initial values" (an agent cannot never receive its "initial values" in a "run" of a "signature protocol"). 
Condition \ref{item:condition2_non_initial_value_sg} expresses that the "specifications" of children of $\node$ are witnesses that messages received in the "local run" $\localrunlabel{\node}$ can be broadcast by other agents. Condition \ref{item:condition3_boss_node_sg} expresses that $\node$ witnesses the broadcast of word $\speclabel{\node}$ by some agent. We can use the subword relation $\subword$, and not equality, because of the lossiness: all received messages must be broadcast, but some broadcast messages may not be received.  

\begin{figure}[t]
	\centering
	\resizebox*{!}{3cm}{
	\input{Figures/fig-ex2}
	}
	\caption{Example of a "signature protocol".}\label{fig:ex2}\label{fig:example-signature-protocol}
\end{figure}
\begin{example}
\label{ex:protocol-signature}
	Figure~\ref{fig:example-signature-protocol} provides an example of a "signature protocol".
Let $\agents = \set{a_1, a_2,a_3}$, let $\run$ the run where the following occurs, where $\tuple{\st{\config}(a_1),\st{\config}(a_2),\allowbreak \st{\config}(a_3)}$ denotes of states of $a_1$, $a_2$ and $a_3$ in $\config$ (register values are omitted):
\begin{itemize}
\item $a_2$ broadcasts $\exready$, $a_1$ receives: $\tuple{q_1, q_0,q_0}$,
\item $a_3$ broadcasts $\exready$, $a_1$ and $a_2$ receive: $\tuple{q_2, q_5,q_0}$,
\item $a_2$ broadcasts $\exready$, $a_3$ receives: $\tuple{q_2,q_5,q_5}$,
\item $a_2$ broadcasts $\exgotwo$, $a_1$ receives:  $\tuple{q_3,q_6,q_5}$,
\item $a_3$ broadcasts $\exgothree$, $a_1$ received: $\tuple{q_4,q_6,q_7}$.
\end{itemize}
	
Observe that the equality tests pass because $a_1$ stores $a_2$'s identifier in its second register and $a_3$'s identifier in its third register. Figure~\ref{fig:ex-unfolding-tree-signature} provides an unfolding tree obtained from $\run$ by applying a procedure introduced later. Because agents $a_2$ and $a_3$ broadcast to several other agents, they each correspond to several nodes of the tree.  
% the following sequence is an initial run covering $q_4$:
	% \begin{align*}
	% 	&\tuple{(q_0, (\valsymb{1},2,3)), (q_0, (x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \tuple{(q_1, (x_1,x_2,z_1)), (q_5,(x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \\ 
	% 	&\tuple{(q_2, (x_1,x_2,x_3)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \tuple{(q_3, (x_1,x_2,x_2)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \\
	% 	&\tuple{(q_4, (x_1,x_2,x_2)),(q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} 
	% \end{align*}
	% For readability's sake we don't write the second and third registers' values of agent $a_2$ and $a_3$ as there are neither broadcast, tested and nothing is store on those registers during the run.
	% First agent $a_2$ broadcasts message $hello$ with its second register's value, then $a_3$ broadcasts message $hey$ with its third register's value. Then, agent $a_2$ broadcasts message $ack$ with its second register's value and finally, agent $a_3$ broadcasts the same message but with its third register's value.
	% All messages are received by agent $a_1$ which hence reaches $q_4$.
	% We show now how to build the unfolding tree regarding the local run of agent $a_1$ in \cref{fig:unfolding-tree-sign}. Tables are (part of) "local runs", columns are (part of) "local configurations": we only display registers used in the local runs (the one broadcast or with a reception action on it). For $\node_2$, the transition between $q_0$ and $q_5$ should be understood as the broadcast of $hello$, whereas for $\node_3$ it should be understand as the broadcast of $hey$.
	% The local run of node $\node_1$ is the local run of agent $a_1$ of the run described above. 
	% By completing partial local runs by fresh integers in the other registers, one can verify that all nodes are labeled by local runs of the protocol (where the broadcast between $q_0$ and $q_5$ is with $hello$ for $\node_2$, and with $hey$ for $\node_3$).
	We explain why this tree is an "unfolding tree@@sg". Condition \ref{item:condition1_initial_value_sg} is trivially satisfied. Condition  \ref{item:condition2_non_initial_value_sg} is satisfied at $\node_1$: $\vinput{2}{\localrunlabel{\node_1}}= \exready \cdot \exgotwo = \speclabel{\node_2}$ and $\vinput{3}{\localrunlabel{\node_1}}= \exready \cdot \exgotwo = \speclabel{\node_3}$.
	It is also satisfied at $\node_2$, $\node_3$ and $\node_5$ because their local runs only receive $\exready$ and they each have a child with "specification@@sg" $\exready$. 
	It is trivially satisfied at $\node_4$ and $\node_6$ as their "local runs" have no reception. 
	Condition \ref{item:condition3_boss_node_sg} holds at every node because the local run of each node exactly broadcasts the "specification@@g" of the node. 
	% Values received in $\localrunlabel{\node_1}$ are $x_2$ and $x_3$, hence from condition \ref{item:condition2_non_initial_value_sg}, node $\node_1$ has two children $\node_2$ and $\node_3$. Note that $\vinput{x_2}{\localrunlabel{\node_2}} = \vinput{x_3}{\localrunlabel{\node_3}} = \epsilon$\lu{si on modifie la condition, on peut enlever cette phrase}. As $\spec(\node_1) = \epsilon$, condition \ref{item:condition3_boss_node_sg} is trivially true for $\node_1$. Note that nodes $\node_2$ and $\node_3$ don't receive any message on their respective local runs and so condition \ref{item:condition2_non_initial_value_sg} is trivially true. Furthermore, $\voutput{x_2}{\localrunlabel{\node_2}} = hello \cdot ack = \spec(\node_2)$ and $\voutput{x_3}{\localrunlabel{\node_3}} = hey \cdot ack = \spec(\node_3)$
\end{example}


\begin{figure}[t]
	\centering
	\input{Figures/tree-example-sign}
	\vspace{-0.5cm}
	\caption{Example of an unfolding tree derived from $\run$. Grids correspond to "local runs", a row representing a "local configuration"; $\atrans_{ij}$ denotes the transition between state $q_i$ and state $q_j$, for example $\atrans_{01} = (q_0, \rec{\exready}{2}{\enregact}, q_1)$. Initial values of "reception-only" registers are irrevelant and written as $\quotemarks{\_}$.}
	\label{fig:unfolding-tree-sign}\label{fig:ex-unfolding-tree-signature}
\end{figure}

\begin{lemma}
\label{lem:coverability_witness_sg}
Given a "signature protocol" $\prot$ with a state $q_f$, $(\prot,q_f)$ is a positive instance of \COVER if and only if there exists an "unfolding tree@@sg" whose root node's local run covers $q_f$. We call such an "unfolding tree@@sg" a ""coverability witness@@sg"".
\end{lemma}
\begin{proof}
Given an "execution" $\run$, agent $a$ \emph{satisfies a "specification@@sg"} $w \in \messages^*$ in $\run$ if the sequence of "message types" broadcast by $a$ admits $w$ as "subword".% if such an agent $a$ exists, we say that $\run$ satisfies "specification@@sg" $w$.   

% Suppose that we have such an "covrability witness@@sg" $\tree$. 
We prove by induction on the size of $\tree$ the following property: for every "unfolding tree" $\tree$, by letting $\node$ the root of $\tree$, there exists a "run" $\run$ with an agent $a$ satisfying the "specification@@sg" $\speclabel{\node}$ and whose "local run" in $\run$ is $\localrunlabel{\node}$. Let $\node$ the "root" of $\tree$, $\localrun := \localrunlabel{\node}$ and $\aval_1, \dots, \aval_c$ the values received in $\localrun$. These values are "non-initial" thanks to condition~\ref{item:condition1_initial_value_sg}; applying condition \ref{item:condition2_non_initial_value_sg} gives the existence of corresponding children $\node_1, \dots, \node_c$ in $\tree$. We apply the induction hypothesis on the "subtrees" rooted in $\node_1, \dots, \node_c$ to obtain "runs" $\run_1, \dots, \run_c$ satisfying the "specifications@@sg" of the children of $\node$. Up to renaming agents, we can assume the set of agents of these runs are disjoint; up to renaming values, we can assume that $\aval_j = \valuelabel{\node_j}$ for all $j$ and that all agents start with distinct values. We build an "initial run" $\run$ whose "agents" is the union of the "agents" of the $c$ runs along with a fresh agent $a$. In $\run$, we make $\run_1$ to $\run_c$ progress in parallel and make $a$ follow the "local run" $\localrun$, matching reception with value $v_j$ in $\localrun$ with a broadcast in $\run_j$. This is possible because, for all $j$, $\vinput{v_j}{\localrun} \subword \speclabel{\node_j} \subword \voutput{v_j}{\run_j}$. 

Conversely, we prove the following by induction on the length of $\run$: for every "initial run" $\run$, for every agent $a$ in $\run$ and for every $v \in \nats$, there exists an "unfolding tree" whose root has "local run" the projection of $\run$ onto $a$ and "specification@@sg" the $v$-output of $a$ in $\run$. If $\run$ is the empty run, consider the "unfolding tree" with a single node whose "local run" and "specification@@sg" are empty. Suppose now that $\run$ has non-zero length, let $a$ an agent in $\run$, $v \in \nats$ and let $\run_p$ the prefix run of $\run$ of length $\size{\run}-1$.
Let $\tree_1$ the "induction tree" obtained by applying the induction hypothesis to $\run_p$, $a$ and $v$, and consider $\tree_2$ obtained by simply appending the last step of $a$ in $\run$ to the "local run" at the root of $\tree_1$. If this last step is a broadcast, we obtain an "unfolding tree"; if the broadcast value is $v$, we append the broadcast "message type" to the "specification@@sg" at the root of $\tree_2$ and we are done. 
Suppose that, in the last step of $\run$, $a$ performs a reception $(q, \rec{m}{i}{\anact},q')$ of a message $(m,\aval')$. We might need to adapt $\tree_2$ to respect condition \ref{item:condition2_non_initial_value_sg} at the root. Let $a'$ the agent broadcasting in the last step of $\run$. Let $\tree_3$ the "unfolding tree@@sg" obtained by applying the induction to $\run_p$, $a'$ and $v'$. Let $\tree_4$ the "unfolding tree@@sg" obtained by appending the last broadcast to the "local run" at the root of $\tree_3$ and the corresponding "message type" to the "specification@@sg" at the root of $\tree_3$. Attaching $\tree_4$ below the root of $\tree_2$ gives an "unfolding tree@@sg" satisfying the desired properties. 
% Note that this construction may generate more children than needed at the root - maybe another child was already there to witness broadcasts of $a'$ in $\run_p$, in which case this child may be deleted. 
\end{proof}


	The "unfolding tree" $\tree$ of Figure~\ref{fig:ex-unfolding-tree-signature} is built from $\run$ of Example~\ref{ex:protocol-signature} using the previous procedure. \nico{c'est un peu faux car la procédure ci-dessus pourrait dupliquer $\node_2$ et $\node_3$: grave ou pas grave?}\lu{pour moi pas grave }
	 Observe that the "unfolding tree" $\tree$  is a "coverability witness" for $q_4$. However, one can find a smaller "coverability witness". 
	Indeed, in the right branch of $\tree$, $\node_5$ and $\node_6$ have the same "specification@@sg", therefore $\node_5$ can be deleted and replaced with $\node_6$. In fact, we would have also been able to shorten the tree if we only had $\speclabel{\node_5} \subword \speclabel{\node_6}$; we will use this argument to bound the size of the smallest "coverability witness".   

\subsubsection{Bounding the Size of the Unfolding Tree}
We formalize the idea above:

\begin{lemma}
\label{lem:no_subword_in_branch_sg}
Let $\tree$ be a "coverability witness@@sg" for $(\prot,q_f)$ with $\prot$ a "signature protocol". Let $\node, \node'$ be two nodes of $\tree$ such that $\node$ is a strict ancestor of $\node'$. If $\speclabel{\node} \subword \speclabel{\node'}$, then there exists a "coverability witness@@sg" for $(\prot, q_f)$ of size strictly smaller than $\size{\tree}$.
\end{lemma}
\begin{proof}
It suffices to replace the subtree rooted in $\node$ with the one rooted in $\node'$.
\end{proof}

With the previous lemma, we would now like to use the "Length function theorem" to bound the size of the tree. However, to do that, we first need a bound on the "size@@treesg" of a node with respect to its parent's "size@@treesg". The following lemma essentially states that the local run of a node may be bounded by a primitive recursive function with respect to the "size@@sg" of its "specification@@sg".

\begin{lemma}
\label{lem:towerbound_signature}
There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "signature protocol" with $r+1$ registers, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ such that $\size{u'} < \towerfun(\size{\prot},r)$ and for all value $v' \in \nats$, there exists $v \in \nats$ such that  $\vinput{v'}{u'} \subword \vinput{v}{u}$. 
\end{lemma}
\begin{proof}
We define $\towerfun(n,k)$ by $\towerfun(n,0) = n+1$ and $\towerfun(n,k+1) = \towerfun(n,k) \cdot ({\size{\transitions}}^{\towerfun(n,k)}+1)$. Observe that $\towerfun(n,k)$ is a tower of exponentials of height $k$, which is primitive-recursive although non-elementary. Register $i$ is ""active@@sg"" in $u$ if $u$ has some $\quotemarks{\enregact}$ action on register $i$. Let $u$ a "local run", $k$ the number of "active@@sg" registers in $\localrun$, $n := \size{\prot}$ and $M := \towerfun(n,k)$.
We prove by induction on the number $k$ of "active@@sg" registers in $u$  that if $\size{u} >\towerfun(n,k)$ then $u$ can be shortened. 
 

If $k=0$, any state repetition can be removed. Suppose that $\size{u} > \towerfun(n,k+1)$ and that the set $I \subseteq \nats$ of "active@@sg" registers of $u$ is such that $\size{I} = k+1$. If there exists an infix run of $u$ of length $M$ with only $k$ "active@@sg" registers, we shorten $u$ using the induction hypothesis. Otherwise, every sequence of $M$ steps in $u$ has a $\quotemarks{\enregact}$ on every register of $I$. Because there are $\size{\transitions}^M$ such sequences and $\size{\localrun} > M \cdot (\size{\transitions}^M +1)$, one sequence $s \in \transitions^M$ appears twice (disjointly) in $\localrun$: in infix run $u_1$ first, then in infix run $u_2$. We shorten $u$ by removing all steps between $u_1$ and $u_2$ and merging $u_1$ and $u_2$. However, $u_1$ and $u_2$ may differ in terms of values received. To merge them, for each $i \in I$, let $j$ the index of the first $\quotemarks{\enregact}$ on register $i$ in $s$; we replace in $u_1$, from step $j$ onwards, the values of all receptions involving $i$ by the corresponding value $v$ in $u_2$. 
 This guarantees that all equality and disequality tests still pass. However, it could be that, by letting $u'$ the obtained run, we do not have $\vinput{v}{u'} \subword \vinput{v}{u}$ because $v$ appears in $u_1$ on register $i' \ne i$; we circumvent this problem by replacing all appearances of $v$ in $u'$ involving register $i$ by a fresh value $v'$. We then have $\vinput{v'}{u'} \subword \vinput{v}{u}$ and $\vinput{v}{u'} \subword \vinput{v}{u}$. Moreover, $u'$ is shorter than $u$; we conclude by iterating this shortening procedure.
\end{proof}

% \luin{if we have some place left, fig to explain proof of above lemma?}
%peu probable qu'on ait la place :(



Using the previous lemma, we may bound the size of a node of a well-chosen "unfolding tree@@sg" with respect to its "specification@@sg".

\begin{lemma}
\label{lem:bounds_tree_sg}
Suppose that $(\prot, q_f)$ is a positive instance of \COVER where $\prot$ is a "signature protocol" with $r+1$ registers. Let $\tree$ be a "coverability witness" of minimal "size@@treesg".
For every node $\node$ in $\tree$: \begin{enumerate}
\item \label{item:bound_node_1_sg} $\size{\localrunlabel{\node}} \leq \towerfun(\size{\prot}, r) (\size{\speclabel{\node}}+1)$,
\item \label{item:bound_node_2_sg} if $\node$ is the child of $\node'$, $\size{\node} \leq \size{\node'} \cdot (\towerfun(\size{\prot},r)+2)$.
\end{enumerate} 
\end{lemma}
\begin{proof}
For \ref{item:bound_node_1_sg}, we identify in $\localrunlabel{\node}$ the broadcasts witnessing $\speclabel{\node}$ and shorten the "local run" in between these steps using Lemma~\ref{lem:towerbound_signature}.
For \ref{item:bound_node_2_sg}, we observe that, by minimality of $\tree$, $\size{\speclabel{\node}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node'}}} \leq \size{\node'}$.  
\end{proof}

This finally allows us to bound the size of a "coverability witness" of "minimal size", using the "Length function theorem":

\begin{proposition}
\label{prop:bounded_witness_sg}
There exists a function $h$ of class $\Ffunction{w^{\size{\messages}+1}}$ such that, 
for all positive instance $(\prot, q_f)$ of \COVER where $\prot$ is a "signature protocol", there exists a "coverability witness" $\tree$ of size $\size{\tree} \leq f(\size{\prot})$.
\end{proposition}
\begin{proof}
Let $n := \size{\prot}$, let $r+1$ the number of registers in $\prot$. 
Let $\tree$ a "coverability witness@@sg". Thanks to Lemma~\ref{lem:no_subword_in_branch_sg}, for all $\node \ne \node'$ in 
$\tree$ with $\node$ ancestor of $\node'$, $\speclabel{\node}$ is not a subword of $\speclabel{\node'}$.  Let $\node_1, \dots, \node_m$ the node appearing in a branch of $\tree$, from root to leaf. The sequence $\speclabel{\node_1}, \dots, \speclabel{\node_m}$ is a "bad sequence".
Thanks to Lemma~\ref{lem:bounds_tree_sg}\ and as $\size{\speclabel{\node_{i+1}}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node_i}}} \leq \size{\localrunlabel{\node_i}}$, for all $i<m$, $\size{\speclabel{\node_{i+1}}} \leq \towerfun(n,r) (\size{\speclabel{\node_{i}}} +1)$ (with convention $\size{\speclabel{\node_1}} = 1$ as the root must cover $q_f$). By direct induction, $\size{\speclabel{\node_i}}$ is bounded by $g^{(i)}(n)$ where $g: n \mapsto (\towerfun(n,n)+1) \cdot n$ is a primitive-recursive function. Let $h$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ the function obtained when applying the "Length function theorem" on $g$ and $\messages$; we have $m \leq h(n)$. 

This allows to bound the "size@@sg" of every node in $\tree$ by $h'(n) = (\towerfun(n,n)+2)^{h(n) + 1}$ thanks to Lemma~\ref{lem:bounds_tree_sg} and to an immediate induction. 
% (initialization thanks to Lemma~\ref{lem:towerbound_signature}). 
By minimality of $\tree$, the number of children of a node is bounded by the number of values appearing in its "local run" hence by $h'(n)$, so the total number of nodes is bounded by $h'(n)^{h(n)+1}$ and the total size of the tree by $f:n \mapsto h'(n)^{h(n)+2}$. Because $\Ffunction{\omega^{\size{\messages}+1}}$ contains all primitive-recursive functions and is closed under multiplication and exponentiation, $f$ is in $\Ffunction{\omega^{\size{\messages}+1}}$.
\end{proof}

The previous argument shows that \COVER for "signature protocols" is decidable and lies in complexity class $\Fcomplexity{\omega^{m+1}}$ for a fixed-size alphabet of size $m$ and in $\Fcomplexity{\omega^\omega}$ in general. Because the hardness from Proposition~\ref{prop:reduction-LCS} holds for "signature protocols", \COVER is in fact complete for this complexity class.

We now extend this method to the general case. 

%%%%%%%%%%%%%%%%%%%

\section{Coverability Decidability in the General Case}
\label{subsec:cover-general-case}

\subsection{Generalizing Unfolding Trees}
\label{sec:unfolding-trees-general}
In the general case, a new phenomenon appears: an agent can now store a value then rebroadcast it, so that several agents may broadcast the same value. Furthermore, an agent starting with value $v$ could broadcast $v$ then require someone else to make a broadcast with value $v$ as well. For example, in the run described in \cref{ex:example-1}, the first agent needs to receive message $(m_6, x_1)$ to reach $q_7$.

 We now have two types of specifications. The first one is \emph{"boss specifications"} which describe the task of broadcasting with its own initial value (this is the only "specification@@sg" we had in "signature protocols"); as before, a "boss specification" consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. The other one is \emph{"follower specifications"} where the task is to broadcast with a non-initial value received previously. More precisely, a "follower specification" is a contract consisting of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$ asking to broadcast a message $(\followmessagespec,v)$ under the condition of previously receiving word $\followwordspec$ with value $v$.

% As before, a "boss specification" consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. A "follower specification" consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that one must be able to broadcast $\followmessagespec$ with value $v$ after receiving the sequence $\followwordspec$ with value $v$. 

Note that, once an agent $a$ broadcasts some message $(m,v)$ where $a$ did not have $v$ initially, then from this point we have an unlimited supply of messages $(m,v)$ by duplicating $a$ using a "copycat" argument. 

\begin{example}
\label{ex:decomposition}
Assume that agent $a_1$ has initially value $v$ and does the following all with value $v$: it broadcasts $\textsf{a} \cdot \textsf{b}$, receives $\textsf{c}$ from $a_2$, broadcasts $\textsf{a}^3$ and receives $\textsf{b}$ from $a_3$. The "follower specification" corresponding to $a_2$'s task must be of the form $(w, \textsf{c})$ where $w \subword \textsf{a} \cdot \textsf{b}$ (we again have the subword relation because messages may get lost). However, $a_3$'s "follower spefication" may be of the form $(w \cdot w', \textsf{c}$ where $w \subword \textsf{a} \cdot \textsf{b}$ and $w' \in \set{\textsf{a},\textsf{c}}^*$ is a subword of $\textsf{a}^3$ enriched with as many $\textsf{c}$ as desired, thanks to the copycar argument. For example, one could have $w= \textsf{b} $ and $w' = \textsf{c} \cdot \textsf{a} \cdot \textsf{c}^4 \cdot \textsf{a} \cdot \textsf{c}^2$. This idea is formalized by using the notion of "decomposition" (in the appendix); in this case, the previous condition would be stated as: $w \cdot w'$ \emph{"admits decomposition"} $(\textsf{a} \cdot \textsf{b}, \textsf{c}, \textsf{a}^3)$.   
\end{example}
% Therefore, if one later needs an agent to broadcast $(m',v)$ then this agent is allowed  hence from a finite set of message types which can be sent with value $v$, there is an infinite set of possible $\followwordspec$ to chose: if a message $(m, v)$ is sent from the agent with initial value $v$ then the "copycat principle" does not apply, however, if $(m, v)$ is sent from an agent without $v$ as initial value, message type $m$ can appear as many times as one wants in $\followwordspec$ once it has been sent once. 
%For instance, in the protocol described in \cref{fig:ex1}, message ($m_6, )

We now extend "unfolding trees" so that nodes are of two types: "boss nodes" whose specifications are "boss specification" and "follower nodes" whose specifications are "follower specification". A "follower node" $\node$ with "follower specification" $(\followwordspec, \followmessagespec)$ is allowed, for value $\valuelabel{\node}$ (which must be "non-initial" in its local run), to receive messages $\followwordspec$ with value $v$ without it being broadcast by any child. Other than that, conditions on "non-initial" values are the same as for "signature protocols". For a given node $\node$ for each "non-initial" value received in the "local run", $\node$ must have a "boss child" broadcasting this word. For each "initial value" $v$ received, $\node$ essentially needs a "follower child" that is able to broadcast the message after receiving previous messages with value $v$; the formal statement is more technical because it takes into account the observation of Example~\ref{ex:decomposition}. 
The formal definition of "unfolding tree" is given in \cref{app:def-trees}.


\begin{example}
	We give an example of a new unfolding tree in \cref{fig:ex-unfolding-tree}. 
	This is the unfolding tree associated to the execution of \cref{ex:example-1}~and agent $a_1$. 
	Observe that the "follower node" $\node_3$ has a $m_2$ reception that does not need to be matched by any child; morally, this is because the broadcast is made in $a_1$. 
	In order to have a child with a "follower specification", a node needs to guarantee that the conditions of the contract are met; 
	this is the case here thanks to the $\intlabel{\atrans_{b2}}$ step in $\node_1$.  
\end{example}
\begin{figure}[t]
	\begin{center}
			% \resizebox{\textwidth}{!}{
					\input{Figures/tree-example1}
				% }
		\end{center}
	\vspace*{-0.5cm}
	\caption{Example of an "unfolding tree". $\delta_{ri}$ (resp. $\delta_{bi}$) denotes the reception (resp. broadcast) transition of message $m_i$ in the protocol described in \cref{fig:ex1}. Initial values which are neither tested or broadcast are omitted and written as $\quotemarks{\_}$.}\label{fig:ex-unfolding-tree}
%	\vspace*{-0.5cm}
\end{figure}

A ""coverability witness"" is again an "unfolding tree" whose root covers $q_f$, with the extra condition that this root is a "boss node" (a "follower node" implicitely relies on its parent's ability to broadcast). 

\begin{restatable}{proposition}{treessoundcomplete}
	\label{prop:trees-sound-complete}
	An instance of $\COVER$ $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}
\begin{proof}[Proof sketch]
	The translation from "run" to tree works by induction on the length of the "run". We first define in a natural way what it means for a "run" to satisfy a "specification". We consider a "run" $\run$ and isolate a well-chosen agent $a$, whose "local run" witnesses that the "specification" is satisfied. We call the induction hypothesis with the "specifications" expressing what $a$ needs to receive from other agents. Each such "specification" is satisfied by a strict prefix of $\run$ (the only exception being if $a$ satisfies a "boss specification" with value $v$ and the last step of $\run$ is a broadcast with $v$ by another agent; in this case, we use the induction hypothesis on $\run$ but with a follower specification, hence the induction is well-founded).
	We construct an "unfolding tree" by labeling the root with the "specification" and the "local run" of $a$, and attaching below it the subtrees obtained by induction hypothesis.
	
	The translation from tree to "run" consists in an induction on the tree. A key concept is the one of "partial run", which extends the notion of "local run" to a subset of agents: in a "partial run", some receptions called \emph{external} are not matched by a broadcast. This is meant to represent the behavior of a subtree of the "unfolding tree": if the root of an "unfolding tree" is a "follower node" with "specification" $(\followwordspec, \followmessagespec)$ then the corresponding "partial run" receives an external sequence $\followwordspec$. The inductive step applies the induction hypothesis to the children of the "root" to obtain partial runs and merges them with the "local run" of the root by branching broadcasts to the right external receptions. 
	See Appendix~\ref{app:trees-sound-complete} for the full proof. 
\end{proof}





\subsubsection{Bounding the Size of the Unfolding Tree.}
\label{sec:tree-bounds}

Our aim is again to provide bounds on the "size@@tree" of the "coverability witness". 
As in the "signature protocol" case, for "boss specifications", the longer the word broadcast, the better: if a word $\bossspec$ can be broadcast with a single value, then any subword of $\bossspec$ can also be broadcast. 
However, for "follower specifications", it goes in the opposite direction: for a fixed $\followmessagespec$, the shorter the requirement $\followwordspec$, the better: if one can broadcast $(\followmessagespec,w)$ after $\followwordspec$ is broadcast with value $v$, then this is also true with a larger $\followwordspec$ because of the lossiness. This leads to a generalization of Lemma~\ref{lem:no_subword_in_branch_sg}:

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\tree$ be a "coverability witness" for $(\prot, q_f)$.
	Let $\node, \node'$ be two nodes of $\tree$ such that $\node$ is an ancestor of $\node'$. If one of the conditions below holds, then there exists a "coverability witness" for $(\prot, q_f)$ of "size@@tree" strictly smaller than $\size{\tree}$:
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; or
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$.
	\end{itemize} 
\end{restatable}

It is fairly easy to generalize \cref{lem:towerbound_signature} to prove that one can bound the size of a node by the number of messages that it must broadcast times a primitive-recursive function $\towerfun(\size{\prot},r)$. The formal statement and the proof can be found in Appendix~\ref{app:tower-lemma} (\cref{lem:short-local-runs}). 
% note that this time the bound is on the exact number of registers (and not the number of registers minus one). We shall refer to this lemma as the Tower Function Lemma as it bounds "local runs" length by a function $\psi(n,k)$ which is in fact a tower of exponentials of height $k$ where each floor is a polynomial in $n$.

%limite du passage de nico
However, we now cannot shorten a branch directly. One would like to apply the "Length function theorem" seperately on "boss nodes" and on "follower nodes", but while the size of a "boss node" is bounded with respect to its parent's "size" 
, the size of a "follower node" is bounded  we 
\nicoin{todo: try to state why it is not easy to bound the size of the tree}


cannot bound the "size@@tree" of the "unfolding tree" from the root to the leaves (what we did in the "signature case") because of "follower nodes", nor from the leaves to the root because of "boss nodes". 

Previously, \cref{lem:no_subword_in_branch_sg,lem:towerbound_signature} lead us to the "Length function theorem". We were able to bound the size of a node with respect to the nodes to which it must send long words of messages (in the signature protocol: from leaves to root), i.e. we could find a bound for a node $\node$ with respect to its parent's size. From what we argued above, we can not do so in the general case.
%However, this is not possible for "follower nodes", as it goes in the opposite direction: a node now might need to send long sequence of messages to its "follower node" child, in order for this node to repeat a value. 
We will thus rearrange the tree in a convenient manner. 

A new version of \cref{lem:no_subword_in_branch_sg} can be found below: \cref{lem:shortening-branches} provides two ways of shortening an "unfolding tree", its proof can be found in Appendix~\ref{app:proofs-reduction-branches}. 
%and \cref{lem:short-local-runs}~is the direct general case version of \cref{lem:towerbound_signature}.






%\cref{lem:no_subword_in_branch_sg} is then replaced by the following lemma, which 





%We now show that there is a computable bound on the "size@@tree" of the "unfolding tree" achieving a given specification and labeled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem"; however, this theorem requires a bound on the lengths of the words. In fact, there is no reason to think that the lengths of the labels of the children of a node can be bounded with respect to the length of the label of that node. 
%
%
%In order to bound the size of the nodes, we now wish to adapt \cref{lem:towerbound_signature}~to the general case.
%We use the following result, which essentially states that if there is a "local run" between two local configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function and which does not require larger inputs than the previous one.

%\begin{restatable}{lemma}{lemShortLocalRuns}
%	\label{lem:short-local-runs}
%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "protocol" with $r$ registers, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ such that $\size{u'} < \towerfun(\size{\prot},r)$ and for all value $v \in \nats$,  $\vinput{v}{u'} \subword \vinput{v}{u}$. 
%%	\\
%%	
%%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers, for every "local run" $\localrun_0: (q_0, \localdata_0) \step{*} (q_f, \localdata_f)$ in $\prot$, for every section $\localrun : (q, \localdata) \step{*} (q, \localdata')$ of $\localrun_0$,  for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun''} \leq \towerfun(\size{\prot},r)$ and:
%%	\begin{enumerate}
%%		\item for all $\aval' \in \nats \setminus V$, there exists $\aval$ a "non-initial" value of $\localrun_0$ such that $\vinput{\aval'}{\localrun'}\subword \vinput{\aval}{\localrun}$,
%%		\item for all $\aval \in V$, $\vinput{\aval}{\localrun'} \subword \vinput{\aval}{\localrun}$. 
%%	\end{enumerate}
%\end{restatable}
%
%\begin{proof}[Proof sketch]
%	
%	
%	The proof follows the same reasoning as the proof of \cref{lem:towerbound_signature}, but this time all registers should be taken into consideration.
%	\luin{pour le moment j'ai juste déplacé l'ancien énoncé en annexe, vérifier si on peut adapter le lemme tower "signé" et sa preuve plus simplement}
%	
%%	First, as for \cref{lem:towerbound_signature}, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the "run" using an induction on the number of registers. We then manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the "local run" we may add some fresh values to it (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are less constraining than the ones that were in the original "run". For technical reasons, we want to prevent fresh values added in the proof from mimicking "initial" values of the agent.\lu{je crois que c'est pour les local disequality tests qui ne sont plus là désormais, à enlever?}
%%	See Appendix~\ref{app:tower-lemma} for the full proof.
%	
%	

% Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\begin{remark}\lu{déplacer si manque de place ?}
%	The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \end{remark}

The rearrangement of the tree is such that long sequences of messages are sent upwards as displayed in Figure~\ref{fig:rearrange-tree}. It will eventually allow us to apply the "Length function theorem". 


We formalize this with the notion of altitude: the altitude of a node written  $\altitude{\node}$ is defined recursively. The altitude of the root is 0, the altitude of a "boss node" is the altitude of its parent minus one, and the altitude of a "follower node" is the altitude of its parent plus one.

%\begin{definition}
%	Let $\tree$ an "unfolding tree". We define the ""altitude"" of a node $\node$ of $\tree$, written $\altitude{\node}$, recursively as follows:
%	\begin{itemize}
%		\item The altitude of the root is $0$,
%		\item The altitude of a "boss node" is the altitude of its parent minus one,
%		\item The altitude of a "follower node" is the altitude of its parent plus one.
%	\end{itemize}
%\end{definition}

\begin{figure}[h]
	\resizebox*{!}{3cm}{
	\input{Figures/rearrangement-tree}
	}
	\caption{Rearrangement of a tree, with the root in red. Black solid arrows connect parents to children, blue dashed arrows highlight that long words of messages are sent upwards.}
	\label{fig:rearrange-tree}
\end{figure}


We can now use the previous lemma to bound the label of each node $\node$ with respect to its neighbors of higher altitude, i.e., its "follower" children and its parent if it is a "boss node". The idea is that these nodes define the number of messages that $\localrunlabel{\node}$ must output to satisfy the "unfolding tree" conditions. The function $\psi$ in the statement below is the one from the Tower Function Lemma (Lemma~\ref{lem:short-local-runs}).

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\prot$ be a "protocol" over $\regnum$ registers, let $\tree$ be an "unfolding tree" over $\prot$ of minimal "size@@tree" satisfying a "boss specification" $\bossspec$, let $\node$ be a node of $\tree$.
	Let $K$ be such that for all "follower" children $\node_f$ of $\node$, $\size{\followlabelword{\node_f}} \leq K$.
	We have the following properties:
	\begin{enumerate}				
		\item  If $\node$ is a "boss node" then $\size{\localrunlabel{\node}} \leq \towerfun(\size{\prot},r)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK +1 \Big]$ and if in addition, $\node$ is not the root, $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$ with $\node'$ its parent
%		\begin{itemize}
%			\item 
%			%If $\node$ is the root of $\tree$ then $\bosslabel{\node} = w$, otherwise 
%			If $\node$ is not the root, $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$ with $\node'$ its parent
%			%\lu{moi pas comprendre prq $w$ et la formulation}
%			
%			\item $\size{\localrunlabel{\node}} \leq \towerfun(\size{\prot},r)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK +1 \Big]$
%		\end{itemize}
		
		\item If $\node$ is a "follower node" then  $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}} \leq \towerfun(\size{\prot},r)\Big[ 1 + \size{\messages}rK \Big]$
			
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	A node $\node$ has at most $\size{\messages}$ "follower" children for each "initial value", hence at most $\size{\messages}r$ in total, each one of them requires at most $K$ messages. The node $\node$ may have to output $\bosslabel{\node}$ extra messages to satisfy its "specification" if it is a "boss node", or just one extra message if it is a "follower node".
	This gives a bound on the number of messages $\localrunlabel{\node}$ needs to broadcast. We mark the positions at which $\localrunlabel{\node}$ sends them and use the Tower Function Lemma to bound the length of sections of the "run" connecting two such broadcasts by $\towerfun(\size{\prot},r)$, which yields the bounds above. See Appendix~\ref{app:bound-node-with-spec} for the full proof.
\end{proof}

Thanks to the previous lemma, we bound the size of a node with respect to its altitude: 
\begin{restatable}{lemma}{lemBoundLengthHeightH}
	\label{lem:bound-length-at-height-h}
	Let $(\prot,q_f)$ be a positive instance of \COVER, $\tree$ a "coverability witness" for $(\prot,q_f)$, $\altmax$ the maximal "altitude" in $\tree$. There exists a primitive recursive function $f_0$ such that any node $\node$ of $\tree$ has size bounded by $f_0(\size{\prot} + \altmax - \altitude{\node})$.
\end{restatable}
\begin{proof}[Proof sketch]
Applying Lemma~\ref{lem:bound-successor-height} inductively from highest to lowest altitude, we bound the sizes of the labels of all nodes at a given altitude $i$ with respect to $\altmax-i$.
See Appendix~\ref{app:bound-node-size-with-altitude} for the detailed proof. 
\end{proof}
 
\begin{restatable}{proposition}{PropBoundTreeSize}
	\label{prop:bound-tree-size}
	There exists a function $f$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ such that an instance $(\prot,q_f)$ of \COVER is positive if and only if it has a "coverability witness" $\tree$ of size bounded by $f(\size{\prot})$.
\end{restatable}

\begin{proof}[Proof sketch]
	The full proof is in Appendix~\ref{app:bound-tree-size}. $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for it thanks to Proposition~\ref{prop:trees-sound-complete}; we consider the "coverability witness" $\tree$ of minimal size.
	In a branch of $\tree$ reaching maximal altitude, we mark the nodes that have a greater altitude than all the previous ones (see Figure~\ref{fig:max-height-bound}). They are necessarily "follower" nodes as a "boss" node is below its parent. This sequence (taken from highest to lowest altitude) is so that the $i$th term is at altitude $\altmax-i$ and we can bound its "size@@tree" with respect to $i$ with the previous arguments. Along with Lemma~\ref{lem:shortening-branches}, we apply the "Length function theorem" on that sequence to bound its length hence the maximal altitude (Lemma~\ref{lem:bound-max-height}).
	
	This yields in turn a bound on the root label, as its altitude ($0$) has a bounded difference with the maximal one. Another application of the "Length function theorem", this time with "boss nodes", allows us to bound the minimal altitude of a node of this tree (Lemma~\ref{lem:bound-min-height}).
	
	Once we have bounded both the maximal and minimal altitudes, we can infer a bound on the size of all nodes using Lemma~\ref{lem:bound-length-at-height-h}, and then on branches as we can shorten branches as soon as they have two nodes with the same specification.
	The bound on the "size@@tree" of the tree then follows from the observation that as nodes have bounded "local runs", they only see a bounded amount of values and thus need a bounded amount of children. 
\end{proof}


%\subsubsection{Decidability}
%\label{sec:decidability-end}

We showed that "unfolding trees" are a sound and complete abstraction for \COVER\ and that there is a computable bound (of the class $\Ffunction{\omega^\omega}$) on the "size@@tree" of a minimal "coverability witness", if it exists. Our decidability procedure computes that bound, enumerates all trees of "size@@tree" below the bound and checks for each of them whether it is "coverability witness". Details can be found in Appendix~\ref{app:decidability}.

\decidablecover*


