\section{Coverability Decidability for Signature Protocols}
\label{sec:cover-decidability}

This section and the next one are dedicated to the proof of our main result:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for BNRA is decidable and $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

For the sake of clarity, in this section, we will first focus on the case of "signature BNRA". 
As a preliminary, we start by defining a notion of "local run" meant to represent the projection of a run onto a given agent. 


\subsection{Local runs}
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$ and $\atrans =(q, \br{m}{i}, q')$ is a "broadcast".  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item if $\anact = \quotemarks{\dummyact}$ 
			then $\localdata(j) = \localdata'(j)$,
			\item if $\anact = \quotemarks{\enregact}$ then $\localdata'(j) = v$,
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item if $\anact = \quotemarks{\eqtestact}$ then $\localdata(j) = \localdata'(j)= v$,
			\item if $\anact = \quotemarks{\diseqtestact}$ then $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	\AP Such a reception step corresponds to receiving message $(m,v)$; in a "local run", one does not specify the origin of a received message.
	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either a "reception step" or an "internal step". A ""local run"" $\localrun$ is a sequence of "local steps" denoted $(q_0, \nu_0) \step{*} (q, \nu)$. Its ""length"" $\size{\localrun}$ is its number of steps. %where $\nu_0$ has distinct values.
	
	A value $\aval \in \nats$ appearing in $\localrun$ is ""initial"" if it appears in $\nu_0$ and ""non-initial"" otherwise. 
%	The ""input"" of $\localrun$, written $\intro*\Input{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages received in $\localrun$; its ""output"", written $\intro*\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages broadcast in $\localrun$. 
	% The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. 
	For $\aval \in \nats$, the $\aval$-""input"" $\intro*\vinput{\aval}{\localrun}$ (resp. $\aval$-""output"" $\intro*\voutput{\aval}{\localrun}$) is the sequence $m_0 \cdots m_{\ell} \in \messages^*$ of message types received (resp. broadcast) with value $\aval$ in $\localrun$.

\subsection{Unfolding Trees}
\label{sec:unfolding_tree_signature}

We first prove decidability of \COVER for "signature BNRA". Note that, in "signature protocols", the initial values of "reception-only" registers are not relevant as they can never be shared with other agents. We deduce from this idea the following informal observation:
\begin{observation}
\label{obs:sg_reception} 
In "signature BNRA", when some agent receives a message, it can compare the value of the message only with the ones of previously received messages, \emph{i.e.}, check whether the sender is the same.
\end{observation}

If we want to turn a "local run" $u$ of an agent $a$ into an actual "run", we must match $a$'s receptions with broadcasts. Because of Observation~\ref{obs:sg_reception}, what matters is not the actual values of the receptions in $u$ but which ones are equal to which.  Therefore, for a value $v$ received in $u$, if $m_1 \dots m_k \in \messages^*$ are the message types received in $u$ with value $v$ in this order, it means that to execute $u$, $a$ need another agent $a'$ to broadcast messages types $m_1$ to $m_k$, all with the same value.  
We describe what an agent needs from other agents as a set of "specifications@@sg" which are words of $\messages^*$. 
% A ""specification@@sg"" $m_1 \cdots m_k \in \messages^*$ is accomplished by an agent if it broadcasts message types $m_1, \dots, m_k$ in this order. 

To represent runs, we consider "unfolding trees@@signature" that abstract runs by representing such specifications, dependencies between them and how they are carried out. In this tree, each node is assigned a "local run" and the "specification@@sg" that it carries out. 
Because of copycat arguments, we will in fact be able to duplicate agents so that each agent only accomplishes one task, hence the tree structure.

\begin{definition}
\label{def:unfolding_tree_signature}
\AP An ""unfolding tree@@sg"" $\tree$ over $\prot$ is
a finite tree where nodes $\node$ have three labels:
\begin{itemize}
	\item a "local run" of $\prot$, written $\intro*\localrunlabel{\node}$;
	
	\item a value in $\nats$, written $\intro*\valuelabel{\node}$;
	
	\item a ""specification@@sg"" $\intro*\speclabel{\node} \in \messages^*$.
\end{itemize} 
Moreover, all nodes $\node$ in $\tree$ must satisfy the three following conditions:
\begin{enumerate}[label= (\roman*), ref=(\roman*)]
	\item \label{item:condition1_initial_value_sg} Initial values of $\localrunlabel{\node}$ are never received in $\localrunlabel{\node}$,
	\item \label{item:condition3_boss_node_sg} $\speclabel{\node} \subword \voutput{\valuelabel{\node}}{\localrunlabel{\node}}$, \emph{(recall that $\subword$ denotes the "subword" relation)}
	\item \label{item:condition2_non_initial_value_sg} For each value $\aval$ received in $\localrunlabel{\node}$, $\node$ has a child $\node'$ s.t. $\vinput{\aval}{\localrunlabel{\node}} \subword \speclabel{\node'}$.
\end{enumerate}

\AP Lastly, given $\tree$ an "unfolding tree@@sg", we define its ""size@@treesg"" by $\size{\tree} := \sum_{\node \in \tree} \size{\node}$ where $\size{\node} := \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@treesg" of $\tree$ takes into account the size of its nodes, so that a tree $\tree$ can be stored in space polynomial in $\size{\tree}$ (renaming the values appearing in $\tree$ if needed). 
\end{definition}
% subword explaination

We explain this definition. Condition \ref{item:condition1_initial_value_sg} enforces that the "local run" cannot cheat by receiving its "initial values". 
 Condition \ref{item:condition3_boss_node_sg} expresses that $\localrunlabel{\node}$ broadcasts (at least) the messages of $\speclabel{\node}$. We can use the subword relation $\subword$ (instead of equality) because messages do not have to be received.  
Condition \ref{item:condition2_non_initial_value_sg} expresses that, for each value $v$ received in the "local run" $\localrunlabel{\node}$, $\node$ has a child who is able to broadcast the sequence of messages that $\localrunlabel{\node}$ receives with value $v$. 
\begin{figure}[t]
	\centering
	\resizebox*{!}{3.5cm}{
	\input{Figures/fig-ex2}
	}
	\caption{Example of a "signature protocol".}\label{fig:ex2}\label{fig:example-signature-protocol}
\end{figure}
\begin{example}
\label{ex:protocol-signature}
	Figure~\ref{fig:example-signature-protocol} provides an example of a "signature protocol".
Let $\agents = \set{a_1, a_2,a_3}$. We denote a configuration $\config$ by $\tuple{\st{\config}(a_1),(\data{\config}(a_1)), \\ \st{\config}(a_2),(\data{\config}(a_2)), \st{\config}(a_3), (\data{\config}(a_3))}$. Irrelevant register values are denoted by $\_$. Let $\run$ be the run over $\agents$ of initial configuration  \\$\tuple{q_0, (1,\_,\_), q_0, (2,\_,\_), q_0, (3,\_,\_)}$ where the following occurs:
\begin{itemize}
\item $a_2$ broadcasts $\exready$, $a_1$ receives: $\tuple{q_1, (1,2,\_), q_0, (2,\_,\_), q_0, (3,\_,\_)}$,
\item $a_3$ broadcasts $\exready$, $a_1$ and $a_2$ receive: $\tuple{q_2, (1,2,3), q_5, (2,\_,\_), q_0, (3,\_,\_)}$,
\item $a_2$ broadcasts $\exready$, $a_3$ receives: $\tuple{q_2, (1,2,3), q_5, (2,\_,\_), q_5, (3,\_,\_)}$,
\item $a_2$ broadcasts $\exgotwo$, $a_1$ receives: $\tuple{q_3, (1,2,3), q_6, (2,\_,\_), q_5, (3,\_,\_)}$,
\item $a_3$ broadcasts $\exgothree$, $a_1$ receives: $\tuple{q_4, (1,2,3), q_6, (2,\_,\_), q_7, (3,\_,\_)}$.
\end{itemize}
	
Figure~\ref{fig:ex-unfolding-tree-signature} provides an "unfolding tree@@sg" derived from $\run$ by applying a procedure introduced later. Because agents $a_2$ and $a_3$ broadcast to several other agents, they each correspond to several nodes of the tree.  
% the following sequence is an initial run covering $q_4$:
	% \begin{align*}
	% 	&\tuple{(q_0, (\valsymb{1},2,3)), (q_0, (x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \tuple{(q_1, (x_1,x_2,z_1)), (q_5,(x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \\ 
	% 	&\tuple{(q_2, (x_1,x_2,x_3)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \tuple{(q_3, (x_1,x_2,x_2)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \\
	% 	&\tuple{(q_4, (x_1,x_2,x_2)),(q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} 
	% \end{align*}
	% For readability's sake we don't write the second and third registers' values of agent $a_2$ and $a_3$ as there are neither broadcast, tested and nothing is store on those registers during the run.
	% First agent $a_2$ broadcasts message $hello$ with its second register's value, then $a_3$ broadcasts message $hey$ with its third register's value. Then, agent $a_2$ broadcasts message $ack$ with its second register's value and finally, agent $a_3$ broadcasts the same message but with its third register's value.
	% All messages are received by agent $a_1$ which hence reaches $q_4$.
	% We show now how to build the unfolding tree regarding the local run of agent $a_1$ in \cref{fig:unfolding-tree-sign}. Tables are (part of) "local runs", columns are (part of) "local configurations": we only display registers used in the local runs (the one broadcast or with a reception action on it). For $\node_2$, the transition between $q_0$ and $q_5$ should be understood as the broadcast of $hello$, whereas for $\node_3$ it should be understand as the broadcast of $hey$.
	% The local run of node $\node_1$ is the local run of agent $a_1$ of the run described above. 
	% By completing partial local runs by fresh integers in the other registers, one can verify that all nodes are labeled by local runs of the protocol (where the broadcast between $q_0$ and $q_5$ is with $hello$ for $\node_2$, and with $hey$ for $\node_3$).

	We explain why this tree is an "unfolding tree@@sg". Condition \ref{item:condition1_initial_value_sg} is trivially satisfied. 
	Condition \ref{item:condition3_boss_node_sg} holds at every node because the local run of each node exactly broadcasts the "specification@@sg" of the node. Condition  \ref{item:condition2_non_initial_value_sg} is satisfied at $\node_1$: $\vinput{2}{\localrunlabel{\node_1}}= \exready \cdot \exgotwo = \speclabel{\node_2}$ and $\vinput{3}{\localrunlabel{\node_1}}= \exready \cdot \exgothree = \speclabel{\node_3}$.
	It is also satisfied at $\node_2$, $\node_3$ and $\node_5$ because their local runs only receive $\exready$ and they each have a child with "specification@@sg" $\exready$. 
	It is trivially satisfied at $\node_4$ and $\node_6$ as their "local runs" have no reception. 
	% Values received in $\localrunlabel{\node_1}$ are $x_2$ and $x_3$, hence from condition \ref{item:condition2_non_initial_value_sg}, node $\node_1$ has two children $\node_2$ and $\node_3$. Note that $\vinput{x_2}{\localrunlabel{\node_2}} = \vinput{x_3}{\localrunlabel{\node_3}} = \epsilon$\lu{si on modifie la condition, on peut enlever cette phrase}. As $\spec(\node_1) = \epsilon$, condition \ref{item:condition3_boss_node_sg} is trivially true for $\node_1$. Note that nodes $\node_2$ and $\node_3$ don't receive any message on their respective local runs and so condition \ref{item:condition2_non_initial_value_sg} is trivially true. Furthermore, $\voutput{x_2}{\localrunlabel{\node_2}} = hello \cdot ack = \spec(\node_2)$ and $\voutput{x_3}{\localrunlabel{\node_3}} = hey \cdot ack = \spec(\node_3)$
\end{example}


\begin{figure}[t]
	\centering
	\input{Figures/tree-example-sign}
	\vspace{-0.5cm}
	\caption{Example of an "unfolding tree@@sg" derived from $\run$. Grids correspond to "local runs", a column of a grid is a "local configuration". Transition $\atrans_{ij}$ is the transition between state $q_i$ and state $q_j$, for example $\atrans_{01} = (q_0, \rec{\exready}{2}{\enregact}, q_1)$. If $\atrans$ is a reception of $m\in \messages$, $\extlabel{\atrans}{v}$ corresponds to receiving message $(m,v)$; if $\atrans$ is a broadcast of $m \in \messages$, $\intlabel{\atrans}$ corresponds to broadcasting $(m,\mathsf{id})$ where $\mathsf{id}$ is the value in the first register of the agent. Initial values of "reception-only" registers are irrevelant and written as $\quotemarks{\_}$. Colors correspond to message types.}
	\label{fig:ex-unfolding-tree-signature}
\end{figure}
%	\todo{relire cette légende}
%We say that an "unfolding tree" $\tau$ ""covers@ut"" a state $q_f$ if the "local run" labeling its root goes through $q_f$. 

\begin{lemma}
\label{lem:coverability_witness_sg}
Given a "signature protocol" $\prot$ with a state $q_f$, $q_f$ is coverable in $\prot$ if and only if there exists an "unfolding tree@@sg" whose root is labelled by a "local run" covering $q_f$. We call such an "unfolding tree@@sg" a ""coverability witness@@sg"".
\end{lemma}
\begin{proof}
Given a "run" $\run$, agent $a$ \emph{satisfies a "specification@@sg"} $w \in \messages^*$ in $\run$ if the sequence of "message types" broadcast by $a$ admits $w$ as "subword".% if such an agent $a$ exists, we say that $\run$ satisfies "specification@@sg" $w$.   

Let $\tree$ be a "coverability witness@@sg". 
We prove the following property by strong induction on the depth of $\node$: for every $\node$ in $\tree$, there exists a "run" $\run$ with an agent $a$ whose "local run" in $\run$ is $\localrunlabel{\node}$ and who satisfies "specification@@sg" $\speclabel{\node}$. This is trivially true for leaves of $\tree$ because their "local runs" have no reception (by condition~\ref{item:condition2_non_initial_value_sg}) hence are actual "runs" by themselves. 
Let $\node$ a node of $\tree$, $\localrun := \localrunlabel{\node}$ and $\aval_1, \dots, \aval_c$ the values received in $\localrun$. 
These values are "non-initial" thanks to condition~\ref{item:condition1_initial_value_sg}; applying condition \ref{item:condition2_non_initial_value_sg} gives the existence of corresponding children $\node_1, \dots, \node_c$ in $\tree$. 
We apply the induction hypothesis on the subtrees rooted in $\node_1, \dots, \node_c$ to obtain "runs" $\run_1, \dots, \run_c$ satisfying the "specifications@@sg" of the children of $\node$. 
Up to renaming agents, we can assume the set of agents of these runs are disjoint; up to renaming values, we can assume that $\aval_j = \valuelabel{\node_j}$ for all $j$ and that all agents start with distinct values. 
We build an "initial run" $\run$ whose "agents" is the union of the "agents" of the $c$ runs along with a fresh agent $a$. In $\run$, we make $\run_1$ to $\run_c$ progress in parallel and make $a$ follow the "local run" $\localrun$, matching each reception with value $v_j$ in $\localrun$ with a broadcast in $\run_j$. 
This is possible because, for all $j$, $\vinput{v_j}{\localrun} \subword \speclabel{\node_j} \subword \voutput{v_j}{\run_j}$ (by \ref{item:condition3_boss_node_sg}). 

Conversely, we prove the following by induction on the length of $\run$: for every "initial run" $\run$, for every agent $a$ in $\run$ and for every $v \in \nats$, there exists an "unfolding tree@@sg" whose root has as "local run" the projection of $\run$ onto $a$ and as "specification@@sg" the $v$-"output" of $a$ in $\run$. If $\run$ is the empty run, consider the "unfolding tree" with a single node whose "local run" and "specification@@sg" are empty. Suppose now that $\run$ has non-zero length, let $a$ an agent in $\run$, $v \in \nats$ and let $\run_p$ the prefix run of $\run$ of length $\size{\run}-1$.
Let $\tree_1$ the "unfolding tree@@sg" obtained by applying the induction hypothesis to $\run_p$, $a$ and $v$, and consider $\tree_2$ obtained by simply appending the last step of $a$ in $\run$ to the "local run" at the root of $\tree_1$. If this last step is a broadcast, we obtain an "unfolding tree@@sg"; if the broadcast value is $v$, we append the broadcast "message type" to the "specification@@sg" at the root of $\tree_2$ and we are done. 
Suppose that, in the last step of $\run$, $a$ performs a reception $(q, \rec{m}{i}{\anact},q')$ of a message $(m,\aval')$. We might need to adapt $\tree_2$ to respect condition \ref{item:condition2_non_initial_value_sg} at the root. Let $a'$ the agent broadcasting in the last step of $\run$. Let $\tree_3$ the "unfolding tree@@sg" obtained by applying the induction to $\run_p$, $a'$ and $v'$. Let $\tree_4$ the "unfolding tree@@sg" obtained by appending the last broadcast to the "local run" at the root of $\tree_3$ and the corresponding "message type" to the "specification@@sg" at the root of $\tree_3$. Attaching $\tree_4$ below the root of $\tree_2$ gives an "unfolding tree@@sg" satisfying the desired properties. 
% Note that this construction may generate more children than needed at the root - maybe another child was already there to witness broadcasts of $a'$ in $\run_p$, in which case this child may be deleted. 
\end{proof}


	The "unfolding tree@@sg" $\tree$ of Figure~\ref{fig:ex-unfolding-tree-signature} is built from $\run$ of Example~\ref{ex:protocol-signature} using the previous procedure.
	 Observe that the "unfolding tree@@sg" $\tree$  is a "coverability witness@@sg" for $q_4$. However, one can find a smaller "coverability witness@@sg". 
	Indeed, in the right branch of $\tree$, $\node_5$ and $\node_6$ have the same "specification@@sg", therefore $\node_5$ can be deleted and replaced with $\node_6$. More generally, we would have also been able to shorten the tree if we had $\speclabel{\node_5} \subword \speclabel{\node_6}$.
	
	\begin{remark}\label{remark:tree-root-spec-1}
	It is sometimes convenient to consider coverability witnesses whose root has a non-empty specification. In order to define the root specification, one can do the following transformation of the protocol: from the state to cover, add a self loop broadcast transition of a fresh message (for instance, a fresh letter not already in $\messages$ together with register 1). Hence, in the rest of this paper, we consider coverability witnesses whose root specification is this fresh letter. 
	\end{remark}

\subsection{Bounding the Size of a Coverability Witness}
In all the following, we fix a positive instance $(\prot,q_f)$ of \COVER with $r+1$ registers (\emph{i.e.}, $r$ registers used for reception) and a  "coverability witness@@sg" $\tree$ of minimal size.
We turn the observation above into an argument that will be useful towards bounding the length of branches of a "coverability witness@@sg":

\begin{lemma}
\label{lem:no_subword_in_branch_sg}
If a "coverability witness@@sg" $\tau$ for $(\prot, q_f)$ of minimal size has two nodes $\node, \node'$ with $\node$ a strict ancestor of $\node'$ then  $\speclabel{\node}$ cannot be a subword of $\speclabel{\node'}$. 
\end{lemma}
\begin{proof}
Otherwise, replacing the subtree rooted in $\node$ with the one rooted in $\node'$ would contradict minimality of $\tree$.
\end{proof}

We would now like to use the "Length function theorem" to bound the height of $\tree$, using the previous lemma. To do so, we need a bound on the "size@@treesg" of a node with respect to its depth. The following lemma bounds the number of steps of a "local run" between two local configurations: we argue that if the "local run" is long enough we can replace it with a shorter one that can be executed using the same input. This will in turn bound the "length" of a "local run" of a node with respect to the "size@@sg" of its "specification@@sg", which is the first step towards our goal.

\begin{lemma}
\label{lem:towerbound_signature}
There exists a primitive recursive function $\towerfun$ such that, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ with $\size{u'} \leq~\towerfun(\size{\prot},r)$ and for all value $v' \in \nats$, there exists $v \in \nats$ such that  $\vinput{v'}{u'} \subword \vinput{v}{u}$. 
\end{lemma}
\begin{proof}
Let $\towerfun(n,0) = n+1$ and $\towerfun(n,k+1) = 2 \, \towerfun(n,k) \cdot ({\size{\transitions}}^{2\,\towerfun(n,k)}+1)$ for all $k$. Observe that $\towerfun(n,k)$ is a tower of exponentials of height $k$, which is primitive-recursive although non-elementary. A register $i \geq 2$ is ""active@@sg"" in a "local run" $u$ if $u$ has some $\quotemarks{\enregact}$ action on register $i$. Let $u$ a "local run", $k$ the number of "active@@sg" registers in $\localrun$, $n := \size{\prot}$ and $M := \towerfun(n,k)$.
We prove by induction on the number $k$ of "active@@sg" registers in $u$  that if $\size{u} >\towerfun(n,k)$ then $u$ can be shortened. 
 

If $k=0$, any state repetition can be removed. Suppose that $\size{u} > \towerfun(n,k+1)$ and that the set $I$ of "active@@sg" registers of $u$ is such that $\size{I} = k+1$. If there exists an infix run of $u$ of length $M$ with only $k$ "active@@sg" registers, we shorten $u$ using the induction hypothesis. Otherwise, every sequence of $M$ steps in $u$ has a $\quotemarks{\enregact}$ on every register of $I$. Because $\size{\localrun} > 2 M \, (\size{\transitions}^{2M} +1)$, $\localrun$ contains at least $\size{\transitions}^{2M}+1$ disjoint sequences of length $2M$ and some $s \in \transitions^{2M}$ appears twice: in infix run $u_1$ first, then in infix run $u_2$. We build a shorter run $u'$ by removing all steps between $u_1$ and $u_2$ and merging $u_1$ and $u_2$ (see \cref{fig:proof-pumping-signed}). 
We need suitable values for the reception steps in $s$ in the shortened run $u'$. 
For a given register $i \in I$, we would like to pick a $\quotemarks{\enregact}$ step on register $i$ in $s$, use values from $u_1$ before that step and values from $u_2$ after that step. This would guarantee that all equality and disequality tests still pass. 
However, there is an issue if a value $v$ appears in several registers in $u$. For example, if $v_1 = v_2 = v$ in Figure~\ref{fig:proof-pumping-signed}, we might interleave receptions of $v$ on registers $2$ and $4$: if we had a $\extlabel{\rec{{m_1}}{2}{\eqtestact}}{v}$ in $u_1$ and a $\extlabel{\rec{{m_2}}{4}{\eqtestact}}{v}$ in $u_2$, we could have ${m_1}$ before ${m_2}$ in $\vinput{v}{u}$ but ${m_1}$ after ${m_2}$ in $\vinput{v}{u'}$, so that we do not have $\vinput{v}{u'} \subword \vinput{v}{u}$. We solve this issue by introducing fresh values between values of $u_1$ and values of $u_2$; because $\size{s} = 2M$, there is a $\quotemarks{\enregact}$ for each register in $I$ in each half of $s$. In the shortened run $u'$, before the \emph{first} $\quotemarks{\enregact}$ on register $i$ (excluded), we use values of $u_1$, and after the \emph{last} $\quotemarks{\enregact}$ on register $i$ (included), we use values of $u_2$. For every value $v$ appearing in register $i$ between these two steps in $u_1$, we select a fresh value $v_f$ (\emph{i.e.}, a value that does not appear anywhere in the run) and consistently replace $v$ with $v_f$ (hatched blocks in \cref{fig:proof-pumping-signed}).
With this technique, receptions with values from $u_1$ and receptions with values from $u_2$ cannot get interleaved in $u'$. Therefore, for every value that appeared in $u$, we have $\vinput{v}{u'} \subword \vinput{v}{u}$. Also, for every fresh value $v'$ there is a value $v$ such that $\vinput{v'}{u'} \subword \vinput{v}{u}$. Moreover, $u'$ is shorter than $u$; we conclude by iterating this shortening procedure. 
\end{proof}
% for each $i \in I$, let $j$ the index of the first $\quotemarks{\enregact}$ on register $i$ in $s$; we replace in $u_1$, from step $j$ onwards, the values of all receptions involving $i$ by the corresponding value $v$ in $u_2$. 
%  This guarantees that all equality and disequality tests still pass. However, it could be that, by letting $u'$ the obtained run, we do not have $\vinput{v}{u'} \subword \vinput{v}{u}$ because $v$ appears in $u_1$ on several registers: observe that in \cref{fig:proof-pumping-signed}, if $v_1 = v_2$ then the shortening operation may interleave the receptions of messages with that value in the two run segments in which case we would not have $\vinput{v_1}{u'} \subword \vinput{v_2}{u}$. This is why we made sure every register was renewed \emph{twice}. In $s$ in the shortened run, for every register $i \in I$, between the first $\quotemarks{\enregact}$ of $i$ (included) and the last  $\quotemarks{\enregact}$ of $i$ (excluded), we replace all values appearing in receptions with register $i$ with fresh values (hatched blocks in \cref{fig:proof-pumping-signed}). We then have $\vinput{v}{u'} \subword \vinput{v}{u}$ for every value that appeared in $u$ and for every fresh value $v'$ there is a $v$ such that $\vinput{v'}{u'} \subword \vinput{v}{u}$. Moreover, $u'$ is shorter than $u$; we conclude by iterating this shortening procedure.

\begin{figure}[t]

	% \resizebox*{!}{4.5cm}{
	\centering
	\input{Figures/fig-illustration-signed-pumping-v2}
	% }
	\caption{Illustration of the proof of \cref{lem:towerbound_signature}. 
%		For example, if $v_1 = v_2$, we transform the r
%		We make sure that we shorten the run so the new $\quotemarks{\enregact}$ actions are made on fresh values. If it was not the case on $u_2$ (here for example value $v$ is not fresh as it appeared before in the run), we introduce a new value never seen before (here value $v'$).
	}
	\label{fig:proof-pumping-signed}
\end{figure}

Using the previous lemma, we will bound the size of a node in $\tree$ with respect to its "specification@@sg" therefore with respect to its parent's size. By induction, we will then obtain a bound depending on the depth, and apply the "Length function theorem" to bound the height of the tree. 

\begin{lemma}
\label{lem:bounds_tree_sg}
For all nodes $\node, \node'$ in $\tree$: \begin{enumerate}
\item \label{item:bound_node_1_sg} $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot}, r)+1) \size{\speclabel{\node}}$,
\item \label{item:bound_node_2_sg} if $\node$ is the child of $\node'$, $\size{\speclabel{\node}} \leq (\towerfun(\size{\prot}, r)+1) \, \size{\speclabel{\node'}}$.
%\item \label{item:bound_node_3_sg} if $\node$ is the child of $\node'$, $\size{\node} \leq (\size{\node'}+1) \, (\towerfun(\size{\prot},r)+1)$.
\end{enumerate} 
\end{lemma}
\begin{proof}
We apply \cref{remark:tree-root-spec-1}\ and assume that the specification of the root is of length $1$.	
For the first item, by minimality of $\tree$, $\localrunlabel{\node}$ ends with the last broadcast required by $\speclabel{\node}$; we identify in $\localrunlabel{\node}$ the broadcast steps witnessing $\speclabel{\node}$ and shorten the "local run" between these steps using Lemma~\ref{lem:towerbound_signature}.  We thus obtain
 $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r)+1)\size{\speclabel{\node}}$, proving \ref{item:bound_node_1_sg}.
For the second item, by minimality of $\tree$, $\size{\speclabel{\node}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node'}}} \leq \size{\localrunlabel{\node'}} \leq (\towerfun(\size{\prot}, r){+}1) \, \size{\speclabel{\node'}}$. 
%For \ref{item:bound_node_3_sg}, we use $\size{\node} = \size{\speclabel{\node}} + \size{\localrunlabel{\node}}$ and combine \ref{item:bound_node_1_sg} and \ref{item:bound_node_2_sg}.  
\end{proof}


\begin{proposition}
\label{prop:bounded_witness_sg}
There exists a function $f$ of class $\Ffunction{\omega^{\size{\messages}-1}}$ s.t. $\size{\tree} \leq f(\size{\prot})$. 
\end{proposition}
\begin{proof}
Let $n := \size{\prot}$, let $r+1$ be the number of registers in $\prot$. Thanks to Lemma~\ref{lem:no_subword_in_branch_sg}, for all $\node \ne \node'$ in 
$\tree$ with $\node$ ancestor of $\node'$, $\speclabel{\node}$ is not a subword of $\speclabel{\node'}$.  Let $\node_1, \dots, \node_m$ the node appearing in a branch of $\tree$, from root to leaf. The sequence $\speclabel{\node_1}, \dots, \speclabel{\node_m}$ is a "bad sequence".
For all $i \in \nset{1}{m}$, $\size{\speclabel{\node_{i+1}}}  \leq (\towerfun(n,r)+1) \, \max(\size{\speclabel{\node_i}},1)$ by Lemma~\ref{lem:bounds_tree_sg}. By direct induction, $\size{\speclabel{\node_i}}$ is bounded by $g^{(i)}(n)$ where $g: n \mapsto n  \, (\towerfun(n,n)+1)$ is a primitive recursive function. Let $h$ of class $\Ffunction{\omega^{\size{\messages}-1}}$ the function obtained when applying the "Length function theorem" on $g$ and $\messages$; we have $m \leq h(n)$. 

By immediate induction, thanks to Lemma~\ref{lem:bounds_tree_sg}.\ref{item:bound_node_2_sg}, for every node $\node$ at depth $d$, $\size{\speclabel{\node}} \leq (\towerfun(n,r)+1)^{d+1}$ which, by Lemma~\ref{lem:bounds_tree_sg}.\ref{item:bound_node_1_sg} and because $d \leq h(n)$, bounds the size of every node by $h'(n) = (\towerfun(n,n)+1)^{h(n) + 2}$. 
% (initialization thanks to Lemma~\ref{lem:towerbound_signature}). 
By minimality of $\tree$, the number of children of a node is bounded by the number of values appearing in its "local run" hence by $h'(n)$, so the total number of nodes in $\tree$ is bounded by $h'(n)^{h(n)+1}$ and the "size@@treesg" of $\tree$ by $f(n) := h'(n)^{h(n)+2}$. Because $\Ffunction{\omega^{\size{\messages}-1}}$ is closed under composition with primitive-recursive functions, $f$ is in $\Ffunction{\omega^{\size{\messages}-1}}$.
\end{proof}

The previous argument shows that \COVER for "signature protocols" is decidable and lies in complexity class $\Fcomplexity{\omega^\omega}$. Because the hardness from Proposition~\ref{prop:reduction-LCS} holds for "signature protocols", \COVER is in fact complete for this complexity class.

We now extend this method to the general case. 

%%%%%%%%%%%%%%%%%%%

\section{Coverability Decidability in the General Case}
\label{sec:cover-general-case}

\subsection{Generalizing Unfolding Trees}
\label{sec:unfolding-trees-general}
In the general case, a new phenomenon appears: an agent may broadcast a value that it did not initially have but that it has received and stored. In particular, an agent starting with value $v$ could broadcast $v$ then require someone else to make a broadcast with value $v$ as well. For example, in the run described in \cref{ex:example-1}, $1$ is initially a value of $a_1$ that $a_2$ receives and rebroadcasts to $a_1$.

 We now have two types of specifications. \emph{"Boss specifications"} describe the task of broadcasting with one of its own initial values; this is the "specification@@sg" we had in "signature protocols" and, as before, it consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. \emph{"Follower specifications"} describe the task of broadcasting with a non-initial value received previously. More precisely, a "follower specification" is a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$ asking to broadcast a message $(\followmessagespec,v)$ under the condition of previously receiving the sequence of "message types" $\followwordspec$ with value $v$.

% As before, a "boss specification" consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. A "follower specification" consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that one must be able to broadcast $\followmessagespec$ with value $v$ after receiving the sequence $\followwordspec$ with value $v$. 

A key idea is that, if an agent that had $v$ initially receives some message $(m,v)$, then intuitively we can isolate a subset of agents that did not have $v$ initially but that are able to broadcast $(m,v)$ after receiving a sequence of messages with that value. We can then copy them many times in the spirit of the "copycat principle". Each copy receives the necessary sequence of messages in parallel, and they then provide us with an unbounded supply of messages $(m,v)$. In short, if an agent broadcasts $(m,v)$ while not having $v$ as an "initial value", then we can consider that we have an unlimited supply of messages $(m,v)$.

\begin{example}

\label{ex:decomposition}
Assume that $\agents = \set{a_1,a_2,a_3}$ and let $v$ be initial for $a_1$. Consider an execution where the broadcasts with value $v$ are: $a_1$ broadcasts $\textsf{a} \cdot \textsf{b}$, then $a_2$ broadcasts $\textsf{c}$, then $a_1$ broadcasts $\textsf{a}^3$ then $a_3$ broadcasts $\textsf{b}$. The "follower specification" of $a_2$'s task would be of the form $(w, \textsf{c})$ where $w \subword \textsf{a} \cdot \textsf{b}$: $a_2$ must be able to broadcast $(c,v)$ once $\textsf{a} \cdot \textsf{b}$ has been broadcast with value $v$. By contrast, $a_3$'s "follower specification" would be of the form $(w \cdot w', \textsf{c})$ where $w \subword \textsf{a} \cdot \textsf{b}$ and $w' \in \set{\textsf{a},\textsf{c}}^*$ is a subword of $\textsf{a}^3$ enriched with as many $\textsf{c}$ as desired, because $a_2$ may be cloned at will.
%(we may mimic $a_2$'s execution with disjoints set of agents until the first reception on $v$ $a_2$ performs, all new agents then perform the same reception and go on with their execution on a similar fashion until broadcasting $\textsf{c}$). 
For example, one could have $w= \textsf{b} $ and $w' = \textsf{c} \cdot \textsf{a} \cdot \textsf{c}^4 \cdot \textsf{a} \cdot \textsf{c}^2$. This idea is formalized in the appendix with the notion of "decomposition". Using this notion, the previous condition becomes: $w \cdot w'$ \emph{"admits decomposition"} $(\textsf{a} \cdot \textsf{b}, \textsf{c}, \textsf{a}^3)$.   
\end{example}
% Therefore, if one later needs an agent to broadcast $(m',v)$ then this agent is allowed  hence from a finite set of message types which can be sent with value $v$, there is an infinite set of possible $\followwordspec$ to chose: if a message $(m, v)$ is sent from the agent with initial value $v$ then the "copycat principle" does not apply, however, if $(m, v)$ is sent from an agent without $v$ as initial value, message type $m$ can appear as many times as one wants in $\followwordspec$ once it has been sent once. 
%For instance, in the protocol described in \cref{fig:ex1}, message ($m_6, )

In our new "unfolding trees", a node is either a "boss node" or a "follower node", depending on its type of specification. 
A "follower node" $\node$ with "follower specification" $(\followwordspec, \followmessagespec)$ is allowed to receive sequence of messages $\followwordspec$ with value $\valuelabel{\node}$ (which must be "non-initial") without it being broadcast by its children. 
Other conditions are similar to the ones for "signature protocols": if $\node$ is a node and $v \ne \valuelabel{\node}$ a "non-initial" value received in its "local run", $\node$ must have a "boss" child broadcasting this word. Moreover, for each $(m,v)$ received where $v$ is an "initial value" of the "local run", $\node$ must have a "follower" child that is able to broadcast $(m,v)$ after receiving messages sent previously with value $v$; the formal statement is more technical because it takes into account the observation of Example~\ref{ex:decomposition}. 
The formal definition of "unfolding tree" is given in \cref{app:def-trees}.


\begin{example}
	Figure~\ref{fig:ex-unfolding-tree} depicts the "unfolding tree" associated to $a_1$ in the "run" of \cref{ex:example-1}. 
	"Follower node" $\node_3$ can have a $m_2$ reception that is not matched by its children because $m_2$ is in $\followwordspec(\node_3)$. $\node_1$ broadcasts $(m_2,1)$ before receiving $(m_4,1)$ hence the "follower specification" of $\node_3$ witnesses broadcast of $(m_4,1)$. 
\end{example}
\begin{figure}[t]
	\begin{center}
			% \resizebox{\textwidth}{!}{
					\input{Figures/tree-example1}
				% }
		\end{center}
	\vspace*{-0.5cm}
	\caption{Example of an "unfolding tree". $\delta_{ri}$ (resp. $\delta_{bi}$) denotes the reception (resp. broadcast) transition of message $m_i$ in the protocol described in \cref{fig:ex1}. Values that are never broadcast are omitted and written as $\quotemarks{\_}$.}\label{fig:ex-unfolding-tree}
%	\vspace*{-0.5cm}
\end{figure}

A ""coverability witness"" is again an "unfolding tree" whose root covers $q_f$ (or broadcasts a message $m_f$, see \cref{remark:tree-root-spec-1}), with the extra condition that the root is a "boss node" (a "follower node" implicitly relies on its parent's ability to broadcast). 

\begin{restatable}{proposition}{treessoundcomplete}
	\label{prop:trees-sound-complete}
	An instance of \COVER $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}
\begin{proof}[Proof sketch]
	The proof is quite similar to the one of Lemma~\ref{lem:coverability_witness_sg}, but is made more technical by the addition of "follower" nodes. 
	When translating an "unfolding tree" to a "run", if the root of the tree is a "follower node" $\node$ of specification $(\followwordspec, \followmessagespec)$, then we actually obtain a "partial run", \emph{i.e.}, a "run" except that the receptions from $\followwordspec$ are not matched by broadcasts in the "run". We then combine this partial run with the run corresponding to the parent of $\node$ and with the runs of other children of $\node$ so that every reception is matched with a broadcast, as detailed in Lemma~\ref{lem:tree-to-run-technical}.
	For the translation from "run" to tree, we inductively construct the tree by extracting from the run the agents and values responsible for satisfying the specifications of each node and analyzing the messages they receive to determine their set of children (as in Example~\ref{ex:decomposition}). See Appendix~\ref{app:trees-sound-complete} for the proof.
	% % The translation from "run" to tree works by induction on the length of the "run". We first define in a natural way what it means for a "run" to satisfy a "specification". We consider a "run" $\run$ and isolate a well-chosen agent $a$, whose "local run" witnesses that the "specification" is satisfied. We call the induction hypothesis with the "specifications" expressing what $a$ needs to receive from other agents. Each such "specification" is satisfied by a strict prefix of $\run$ (the only exception being if $a$ satisfies a "boss specification" with value $v$ and the last step of $\run$ is a broadcast with $v$ by another agent; in this case, we use the induction hypothesis on $\run$ but with a follower specification, hence the induction is well-founded).
	% We construct an "unfolding tree" by labeling the root with the "specification" and the "local run" of $a$, and attaching below it the subtrees obtained by induction hypothesis.
	% The translation from tree to "run" consists in an induction on the tree. A key concept is the one of "partial run", which extends the notion of "local run" to a subset of agents: in a "partial run", some receptions called \emph{external} are not matched by a broadcast. This is meant to represent the behavior of a subtree of the "unfolding tree": if the root of an "unfolding tree" is a "follower node" with "specification" $(\followwordspec, \followmessagespec)$ then the corresponding "partial run" receives an external sequence $\followwordspec$. The inductive step applies the induction hypothesis to the children of the "root" to obtain partial runs and merges them with the "local run" of the root by branching broadcasts to the right external receptions. 
	% 
\end{proof}





\subsubsection{Bounding the Size of the Unfolding Tree.}
\label{sec:tree-bounds}

Our aim is again to bound the "size@@tree" of a minimal "coverability witness". In the following, we fix an instance $(\prot,q_f)$ with $r$ registers and a "coverability witness" of minimal size. We start by providing new conditions under which a branch can be shortened; for "boss specifications", it is the condition of Lemma~\ref{lem:no_subword_in_branch_sg} but for "follower specifications", the subword relation goes the opposite direction because the shorter the requirement $\followwordspec$, the better.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\node \ne \node'$ be two nodes of $\tree$ such that $\node$ is an ancestor of $\node'$. If one of those conditions holds, then $\tree$ can be shortened  (contradicting its minimality):
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; 
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$.
	\end{itemize} 
\end{restatable}

We can generalize \cref{lem:towerbound_signature} to bound the size of a node by the number of messages that it must broadcast times a primitive-recursive function $\towerfun(\size{\prot},r)$. The proof is more technical than the one of \cref{lem:towerbound_signature} but the idea is essentially the same. The formal statement is given below, and the proof can be found in Appendix~\ref{app:tower-lemma}. 
One can therefore bound the size of a node with respect to the size of the nodes that it must broadcast to.

	\begin{restatable}{lemma}{lemShortLocalRuns}
	\label{lem:short-local-runs}
	There exists a primitive recursive function $\towerfun$ such that, for every protocol $\prot$ with $r$ registers, 
	for all "local runs" $\localrun_0: (q_0, \localdata_0) \step{*} (q, \localdata)$, $\localrun: (q, \localdata) \step{*} (q', \localdata')$, $\localrun_f: (q', \localdata') \step{*} (q_f, \localdata_f)$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ with $\size{\localrun'} \leq \towerfun(\size{\prot} ,r)$ and for all $\aval' \in \nats$: 
	\begin{enumerate}
		\item if $\aval'$ appears in $\localrun_0$, $\localrun$, or $\localrun_{f}$, $\vinput{\aval'}{\localrun'} \subword \vinput{\aval'}{\localrun}$,
		\item  otherwise, there exists $\aval \in \nats$, not "initial" in $\localrun_0$, such that $\vinput{\aval'}{\localrun'} \subword \vinput{\aval}{\localrun}$.
	\end{enumerate}
\end{restatable}

It is however now much harder than in the "signature" case to bound the size of the "coverability witness". Indeed, the broadcasts no longer go only from children to parents in the "unfolding tree". If $\node_p$ is the parent of $\node_c$, then $\node_c$ broadcasts to $\node_p$ if $\node_c$ is a "boss node", but $\node_p$ broadcasts to $\node_c$ if $\node_c$ is a "follower node", in which case $\node_c$ only broadcasts one message to $\node_p$. Therefore, we cannot in general bound $\size{\node_p}$ with respect to $\size{\node_c}$ nor $\size{\node_c}$ with respect to $\size{\node_p}$, making us unable to apply the "Length function theorem" immediately. 

This leads us to arrange the "unfolding tree" so that long broadcast sequences are sent upwards, using the notion of "altitude" depicted in Figure~\ref{fig:rearrange-tree}, formally defined as follows.
The ""altitude"" of the root is $0$, the altitude of a "boss node" is the altitude of its parent minus one, and the altitude of a "follower node" is the altitude of its parent plus one.
We denote the "altitude" of $\node$ by $\altitude{\node}$.
This way the nodes of maximal "altitude" are the ones that do not need to send long sequences of messages. We will bound the size of nodes with respect to their "altitude", from the highest to the lowest, and then use the "Length function theorem" to bound the maximal and minimal "altitudes". We present here a sketch of the proof; details are postponed to Appendix~\ref{app:proofs_bounds}. 


% note that this time the bound is on the exact number of registers (and not the number of registers minus one). We shall refer to this lemma as the Tower Function Lemma as it bounds "local runs" length by a function $\psi(n,k)$ which is in fact a tower of exponentials of height $k$ where each floor is a polynomial in $n$.

% Previously, \cref{lem:no_subword_in_branch_sg,lem:towerbound_signature} lead us to the "Length function theorem". We were able to bound the size of a node with respect to the nodes to which it must send long words of messages (in the signature protocol: from leaves to root), i.e. we could find a bound for a node $\node$ with respect to its parent's size. From what we argued above, we can not do so in the general case.
%However, this is not possible for "follower nodes", as it goes in the opposite direction: a node now might need to send long sequence of messages to its "follower node" child, in order for this node to repeat a value. 
% We will thus rearrange the tree in a convenient manner. 

% A new version of \cref{lem:no_subword_in_branch_sg} can be found below: \cref{lem:shortening-branches} provides two ways of shortening an "unfolding tree", its proof can be found in Appendix~\ref{app:proofs-reduction-branches}. 
%and \cref{lem:short-local-runs}~is the direct general case version of \cref{lem:towerbound_signature}.






%\cref{lem:no_subword_in_branch_sg} is then replaced by the following lemma, which 





%We now show that there is a computable bound on the "size@@tree" of the "unfolding tree" achieving a given specification and labeled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem"; however, this theorem requires a bound on the lengths of the words. In fact, there is no reason to think that the lengths of the labels of the children of a node can be bounded with respect to the length of the label of that node. 
%
%
%In order to bound the size of the nodes, we now wish to adapt \cref{lem:towerbound_signature}~to the general case.
%We use the following result, which essentially states that if there is a "local run" between two local configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function and which does not require larger inputs than the previous one.

%\begin{restatable}{lemma}{lemShortLocalRuns}
%	\label{lem:short-local-runs}
%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "protocol" with $r$ registers, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ such that $\size{u'} < \towerfun(\size{\prot},r)$ and for all value $v \in \nats$,  $\vinput{v}{u'} \subword \vinput{v}{u}$. 
%%	\\
%%	
%%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers, for every "local run" $\localrun_0: (q_0, \localdata_0) \step{*} (q_f, \localdata_f)$ in $\prot$, for every section $\localrun : (q, \localdata) \step{*} (q, \localdata')$ of $\localrun_0$,  for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun''} \leq \towerfun(\size{\prot},r)$ and:
%%	\begin{enumerate}
%%		\item for all $\aval' \in \nats \setminus V$, there exists $\aval$ a "non-initial" value of $\localrun_0$ such that $\vinput{\aval'}{\localrun'}\subword \vinput{\aval}{\localrun}$,
%%		\item for all $\aval \in V$, $\vinput{\aval}{\localrun'} \subword \vinput{\aval}{\localrun}$. 
%%	\end{enumerate}
%\end{restatable}
%
%\begin{proof}[Proof sketch]
%	
%	
%	The proof follows the same reasoning as the proof of \cref{lem:towerbound_signature}, but this time all registers should be taken into consideration.
%	\luin{pour le moment j'ai juste déplacé l'ancien énoncé en annexe, vérifier si on peut adapter le lemme tower "signé" et sa preuve plus simplement}
%	
%%	First, as for \cref{lem:towerbound_signature}, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the "run" using an induction on the number of registers. We then manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the "local run" we may add some fresh values to it (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are less constraining than the ones that were in the original "run". For technical reasons, we want to prevent fresh values added in the proof from mimicking "initial" values of the agent.\lu{je crois que c'est pour les local disequality tests qui ne sont plus là désormais, à enlever?}
%%	See Appendix~\ref{app:tower-lemma} for the full proof.
%	
%	

% Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\begin{remark}\lu{déplacer si manque de place ?}
%	The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \end{remark}
%\begin{definition}
%	Let $\tree$ an "unfolding tree". We define the ""altitude"" of a node $\node$ of $\tree$, written $\altitude{\node}$, recursively as follows:
%	\begin{itemize}
%		\item The altitude of the root is $0$,
%		\item The altitude of a "boss node" is the altitude of its parent minus one,
%		\item The altitude of a "follower node" is the altitude of its parent plus one.
%	\end{itemize}
%\end{definition}

\begin{figure}[t]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of a tree. The root is in red, black solid arrows connect parents to children, blue dashed arrows highlight that long words of messages are sent upwards.}
	\label{fig:rearrange-tree}
\end{figure}

Let $\altmax \geq 0$ (resp. $\altmin \leq 0$) denote the maximum (resp. minimum) altitude in $\tree$.
We first bound the size of a node with respect to the difference between its altitude and $\altmax$.

\begin{restatable}{lemma}{lemBoundLengthHeightH}
	\label{lem:bound-length-at-height-h}
	%Let $\altmax$ the maximal "altitude" in $\tree$. 
	There is a primitive recursive function $f_0$ such that, for every node $\node$ of $\tree$, $\size{\node} \leq f_0(\size{\prot} + \altmax - \altitude{\node})$.
\end{restatable}
\begin{proof}[Proof sketch]
	We proceed by induction on the altitude, from highest to lowest. 
	A node of maximal "altitude"  has at most one message to broadcast (a "follower node" must broadcast one message to its parent), so its size is bounded by $\towerfun(\size{\prot},r)$ by \cref{lem:short-local-runs} (applying the Lemma to its local run minus its final step, \emph{i.e.}, the step making the broadcast to its parent).
	Let $\node$ be a node of $\tree$ whose neighbors of higher altitude have size bounded by $K$.
	We claim that $\size{\node} \leq (\towerfun(\size{\prot}, r)+2) \, (\size{\messages} \, r \, K + K)$, with $\psi$ the primitive-recursive function defined in Lemma~\ref{lem:short-local-runs}. 
	The idea is similar to the one for Lemma~\ref{lem:bounds_tree_sg}. The neighbors of higher "altitude" are the nodes which require sequences of messages from $\node$. Their size bounds the number of messages that $\node$ needs to send; we then apply Lemma~\ref{lem:short-local-runs} to bound the size of the local run of $\node$. Lemma~\ref{lem:bound-successor-height} in the appendix details these ideas.
We finally obtain $f_0$ by iteratively applying the inequality above.
\end{proof}



We now bound $\altmax$ and $\altmin$:
\begin{lemma}
$\altmax$ and $|\altmin|$ are bounded by a function of class $\Ffunction{\omega^{\size{\messages}}}$. 
\end{lemma}
\begin{proof}[Proof sketch]
We first bound $\altmax$. Consider a branch of $\tree$ that has a node at "altitude" $\altmax$. We follow this branch from the root to a node of altitude $\altmax$: for every $j \in \nset{1}{\altmax}$, let $\node_{j}$ be the first node of the branch that has altitude $j$ (Figure~\ref{fig:max-height-bound} in the appendix). All such nodes are necessarily "follower nodes" as they are above their parent. Sequence $\node_{\altmax}, \dots, \node_2, \node_1$ is so that the $i$th term is at altitude $\altmax-i$ hence its size is bounded by $f_0(\size{\prot} + i)$ (Lemma~\ref{lem:bound-length-at-height-h}). With the observation of Lemma~\ref{lem:shortening-branches}, we retrieve from the "specifications" of this sequence of nodes a "bad sequence" and we apply the "Length function theorem" to bound $\altmax$ (Lemma~\ref{lem:bound-max-height} in the appendix).
This yields in turn a bound on the size of the root of $\tree$. In order to bound $\altmin$, we proceed similarly, using "boss nodes" this time. We follow a branch from the root to a node of "altitude" $\altmin$. The sequence of nodes that are lower than all previous ones yields a sequence of "boss specifications", which is a "bad sequence" by Lemma~\ref{lem:shortening-branches}, and whose growth can be bounded using Lemma~\ref{lem:bound-length-at-height-h} and the bound on $\altmax$. We apply the "Length function theorem" to bound $|\altmin|$ (Lemma~\ref{lem:bound-min-height}).
\end{proof}

Once we have bounded $\altmax$ and $\altmin$, we can infer a bound on the size of all nodes (Lemma~\ref{lem:bound-length-at-height-h} in the appendix), and then on the length of branches: by minimality, a branch cannot have two nodes with the same specification. 
The bound on the "size@@tree" of the tree then follows from the observation that bounding the size of nodes of $\tree$ also allows to bound their number of children.
 

% \begin{restatable}{proposition}{PropBoundTreeSize}
% 	\label{prop:bound-tree-size}
% 	There exists a function $f$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ s.t. $\size{\tree} \leq f(\size{\prot})$.
% \end{restatable}

%\subsubsection{Decidability}
%\label{sec:decidability-end}

We obtain a computable bound (of the class $\Ffunction{\omega^\omega}$) on the "size@@tree" of a minimal "coverability witness" if it exists. 
Our decidability procedure computes that bound, enumerates all trees of "size@@tree" below the bound and checks for each of them whether it is "coverability witness". This yields the main result of this paper:

\decidablecover*


