\section{Cover Decidability}
\label{sec:cover-decidability}

This section is dedicated to the proof of the main result of this paper:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for BNRA is decidable and $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

For the sake of clarity, we will first focus on the case of "signature BNRA". 
As a preliminary, we start by defining a notion of "local run" meant to represent the projection of a run onto a given agent

\subsection{Local runs}
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$ and $\atrans =(q, \br{m}{i}, q')$ is a "broadcast".  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and one of the following holds:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either a "reception step" or an "internal step". 
	\AP A ""local run"" $\localrun$ is a sequence of "local steps" denoted $(q_0, \nu_0) \step{*} (q, \nu)$.
	A value $\aval \in \nats$ appearing in $\localrun$ is ""initial"" if it appears in $\nu_0$ and ""non-initial"" otherwise. 
	The ""input"" of $\localrun$, written $\intro*\Input{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of its "reception steps", its ""output"", written $\intro*\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages broadcast in $\localrun$. 
	% The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. 
	For $\aval \in \nats$, the $\aval$-""input"" $\intro*\vinput{\aval}{\localrun}$ (resp. $\val$-""output"" $\intro*\voutput{\aval}{\localrun}$) is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ (resp. $\Output{\localrun}$) on $\messages \times \set{\aval}$.

\subsection{Cover Decidability for "Signature BNRA"}
We first prove decdability of \COVER for "signature BNRA". We start with the following observation: when an agent receives messages, it can compare the values in the messages only with previously received values; the initial values in "reception-only" registers are not relevant as they can never be shared with other processes. Therefore, a given agent $a$ can only see which received messages have the same value, \emph{i.e.}, coming from the same agent, so that what $a$ needs from other agents may be stated as a set of words where each word must be received in messages of the same value. 

We call ""specifications@@signature"" words of $\messages^*$. A "specification" is meant to encode the task that a given agent accomplishes. To represent runs, we consider ""unfolding trees@@signature"" that represent such specifications, dependencies between them and how they are carried out. Because of copycat arguments, we will in fact be able to clone agents so that communications between agents only go one way, hence the tree structure.

\subsubsection{Unfolding trees}
\label{sec:unfolding_tree_signature}
An \emph{unfolding tree} is an abstraction of a "run" in the form of a tree where each node is assigned a "local run" and the "specification" that it carries out. 

\begin{definition}
\label{def:unfolding_tree_signature}
\AP An ""unfolding tree@@sg"" $\tree$ over $\prot$ is
a finite tree where nodes $\node$ have three labels:
\begin{itemize}
	\item a "local run" of $\prot$, written $\intro*\localrunlabel{\node}$, starting in the initial state with distinct register values;
	
	\item a value in $\nats$, written $\intro*\valuelabel{\node}$;
	
	\item a ""specification"" $\intro*\speclabel{\node} \in \messages^*$.
\end{itemize} 
Moreover, all nodes $\node$ in $\tree$ must satisfy the two following conditions:
\begin{enumerate}[label= (\roman*), ref=(\roman*)]
	\item \label{item:condition1_non_initial_value_sg} For each value $\aval$ received in $\localrunlabel{\node}$, $\node$ has a child $\node'$ such that $\vinput{\aval}{\localrunlabel{\node}} \subword \speclabel{\node'}$\lu{trivial dans le cas de protocole signé : l'enfant avec la valeur $v$ doit broadcast $v$, donc c'est son premier registre initial, et personne d'autre que lui ne peut envoyer ce message ainsi pas d'input -> à enlever de cette partie ? },
	\item \label{item:condition2_boss_node_sg} $\speclabel{\node} \subword \voutput{\valuelabel{\node}}{\localrunlabel{\node}}$.
\end{enumerate}

\AP Lastly, given $\tree$ an "unfolding tree@@sg", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\node}$ where $\size{\node} := \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@tree" of $\tree$ takes into account the size of its nodes, so that a tree $\tree$ can be stored in space polynomial in $\size{\tree}$ (renaming the values appearing in $\tree$ if needed). 
\end{definition}

Given $\node$ a "node@@sg" of an "unfolding tree@@sg", condition \ref{item:condition1_non_initial_value_sg} expresses that the "specifications" of children of $\node$ are witnesses that messages received in the "local run" $\localrunlabel{\node}$ can be broadcast by other agents. Condition \ref{item:condition2_boss_node_sg} expresses that $\node$ witnesses the broadcast of a sequence of messages $\speclabel{\node}$ with the same value. Note that we can use the subword relation $\subword$ because of the lossiness: it suffices to ensure that all received messages are broadcast, but some broadcast messages may not be received.  

\begin{example}
	We now give an example of a "signature protocol", and present the corresponding "unfolding treee" of a simple "local run". 
	\begin{figure}[t]
		\input{Figures/fig-ex2}
		\caption{Example of a "signature protocol".}\label{fig:ex2}
	\end{figure}
Let $\agents = \set{a_1, a_2,a_3}$, the following sequence is an initial run covering $q_4$, where $x_1, y_1, z_1, x_2, x_3$ are distinct natural integers:
	\begin{align*}
		&\tuple{(q_0, (x_1,y_1,z_1)), (q_0, (x_2,,)) , (q_0, (x_3,,))} \step{} \tuple{(q_1, (x_1,x_2,z_1)), (q_5,(x_2,,)) , (q_0, (x_3,,))} \step{} \\ 
		&\tuple{(q_2, (x_1,x_2,x_3)), (q_5,(x_2,,)), (q_5, (x_3,,))} \step{} \tuple{(q_3, (x_1,x_2,x_2)), (q_5,(x_2,,)), (q_5, (x_3,,))} \step{} \\
		&\tuple{(q_4, (x_1,x_2,x_2)),(q_5,(x_2,,)), (q_5, (x_3,,))} 
	\end{align*}
	For readability's sake we don't write the second and third registers' values of agent $a_2$ and $a_3$ as there are neither broadcast, tested and nothing is store on those registers during the run.
	First agent $a_2$ broadcasts message $hello$ with its second register's value, then $a_3$ broadcasts message $hey$ with its third register's value. Then, agent $a_2$ broadcasts message $ack$ with its second register's value and finally, agent $a_3$ broadcasts the same message but with its third register's value.
	All messages are received by agent $a_1$ which hence reaches $q_4$.
	We show now how to build the unfolding tree regarding the local run of agent $a_1$ in \cref{fig:unfolding-tree-sign}. Tables are (part of) "local runs", columns are (part of) "local configurations": we only display registers used in the local runs (the one broadcast or with a reception action on it). For $\node_2$, the transition between $q_0$ and $q_5$ should be understood as the broadcast of $hello$, whereas for $\node_3$ it should be understand as the broadcast of $hey$.
	\begin{figure}[t]
		\input{Figures/tree-example-sign}
		\caption{Example of an unfolding tree.}\label{fig:unfolding-tree-sign}
	\end{figure}


	The local run of node $\node_1$ is the local run of agent $a_1$ of the run described above. 
	By completing partial local runs by fresh integers in the other registers, one can verify that all nodes are labeled by local runs of the protocol (where the broadcast between $q_0$ and $q_5$ is with $hello$ for $\node_2$, and with $hey$ for $\node_3$).
	We now verify that conditions  \ref{item:condition1_non_initial_value_sg} and \ref{item:condition2_boss_node_sg} hold for the three nodes. Values received in $\localrunlabel{\node_1}$ are $x_2$ and $x_3$, hence from condition \ref{item:condition1_non_initial_value_sg}, node $\node_1$ has two children $\node_2$ and $\node_3$. Note that $\vinput{x_2}{\localrunlabel{\node_2}} = \vinput{x_3}{\localrunlabel{\node_3}} = \epsilon$\lu{si on modifie la condition, on peut enlever cette phrase}. As $\spec(\node_1) = \epsilon$, condition \ref{item:condition2_boss_node_sg} is trivially true for $\node_1$. Note that nodes $\node_2$ and $\node_3$ don't receive any message on their respective local runs and so condition \ref{item:condition1_non_initial_value_sg} is trivially true. Furthermore, $\voutput{x_2}{\localrunlabel{\node_2}} = hello \cdot ack = \spec(\node_2)$ and $\voutput{x_3}{\localrunlabel{\node_3}} = hey \cdot ack = \spec(\node_3)$.
\end{example}

\begin{lemma}
\label{lem:coverability_witness_sg}
Given a "signature protocol" $\prot$ with a state $q_f$, $(\prot,q_f)$ is a positive instance of \COVER if and only if there exists an "unfolding tree@@sg" whose root node's local run covers $q_f$. We call such an "unfolding tree@@sg" a ""coverability witness@@sg"".
\end{lemma}
\begin{proof}
Given an "execution" $\run$, we say that an agent $a$ in $\run$ satisfies a "specification@@sg" $w \in \messages^*$ if, in $\run$, the sequence of "message types" broadcast by $a$ admits $w$ as "subword".% if such an agent $a$ exists, we say that $\run$ satisfies "specification@@sg" $w$.   

Suppose that we have such an "unfolding tree@@sg" $\tree$. We prove by induction on the size of the subtree $\tree'$ of $\tree$ the following property: by letting $\node$ the root of $\tree'$, there exists a "run" $\run$ with an agent $a$ satisfying the "specification@@sg" $\speclabel{\node}$ and whose "local run" in $\run$ is $\localrunlabel{\node}$. Let $\tree'$ a subtree of $\tree$, let $\node$ the "root" of $\tree'$, $\localrun := \localrunlabel{\node}$ and $\aval_1, \dots, \aval_c$ the values received in $\localrun$; applying condition \ref{item:condition1_non_initial_value_sg} gives the existence of corresponding children $\node_1, \dots, \node_c$ in $\tree'$. We apply the induction hypothesis on the "subtrees" rooted in $\node_1, \dots, \node_c$ to obtain "runs" $\run_1, \dots, \run_c$ satisfying the "specifications@@sg" of the children of $\node$. Up to renaming agents, we can assume the set of agents of these runs are disjoint; up to renaming values, we can assume that $\aval_j = \valuelabel{\node_j}$ for all $j$. We build a run $\run$ whose "agents" is the union of the "agents" of the $c$ runs along with a fresh agent $a$. In $\run$, we make $\run_1$ to $\run_c$ progress in parallel and make $a$ follow the "local run" $\localrun$, matching reception with value $v_j$ in $\localrun$ with a broadcast in $\run_j$. This is possible because, for all $j$, $\vinput{v_j}{\localrun} \subword \speclabel{\node_j} \subword \voutput{v_j}{\run_j}$. 

Conversely, consider a "run" $\run$. We prove the following by induction on the length of $\run$: for every agent $a$ in $\run$ and for every $v \in \nats$, there exists an "unfolding tree" whose root has "local run" the projection of $\run$ onto $a$ and "specification@@sg" the $v$-output of $a$ in $\run$. If $\run$ is the empty run, consider the "unfolding tree" with a single node whose "local run" and "specification@@sg" are empty. Suppose now that $\run$ has non-zero length, let $a$ an agent in $\run$, $v \in \nats$ and let $\run_p$ the prefix run of $\run$ of length $\size{\run}-1$.
Let $\tree_1$ the "induction tree" obtained by applying the induction hypothesis to $\run_p$, $a$ and $v$, and consider $\tree_2$ obtained by simply appending the last step of $a$ in $\run$ to the "local run" at the root of $\tree_1$. If this last step is a broadcast, we obtain an "unfolding tree"; if the broadcast value is $v$, we append the broadcast "message type" to the "specification@@sg" at the root of $\tree_2$ and we are done. 
Suppose that, in the last step of $\run$, $a$ performs a reception $(q, \rec{m}{i}{\anact},q')$ of a message $(m,\aval')$. We might need to adapt $\tree_2$ to respect condition \ref{item:condition1_non_initial_value_sg} at the root. Let $a'$ the agent broadcasting in the last step of $\run$. Let $\tree_3$ the "unfolding tree@@sg" obtained by applying the induction to $\run_p$ ,$a'$ and $v'$. Let $\tree_4$ the "unfolding tree@@sg" obtained by appending the last broadcast to the "local run" at the root of $\tree_3$ and the corresponding "message type" to the "specification@@sg" at the root of $\tree_3$. Attaching $\tree_4$ to the root of $\tree_2$ gives an "unfolding tree@@sg" satisfying the desired properties. 
% Note that this construction may generate more children than needed at the root - maybe another child was already there to witness broadcasts of $a'$ in $\run_p$, in which case this child may be deleted. 
\end{proof}

Our aim is now to bound the size of the "coverability witness@@sg" that we have to consider.

\subsubsection{Bounding the Size of the Unfolding Tree}
Observe that, because of the lossiness of the system, a longer "specification@@sg" is generally better. We formalize this idea as follows:

\begin{lemma}
\label{lem:no_subword_in_branch_sg}
Let $\tree$ be a "coverability witness@@sg" for $(\prot,q_f)$ with $\prot$ a "signature protocol". Let $\node, \node'$ be two nodes of $\tree$ such that $\node$ is a strict ancestor of $\node'$. If $\speclabel{\node} \subword \speclabel{\node'}$, then there exists a "coverability witness@@sg" for $(\prot, q_f)$ of size strictly smaller than $\size{\tree}$.
\end{lemma}
\begin{proof}
It suffices to replace the subtree rooted in $\node$ with the one rooted in $\node'$.
\end{proof}

With the previous lemma, we would now like to use the "Length function theorem" to bound the size of the tree. However, to do that, we first need a bound on the "size@@treesg" of a node with respect to its parent's "size@@treesg". The following lemma essentially states that the local run of a node may be bounded by a primitive recursive function with respect to the "size@@sg" of its "specification@@sg".

\begin{lemma}
\label{lem:towerbound_signature}
There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "signature protocol" with $r+1$ registers, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ such that $\size{u'} < \towerfun(\size{\prot},r)$ and for all value $v \in \nats$,  $\vinput{v}{u'} \subword \vinput{v}{u}$. 
\end{lemma}
\begin{proof}
Register $i$ is ""active@@sg"" in $u$ if $u$ has at least one $\quotemarks{\enregact}$ action on register $i$, we note $k$ the number of "active@@sg" registers in the local run $\localrun$. We define $\towerfun(n,k)$ by $\towerfun(n,0) = n+1$ and $\towerfun(n,k+1) = \towerfun(n,k) \cdot ({\size{\transitions}}^{\towerfun(n,k)}+1)$. Observe that $\towerfun(n,k)$ is a tower of exponentials of height $k$, which is primitive-recursive although non-elementary.
We prove by induction on $k$ that $u$ can be shortened. Let $n := \size{\prot}$ and $M := \towerfun(n,k)$.
 

If $k=0$, register values do not change and any state repetition can be removed. Suppose that $\size{u} > \towerfun(n,k+1)$ and that the set $I \subseteq \nats$ of active registers of $u$ is such that $\size{I} = k+1$. If there exists an infix run of $u$ of length $M$ with only $k$ active registers, we shorten $u$ using the induction hypothesis. Otherwise, every sequence of $M$ steps in $u$ has a $\quotemarks{\enregact}$ on each register of $I$. Because there are $\size{\transitions}^M$ such sequences and $\size{\localrun} > M \cdot (\size{\transitions}^M +1)$, one sequence $s \in \transitions^M$ appears twice (disjointly) in $\localrun$: in infix run $u_1$ first, then in infix run $u_2$. We shorten $u$ by removing all steps between $u_1$ and $u_2$ and merging $u_1$ and $u_2$. Note that $u_1$ and $u_2$ may differ in terms of values received. To merge them, for a given $i \in I$, let $j$ the index of the first $\quotemarks{\enregact}$ on register $i$ in $s$; we replace in $u_1$, from step $j$ onwards, the values of all receptions involving $i$ by the corresponding values in $u_2$. This guarantees that all equality and disequality tests still pass. The obtained run is shorter than $u$ and satisfies the desired property; we iterate this shortening procedure until the length of the local run is less that $\towerfun(n,k+1)$.
\end{proof}

\luin{if we have some place left, fig to explain proof of above lemma?}

Using the previous lemma, we may bound the size of a node of a well-chosen "unfolding tree@@sg" with respect to its "specification@@sg".

\begin{lemma}
\label{lem:bounds_tree_sg}
Suppose that $(\prot, q_f)$ is a positive instance of \COVER where $\prot$ is a "signature protocol" with $r+1$ registers. Let $\tree$ be a "coverability witness" of minimal "size@@treesg".
For every node $\node$ in $\tree$: \begin{itemize}
\item $\size{\localrunlabel{\node}} \leq \towerfun(\size{\prot}, r) (\size{\speclabel{\node}}+1)$,
\item if $\node$ is the child of $\node'$, $\size{\node} \leq \size{\node'} \cdot (\towerfun(\size{\prot},r)+2)$.
\end{itemize} 
\end{lemma}
\begin{proof}
For the first statement, we identify in $\localrunlabel{\node}$ the broadcasts witnessing $\speclabel{\node}$, and shorten the "local run" in between these steps using Lemma~\ref{lem:towerbound_signature}.
For the second statement, we observe that, by minimality of $\tree$, $\size{\speclabel{\node}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node'}}} \leq \size{\node'}$.  
\end{proof}

This finally allows us to bound the size of a "coverability witness" of "minimal size", using the "Length function theorem":

\begin{proposition}
\label{prop:bounded_witness_sg}
There exists a function $h$ of class $\Ffunction{w^{\size{\messages}+1}}$ such that, 
for all positive instance $(\prot, q_f)$ of \COVER where $\prot$ is a "signature protocol", there exists a "coverability witness" $\tree$ of size $\size{\tree} \leq f(\size{\prot})$.
\end{proposition}
\begin{proof}
Let $n := \size{\prot}$, let $r+1$ the number of registers in $\prot$. 
Let $\tree$ a "coverability witness" (which exists thanks to Lemma~\ref{lem:coverability_witness_sg}). Thanks to Lemma~\ref{lem:no_subword_in_branch_sg}, for all $\node \ne \node'$ in 
$\tree$ with $\node$ ancestor of $\node'$, $\speclabel{\node}$ is not a subword of $\speclabel{\node'}$.  Let $\node_1, \dots, \node_m$ the node appearing in a branch of $\tree$, from root to leaf. The sequence $\speclabel{\node_1}, \dots, \speclabel{\node_m}$ is a "bad sequence".
Thanks to Lemma~\ref{lem:bounds_tree_sg}\ and as $\size{\speclabel{\node_{i+1}}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node_i}}} \leq \size{\localrunlabel{\node_i}}$, for all $i<m$, $\size{\speclabel{\node_{i+1}}} \leq \towerfun(n,r) (\size{\speclabel{\node_{i}}} +1)$ (with $\speclabel{\node_1} = 1$ as the root must cover $q_f$). By direct induction, $\size{\speclabel{\node_i}}$ is bounded by $g^{(i)}(n)$ where $g: n \mapsto (\towerfun(n,n)+1) \cdot n$ which is a primitive-recursive function. Let $f$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ the function obtained when applying the "Length function theorem" on $g$ and $\messages$; we have $m \leq f(n)$. 

This allows to bound the "size@@sg" of every node in $\tree$ by $f'(n) = (\towerfun(n,n)+2)^{f(n) + 1}$ thanks to Lemma~\ref{lem:bounds_tree_sg} and to an immediate induction. 
% (initialization thanks to Lemma~\ref{lem:towerbound_signature}). 
By minimality of $\tree$, the number of children of a node is bounded by the number of values appearing in its "local run" hence by $f'(n)$, so the total number of nodes is bounded by $f'(n)^{f(n)+1}$ and the total size of the tree by $h:n \mapsto f'(n)^{f(n)+2}$. Because $\Ffunction{\omega^{\size{\messages}+1}}$ contains all primitive-recursive functions and is closed under multiplication and exponentiation, $h$ is in $\Ffunction{\omega^{\size{\messages}+1}}$.
\end{proof}

The previous argument shows that \COVER for "signature protocols" is decidable and lies in complexity class $\Fcomplexity{\omega^{m+1}}$ for a fixed-size alphabet of size $m$ and in $\Fcomplexity{\omega^\omega}$ in general. Because the hardness from Proposition~\ref{prop:reduction-LCS} holds for "signature protocols", \COVER is in fact complete for this complexity class.

We now extend this method to the general case. 

%%%%%%%%%%%%%%%%%%%

\subsection{General case}
In the general case, some more complex behaviors occur and the same unfolding tree is not sufficient. A value can now be store by some agent \emph{and repeated}, furthermore, an agent could need some other agents to repeat its initial value in order to issue a transition. Remember run described in \cref{ex:example-1}~where the first agent needs to receive message$(m_6, x_1)$ to reach $q_7$. Hence, because of this new scenario, we now have two types of specifications: \emph{"boss specification"} which describes the usual scenario for "signature protocol" (the value to broadcast among with the specification is initial) and the \emph{"follower specification"}: the role of a node with a "follower specification" is now to repeat a given value. In order to repeat this value, the node is given an input word (a word $w$ of messages types received with the value to repeat) and an objective (a message type to broadcast with the value to repeat).

\subsubsection{Notations and Definitions}
\label{sec:decidability-defs}
% decompositions , admits decompositions

We will now need a way to handle and describe "follower specification", and we shall use the following notions.
A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. 
A word $w \in \messages^*$ ""admits decomposition"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w \subword w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding letters from $\set{m_1, \ldots, m_{j-1}}$. 
We denote by $\intro*\langdec{\decsymb}$ the language of words that "admit decomposition" $\decsymb$. 
This definition will be useful later; the intuition is that a "decomposition" describes the sequence of messages sent with some value $v$ in a "run". The $w_i$ are "message types" sent by the agent with that value initially, and the $m_i$ mark the times at which each "message type" is broadcast for the first time by another agent. This is all the information we need as if an agent manages to send some message $(m,v)$ with a value $v$ it did not have initially, then from this point on we can assume that we have an unlimited supply of messages $(m,v)$, using (essentially) the "copycat principle".  

\subsubsection{New Unfolding trees}
\label{sec:decidability-tree-unfoldings}
% new definition and conditions 

As before, a "boss specification" consists of a word $\bossspec \in \messages^\ast$ describing a sequence of message types that should be broadcast all with the same initial value. A "follower specification" consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that one must be able to broadcast $\followmessagespec$ with value $v$ after receiving the sequence $\followwordspec$ with value $v$. 

\begin{definition}
	\label{def:unfolding_tree}
	\AP An ""unfolding tree"" $\tree$ over $\prot$ is
	a finite tree where nodes $\node$ have three labels:
	\begin{itemize}
		\item a "local run" of $\prot$, written $\intro*\localrunlabel{\node}$, starting in the initial state with distinct register values;
		
		\item a value in $\nats$, written $\intro*\valuelabel{\node}$;
		
		\item a ""specification"" $\intro*\speclabel{\node}$, which is either a word $\intro*\bosslabel{\node} \in \messages^*$ ("boss specification") or a pair $(\intro*\followlabelword{\node}, \intro*\followlabelmessage{\node}) \in \messages^* \times \messages$ ("follower specification"). In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"".
	\end{itemize} 
	Moreover, all nodes $\node$ in an "unfolding tree" must satisfy the four following conditions:
	\begin{enumerate}[label= (\roman*), ref=(\roman*)]
		\item \label{item:condition1_non_initial_value} For each "non-initial value" $\aval \ne \valuelabel{\node}$ of $\localrunlabel{\node}$, $\node$ has a child $\node'$ which is a "boss node" such that $\vinput{\aval}{\localrunlabel{\node}}$ is a subword of $\bosslabel{\node'}$.
		
		\item \label{item:condition2_initial_value} For each "initial value" $\aval$ in $\localrunlabel{\node}$, there is a "decomposition" $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$~s.t.:
		\begin{itemize}
			\item $\localrunlabel{\node}$ may be split into successive "local runs" $\localrun_0, \dots, \localrun_{\ell}$ where, for all $i \in \nset{1}{\ell}$, $w_i \subword \voutput{\aval}{\localrun_i}$ and $\vinput{\aval}{\localrun_i} \in \set{m_1, \dots, m_{i-1}}^*$,
			\item for all $i \in [1,\ell]$, $\node$ has a child $\node_i$ which is a "follower node" such that $\followlabelmessage{\node_i} = m_i$ and $\followlabelword{\node_i} \in\langdec{\decsymb_i}$ where $\decsymb_i = (w_0, m_1, w_1, \ldots, m_{i-1}, w_{i-1})$.	\end{itemize}
		
		\item \label{item:condition3_follower_node} If $\node$ is a "follower node" then $\valuelabel{\node}$ is not an "initial value" of $\localrun$, $\vinput{\valuelabel{\node}}{\localrun} \subword \followlabelword{\node}$ and 
		$\voutput{\valuelabel{\node}}{\localrun}$ contains $\followlabelmessage{\node}$.
		
		\item \label{item:condition4_boss_node} If $\node$ is a "boss node", then $\valuelabel{\node}$ is an "initial value" of $\localrunlabel{\node}$ and the "decomposition" $\decsymb$ of \ref{item:condition2_initial_value} for $\valuelabel{\node}$ satisfies that $\bosslabel{\node} \in \langdec{\decsymb}$.
	\end{enumerate}
	
	\AP Lastly, as before, given $\tree$ an "unfolding tree", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. %Note that the "size@@tree" of $\tree$ takes into account the size of its nodes, so that a tree $\tree$ can be stored in space polynomial in $\size{\tree}$ (renaming the values appearing in $\tree$ if needed). 
\end{definition}
 
 We now explain this definition. Let $\node$ be a node of an "unfolding tree" $\tree$ and let $\localrun := \localrunlabel{\node}$. 
 
 As before, $\localrun$ encodes the "local run" of a given agent, $\speclabel{\node}$ encodes the specification that this "local run" carries out and $\valuelabel{\node}$ encodes the value for which the "specification" is carried out.

Conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value} state that the "specifications" of the children of $\node$ are witnesses that messages received in the "local run" $\localrunlabel{\node}$ can be broadcast by other agents. 
Conditions \ref{item:condition3_follower_node} and \ref{item:condition4_boss_node} state that $\node$ is a witness that its "specification" is carried out. 

As before, condition \ref{item:condition1_non_initial_value} expresses that, for every "non-initial value" $\aval$ of $\localrun$, $\node$ must have a "boss" child witnessing that $\vinput{v}{\localrun}$ can indeed be broadcast. 
Because $\aval$ was first stored by a "reception step" of $\localrun$, any other (fresh) value with sequence of message types containing $\vinput{v}{\localrun}$ also works and we do not impose the value label of this child to be $v$. 

We now explain condition \ref{item:condition2_initial_value}, which states that every initial value $v$ in $\localrunlabel{\node}$ can indeed be repeated (if needed). Let $v$ be an "initial value" of $\localrun$. Consider a "run" where $\localrun$ is the "local run" of agent $a$. If another agent broadcasts with value $v$, it has first received and stored $\aval$. Therefore, such an agent can be duplicated, and we may afterwards assume that we have an unlimited supply of messages $(m,v)$.
We split $\localrun$ into $u_0,\dots,u_\ell$ based on the first point where each type of message is received with value $v$. For every $i$, the sequence of messages available with value $v$ during $u_i$ is $\voutput{v}{u_i}$ expanded by freely adding symbols from $\set{m_1,\dots, m_{i-1}}$. Therefore, the child $\node_i$ responsible for the broadcast of $(m_i,v)$ may first receive with value $v$ a subword of $w_0' \cdot w_1' \cdots w_{i-1}'$ where, for all $j \leq i-1$, $w_j$ is obtained from $\voutput{v}{u_i}$ by adding symbols from $\set{m_1, \dots, m_{j-1}}$, which we state as $\followlabelword{\node_i} \in \langdec{\decsymb_i}$.   

Condition~\ref{item:condition3_follower_node} directly states that a "follower node" $\node$ receives word $\followlabelword{\node}$ with value $\valuelabel{\node}$ and broadcasts message $(\followlabelmessage{\node}, \valuelabel{\node})$. Condition \ref{item:condition4_boss_node} expresses that a "boss node" witnesses the broadcast of a sequence of messages $\bosslabel{\node}$ with a single value; whereas in the "signature protocol" case, in this sequence, some messages may come from auxiliary agents encoded in "follower" children, which is why we have the condition that $\bosslabel{\node} \in \langdec{\decsymb}$ and not simply $ \voutput{\valuelabel{\node}}{\localrun} \subword \bosslabel{\node}$. 

Our aim is to prove that we can study \COVER directly on "unfolding trees". We consider trees whose root is a "boss node", as they suffice to witness "coverability"  (a "follower node" implicitely relies on its parent's ability to broadcast some messages). We will assume that the root of a "coverability witness" has a "boss specification", as before, the local run of such a tree should cover $q_f$.

\begin{example}
	\lu{example?}
\end{example}
%\begin{figure}
%	\begin{center}
%		\resizebox{\textwidth}{!}{
%			\input{Figures/tree-example1}
%		}
%	\end{center}
%	\caption{Example of an "unfolding tree". The step labels in "local runs" are omitted for simplicity.}\label{fig-ex-unfolding-tree}
%\end{figure}
%
%\begin{example}
%	In \cref{fig-ex-unfolding-tree}~we display an "unfolding tree" obtained from the "run" of \cref{ex:example-1}. Tables are "local runs", columns are "local configurations". For instance, the "local run" at $\node_1$ is \begin{multline*} 
%		(q_0, (x_1,y_1)) \intstep{(q_0, \br{m_2}{1},q_1)} (q_1, (x_1, y_1)) \extbr{(q_1, \rec{m_4}{2}{\enregact}, q_4)}{y_2} (q_4, (x_1, y_2)) \\ \extbr{(q_4, \rec{m_6}{1}{\eqtestact}, q_7)}{x_1} (q_7, (x_1, y_2)) \intstep{(q_7, \br{m_7}{1},q_7)} (q_7, (x_1, y_2)) \end{multline*}
%	
%	
%	
%	We explain why conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value} are satisfied at the root $\node_1$ of the tree. Let $\localrun := \localrunlabel{\node_1}$ its "local run". 
%	The only "non-initial value" in $\localrun$ is $y_2$, and $\vinput{y_2}{\localrun} = m_4$; condition \ref{item:condition1_non_initial_value} is satisfied as $\node_1$ has a boss child with a "boss specification" containing $m_4$. 
%	For "initial value" $y_1$, condition~\ref{item:condition2_initial_value} is satisfied as $\localrun$ never receives a message with value $y_1$. For $x_1$, consider the decomposition $\decsymb := (w, m_6, w')$ for $w:= m_2$ and $w' := m_7$ seen as words of $\messages^*$. Condition~\ref{item:condition2_initial_value} is satisfied thanks to $\node_3$ being a child of $\node_1$ with "follower specification" $(\mathbf{fm}, \mathbf{fw})$ such that $\mathbf{fm} = m_6$ and $\mathbf{fw} \in \langdec{\decsymb_1}$ where $\decsymb_1 = (m_2)$. One can check that conditions~\ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value} are satisfied for the other nodes. 
%	
%	Condition \ref{item:condition3_follower_node} only applies to $\node_3$. It is satisfied as $\localrunlabel{\node_3}$ broadcasts $(m_6,x_1)$ after receiving only $(m_2,x_1)$ with that value. 
%	For condition \ref{item:condition4_boss_node}, it suffices to observe that $\node_2$ and $\node_4$ broadcast their $\bossspec$ themselves; we can consider "decompositions" $(m_4)$ and $(m_2)$ respectively. Moreover, $\node_1$ satisfies "boss specification" $\bossspec:= m_1 \, m_6 \, m_6 \, m_7$ as $\bossspec \in \langdec{\decsymb}$ with $\decsymb := (m_2, m_6, m_7)$ as above. Therefore $\node_1$ is a witness that $\bossspec$ can be broadcast with a single value, although its "local run" does not broadcast $m_6$ itself. 
%	
%	The "run" from Example~\ref{ex:example-1} involved two agents $a_1$ and $a_2$; $a_1$ corresponds to nodes $\node_1$ and $\node_4$ and $a_2$ 
%	to nodes $\node_2$ and $\node_3$. Note that, if we apply our procedure described below to build a "run" from $\tree$, we would use $4$ distinct agents, each playing a single role.
%\end{example}

% sound & complete 

\begin{restatable}{proposition}{treessoundcomplete}
	\label{prop:trees-sound-complete}
	An instance of $\COVER$ $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}
\begin{proof}[Proof sketch]
	The translation from "run" to tree works by induction on the length of the "run". We first define in a natural way what it means for a "run" to satisfy a "specification". We consider a "run" $\run$ and isolate a well-chosen agent $a$, whose "local run" witnesses that the "specification" is satisfied. We call the induction hypothesis with the "specifications" expressing what $a$ needs to receive from other agents. Each such "specification" is satisfied by a strict prefix of $\run$ (the only exception being if $a$ satisfies a "boss specification" with value $v$ and the last step of $\run$ is a broadcast with $v$ by another agent; in this case, we use the induction hypothesis on $\run$ but with a follower specification, hence the induction is well-founded).
	We construct an "unfolding tree" by labeling the root with the "specification" and the "local run" of $a$, and attaching below it the subtrees obtained by induction hypothesis.
	
	The translation from tree to "run" consists in an induction on the tree. A key concept is the one of "partial run", which extends the notion of "local run" to a subset of agents: in a "partial run", some receptions called \emph{external} are not matched by a broadcast. This is meant to represent the behavior of a subtree of the "unfolding tree": if the root of an "unfolding tree" is a "follower node" with "specification" $(\followwordspec, \followmessagespec)$ then the corresponding "partial run" receives an external sequence $\followwordspec$. The inductive step applies the induction hypothesis to the children of the "root" to obtain partial runs and merges them with the "local run" of the root by branching broadcasts to the right external receptions. 
	See Appendix~\ref{app:trees-sound-complete} for the full proof. 
\end{proof}




%lemma restating what whas stated for signature protocol (boss nodes) + follower nodes

% present here the new arrangment of the tree / defintion of altitude + figure

% tower lemma (observe that it will be helpful to bound highest follower lemma so maybe not here)

% je pense qu'il faut reformuler lemma 29, le "w" c'est bizarre 




\subsubsection{Bounding the Size of the Unfolding Tree}
\label{sec:tree-bounds}

Our aim is now to provide bounds on the "size@@tree" of the "coverability witness". 
As in the "signature protocol" case, for "boss specifications", the longer the word broadcast, the better: if a word $\bossspec$ can be broadcast with a single value, then any subword of $\bossspec$ can also be broadcast. 
For "follower specifications", it goes in the opposite direction: for a fixed $\followmessagespec$, the shorter the requirement $\followwordspec$, the better. \cref{lem:no_subword_in_branch_sg} is then replaced by the following lemma, which provides two ways of shortening an "unfolding tree". Its proof can be found in Appendix~\ref{app:proofs-reduction-branches}.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\tree$ be a "coverability witness" for $(\prot, q_f)$.
	Let $\node, \node'$ be two nodes of $\tree$ such that $\node$ is an ancestor of $\node'$. If one of the conditions below holds, then there exists a "coverability witness" for $(\prot, q_f)$ of "size@@tree" smaller than $\size{\tree}$:
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; or
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$.
	\end{itemize} 
\end{restatable}



We now show that there is a computable bound on the "size@@tree" of the "unfolding tree" achieving a given specification and labeled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem"; however, this theorem requires a bound on the lengths of the words. In fact, there is no reason to think that the lengths of the labels of the children of a node can be bounded with respect to the length of the label of that node. 


In order to bound the size of the nodes, we now wish to adapt \cref{lem:towerbound_signature}~to the general case.
%We use the following result, which essentially states that if there is a "local run" between two local configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function and which does not require larger inputs than the previous one.

\begin{restatable}{lemma}{lemShortLocalRuns}
	\label{lem:short-local-runs}
	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers, for every "local run" $\localrun_0: (q_0, \localdata_0) \step{*} (q_f, \localdata_f)$ in $\prot$, for every section $\localrun : (q, \localdata) \step{*} (q, \localdata')$ of $\localrun_0$,  for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun''} \leq \towerfun(\size{\prot},r)$ and:
	\begin{enumerate}
		\item for all $\aval' \in \nats \setminus V$, there exists $\aval$ a "non-initial" value of $\localrun_0$ such that $\vinput{\aval'}{\localrun'}\subword \vinput{\aval}{\localrun}$,
		\item for all $\aval \in V$, $\vinput{\aval}{\localrun'} \subword \vinput{\aval}{\localrun}$. 
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	
	
	The proof follows the same reasoning as the proof of \cref{lem:towerbound_signature}, but this time all registers should be taken into consideration.
	\luin{dites moi si je me trompe mais on peut simplifier l'énoncé maintenant qu'on a plus les local disequality tests non ? décommenter le sketch proof si ce n'est pas le cas}
	
%	First, as for \cref{lem:towerbound_signature}, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the "run" using an induction on the number of registers. We then manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the "local run" we may add some fresh values to it (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are less constraining than the ones that were in the original "run". For technical reasons, we want to prevent fresh values added in the proof from mimicking "initial" values of the agent.\lu{je crois que c'est pour les local disequality tests qui ne sont plus là désormais, à enlever?}
%	See Appendix~\ref{app:tower-lemma} for the full proof.
	
	
\end{proof}

\begin{remark}
	The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \end{remark}

If we had in our "unfolding tree" only "boss nodes" or only "follower nodes", then the previous result would allow us to apply the "Length function theorem" (note that this is the case in the "signature protocol" case). Indeed, we can bound the size of a node with respect to the nodes to which it must send long words of messages. This means we can find a bound for a node $\node$ that depends on $\node$'s "follower" children's size and, if $\node$ is a "boss" node, with respect to its parent's size. However, we cannot bound the "size@@tree" of an "unfolding tree" from the root to the leaves because of "follower nodes" nor from the leaves to the root because of "boss nodes". We thus rearrange the tree as in Figure~\ref{fig:rearrange-tree} to make it so that long sequences of messages are sent upwards. We formalize this with the notion of altitude:

\begin{definition}
	Let $\tree$ an "unfolding tree". We define the ""altitude"" of a node $\node$ of $\tree$, written $\altitude{\node}$, recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$,
		\item The altitude of a "boss node" is the altitude of its parent minus one,
		\item The altitude of a "follower node" is the altitude of its parent plus one.
	\end{itemize}
\end{definition}

\begin{figure}[h]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of a tree, with the root in red. Black solid arrows connect parents to children, blue dashed arrows highlight that long words of messages are sent upwards.}
	\label{fig:rearrange-tree}
\end{figure}
\luin{no change after this point}

We now use the previous lemma to bound the label of each node $\node$ with respect to its neighbors of higher altitude, i.e., its "follower" children and its parent if it is a "boss node". The idea is that these nodes define the number of messages that $\localrunlabel{\node}$ must output to satisfy the "unfolding tree" conditions. The function $\psi$ in the statement below is the one from Lemma~\ref{lem:short-local-runs}.

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\prot$ be a "protocol" over $\regnum$ registers, let $\tree$ be an "unfolding tree" over $\prot$ of minimal "size@@tree" satisfying a "boss specification" $\bossspec$, let $\node$ be a node of $\tree$.
	Let $K$ be such that for all "follower" children $\node_f$ of $\node$, $\size{\followlabelword{\node_f}} \leq K$.
	We have the following properties:
	
	\begin{enumerate}				
		\item  If $\node$ is a "boss node" then 
		\begin{itemize}
			\item If $\node$ is the root of $\tree$ then $\bosslabel{\node} = w$, otherwise $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$ with $\node'$ its parent\lu{moi pas comprendre ce $w$ et cette formulation}
			
			\item In both cases $\size{\localrunlabel{\node}} \leq \towerfun(\size{\prot},r)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK +1 \Big]$
		\end{itemize}
		
		\item If $\node$ is a "follower node" then  $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}} \leq \towerfun(\size{\prot},r)\Big[ 1 + \size{\messages}rK \Big]$
			
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	A node $\node$ has at most $\size{\messages}$ "follower" children for each "initial value", hence at most $\size{\messages}r$ in total, each one of them requires at most $K$ messages. The node $\node$ may have to output $\bosslabel{\node}$ extra messages to satisfy its "specification" if it is a "boss node", or just one extra message if it is a "follower node".
	This gives a bound on the number of messages $\localrunlabel{\node}$ needs to broadcast. We mark the positions at which $\localrunlabel{\node}$ sends them and use Lemma~\ref{lem:short-local-runs} to bound the length of sections of the "run" connecting two such broadcasts by $\towerfun(\size{\prot},r)$, which yields the bounds above. See Appendix~\ref{app:bound-node-with-spec} for the full proof.
\end{proof}

Thanks to the previous lemma, we bound the size of a node with respect to its altitude: 
\begin{restatable}{lemma}{lemBoundLengthHeightH}
	\label{lem:bound-length-at-height-h}
	Let $(\prot,q_f)$ be a positive instance of \COVER, $\tree$ a "coverability witness" for $(\prot,q_f)$, $\altmax$ the maximal "altitude" in $\tree$. There exists a primitive recursive function $f_0$ such that any node $\node$ of $\tree$ has size bounded by $f_0(\size{\prot} + \altmax - \altitude{\node})$.
\end{restatable}
\begin{proof}[Proof sketch]
Applying Lemma~\ref{lem:bound-successor-height} inductively from highest to lowest altitude, we bound the sizes of the labels of all nodes at a given altitude $i$ with respect to $\altmax-i$.
See Appendix~\ref{app:bound-node-size-with-altitude} for the detailed proof. 
\end{proof}
 
\begin{restatable}{proposition}{PropBoundTreeSize}
	\label{prop:bound-tree-size}
	There exists a function $f$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ such that an instance $(\prot,q_f)$ of \COVER is positive if and only if it has a "coverability witness" $\tree$ of size bounded by $f(\size{\prot})$.
\end{restatable}

\begin{proof}[Proof sketch]
	The full proof is in Appendix~\ref{app:bound-tree-size}. $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for it thanks to Proposition~\ref{prop:trees-sound-complete}; we consider the "coverability witness" $\tree$ of minimal size.
	In a branch of $\tree$ reaching maximal altitude, we mark the nodes that have a greater altitude than all the previous ones (see Figure~\ref{fig:max-height-bound}). They are necessarily "follower" nodes as a "boss" node is below its parent. This sequence (taken from highest to lowest altitude) is so that the $i$th term is at altitude $\altmax-i$ and we can bound its "size@@tree" with respect to $i$ with the previous arguments. Along with Lemma~\ref{lem:shortening-branches}, we apply the "Length function theorem" on that sequence to bound its length hence the maximal altitude (Lemma~\ref{lem:bound-max-height}).
	
	This yields in turn a bound on the root label, as its altitude ($0$) has a bounded difference with the maximal one. Another application of the "Length function theorem", this time with "boss nodes", allows us to bound the minimal altitude of a node of this tree (Lemma~\ref{lem:bound-min-height}).
	
	Once we have bounded both the maximal and minimal altitudes, we can infer a bound on the size of all nodes using Lemma~\ref{lem:bound-length-at-height-h}, and then on branches as we can shorten branches as soon as they have two nodes with the same specification.
	The bound on the "size@@tree" of the tree then follows from the observation that as nodes have bounded "local runs", they only see a bounded amount of values and thus need a bounded amount of children. 
\end{proof}


\subsubsection{Decidability}
\label{sec:decidability-end}

In Section~\ref{sec:decidability-tree-unfoldings}, we showed that "unfolding trees" are a sound and complete abstraction for \COVER. In Section~\ref{sec:tree-bounds}, we proved that there is a computable bound (of the class $\Ffunction{\omega^\omega}$) on the "size@@tree" of a minimal "coverability witness", if it exists. Our decidability procedure computes that bound, enumerates all trees of "size@@tree" below the bound and checks for each of them whether it is "coverability witness". Details can be found in Appendix~\ref{app:decidability}.

\decidablecover*


