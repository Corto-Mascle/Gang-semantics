\section{Coverability Decidability for Signature Protocols}
\label{sec:cover-decidability}

This section and the next one are dedicated to the proof of our main result:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for BNRA is decidable and $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

For the sake of clarity, in this section, we will first focus on the case of "signature BNRA". 
As a preliminary, we start by defining a notion of "local run" meant to represent the projection of a run onto a given agent.

\subsection{Local runs}
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$ and $\atrans =(q, \br{m}{i}, q')$ is a "broadcast".  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item if $\anact = \quotemarks{\dummyact}$ 
			then $\localdata(j) = \localdata'(j)$,
			\item if $\anact = \quotemarks{\enregact}$ then $\localdata'(j) = v$,
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item if $\anact = \quotemarks{\eqtestact}$ then $\localdata(j) = \localdata'(j)= v$,
			\item if $\anact = \quotemarks{\diseqtestact}$ then $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either a "reception step" or an "internal step". 
	\AP A ""local run"" $\localrun$ is a sequence of "local steps" denoted $(q_0, \nu_0) \step{*} (q, \nu)$. Its ""size@@localrun"" $\size{\localrun}$ is its number of steps. %where $\nu_0$ has distinct values.
	A value $\aval \in \nats$ appearing in $\localrun$ is ""initial"" if it appears in $\nu_0$ and ""non-initial"" otherwise. 
%	The ""input"" of $\localrun$, written $\intro*\Input{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages received in $\localrun$; its ""output"", written $\intro*\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages broadcast in $\localrun$. 
	% The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. 
	For $\aval \in \nats$, the $\aval$-""input"" $\intro*\vinput{\aval}{\localrun}$ (resp. $\aval$-""output"" $\intro*\voutput{\aval}{\localrun}$) is the sequence $m_0 \cdots m_{\ell} \in \messages^*$ of message types received (resp. broadcast) with value $\aval$ in $\localrun$.

\subsection{Unfolding Trees}
\label{sec:unfolding_tree_signature}

We first prove decidability of \COVER for "signature BNRA". Note that, in "signature protocols", the initial values of "reception-only" registers are not relevant as they can never be shared with other agents. We deduce from this idea the following informal observation:
\begin{observation}
\label{obs:sg_reception} 
In "signature BNRA", when some agent receives a message, it can compare the value of the message only with the ones of previously received messages, \emph{i.e.}, check whether the sender is the same.
\end{observation}

If we want to turn a "local run" $u$ of an agent $a$ into an actual "run", we must match $a$'s receptions with broadcasts. Because of Observation~\ref{obs:sg_reception}, what matters is not the actual values of the receptions in $u$ but which ones are equal to which.  Therefore, for a value $v$ received in $u$, if $m_1 \dots m_k \in \messages^*$ are the message types received in $u$ with value $v$ in this order, it means that to execute $u$, $a$ need another agent $a'$ to broadcast messages types $m_1$ to $m_k$, all with the same value.  
We describe what an agent needs from other agents as a set of ""specifications@@sg"" which are words of $\messages^*$. 
% A ""specification@@sg"" $m_1 \cdots m_k \in \messages^*$ is accomplished by an agent if it broadcasts message types $m_1, \dots, m_k$ in this order. 

To represent runs, we consider "unfolding trees@@signature" that abstract runs by representing such specifications, dependencies between them and how they are carried out. In this tree, each node is assigned a "local run" and the "specification@@sg" that it carries out. 
Because of copycat arguments, we will in fact be able to duplicate agents so that each agent only accomplishes one task, hence the tree structure.

\begin{definition}
\label{def:unfolding_tree_signature}
\AP An ""unfolding tree@@sg"" $\tree$ over $\prot$ is
a finite tree where nodes $\node$ have three labels:
\begin{itemize}
	\item a "local run" of $\prot$, written $\intro*\localrunlabel{\node}$;
	
	\item a value in $\nats$, written $\intro*\valuelabel{\node}$;
	
	\item a "specification" $\intro*\speclabel{\node} \in \messages^*$.
\end{itemize} 
Moreover, all nodes $\node$ in $\tree$ must satisfy the three following conditions:
\begin{enumerate}[label= (\roman*), ref=(\roman*)]
	\item \label{item:condition1_initial_value_sg} Initial values of $\localrunlabel{\node}$ are never received in $\localrunlabel{\node}$,
	\item \label{item:condition3_boss_node_sg} $\speclabel{\node} \subword \voutput{\valuelabel{\node}}{\localrunlabel{\node}}$, \emph{(recall that $\subword$ denotes the "subword" relation)}
	\item \label{item:condition2_non_initial_value_sg} For each value $\aval$ received in $\localrunlabel{\node}$, $\node$ has a child $\node'$ s.t. $\vinput{\aval}{\localrunlabel{\node}} \subword \speclabel{\node'}$.
\end{enumerate}

\AP Lastly, given $\tree$ an "unfolding tree@@sg", we define its ""size@@treesg"" by $\size{\tree} := \sum_{\node \in \tree} \size{\node}$ where $\size{\node} := \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@treesg" of $\tree$ takes into account the size of its nodes, so that a tree $\tree$ can be stored in space polynomial in $\size{\tree}$ (renaming the values appearing in $\tree$ if needed). 
\end{definition}
% subword explaination

We explain this definition. Condition \ref{item:condition1_initial_value_sg} enforces that the "local run" cannot cheat by receiving its "initial values". 
 Condition \ref{item:condition3_boss_node_sg} expresses that $\localrunlabel{\node}$ broadcasts (at least) the messages of $\speclabel{\node}$. We can use the subword relation $\subword$, and not equality, because of the lossiness: if some unecessary messages are broadcast, simply consider that they are not received.
Condition \ref{item:condition2_non_initial_value_sg} expresses that, for each value received, $\node$ has a child that broadcasts the right sequence of messages.

\begin{figure}[t]
	\centering
	\resizebox*{!}{3.5cm}{
	\input{Figures/fig-ex2}
	}
	\caption{Example of a "signature protocol".}\label{fig:ex2}\label{fig:example-signature-protocol}
\end{figure}
\begin{example}
\label{ex:protocol-signature}
	Figure~\ref{fig:example-signature-protocol} provides an example of a "signature protocol".
Let $\agents = \set{a_1, a_2,a_3}$. We denote a configuration $\config$ by $\tuple{\st{\config}(a_1),(\data{\config}(a_1)), \\ \st{\config}(a_2),(\data{\config}(a_2)), \st{\config}(a_3), (\data{\config}(a_3))}$. Irrelevant register values are denoted by $\_$. Let $\run$ be the run over $\agents$ of initial configuration  \\$\tuple{q_0, (1,\_,\_), q_0, (2,\_,\_), q_0, (3,\_,\_)}$ where the following occurs:
\begin{itemize}
\item $a_2$ broadcasts $\exready$, $a_1$ receives: $\tuple{q_1, (1,2,\_), q_0, (2,\_,\_), q_0, (3,\_,\_)}$,
\item $a_3$ broadcasts $\exready$, $a_1$ and $a_2$ receive: $\tuple{q_2, (1,2,3), q_5, (2,\_,\_), q_0, (3,\_,\_)}$,
\item $a_2$ broadcasts $\exready$, $a_3$ receives: $\tuple{q_2, (1,2,3), q_5, (2,\_,\_), q_5, (3,\_,\_)}$,
\item $a_2$ broadcasts $\exgotwo$, $a_1$ receives: $\tuple{q_3, (1,2,3), q_6, (2,\_,\_), q_5, (3,\_,\_)}$,
\item $a_3$ broadcasts $\exgothree$, $a_1$ receives: $\tuple{q_4, (1,2,3), q_6, (2,\_,\_), q_7, (3,\_,\_)}$.
\end{itemize}
	
Figure~\ref{fig:ex-unfolding-tree-signature} provides an unfolding tree derived from $\run$ by applying a procedure introduced later. Because agents $a_2$ and $a_3$ broadcast to several other agents, they each correspond to several nodes of the tree.  
% the following sequence is an initial run covering $q_4$:
	% \begin{align*}
	% 	&\tuple{(q_0, (\valsymb{1},2,3)), (q_0, (x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \tuple{(q_1, (x_1,x_2,z_1)), (q_5,(x_2,\_,\_)) , (q_0, (x_3,\_,\_))} \step{} \\ 
	% 	&\tuple{(q_2, (x_1,x_2,x_3)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \tuple{(q_3, (x_1,x_2,x_2)), (q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} \step{} \\
	% 	&\tuple{(q_4, (x_1,x_2,x_2)),(q_5,(x_2,\_,\_)), (q_5, (x_3,\_,\_))} 
	% \end{align*}
	% For readability's sake we don't write the second and third registers' values of agent $a_2$ and $a_3$ as there are neither broadcast, tested and nothing is store on those registers during the run.
	% First agent $a_2$ broadcasts message $hello$ with its second register's value, then $a_3$ broadcasts message $hey$ with its third register's value. Then, agent $a_2$ broadcasts message $ack$ with its second register's value and finally, agent $a_3$ broadcasts the same message but with its third register's value.
	% All messages are received by agent $a_1$ which hence reaches $q_4$.
	% We show now how to build the unfolding tree regarding the local run of agent $a_1$ in \cref{fig:unfolding-tree-sign}. Tables are (part of) "local runs", columns are (part of) "local configurations": we only display registers used in the local runs (the one broadcast or with a reception action on it). For $\node_2$, the transition between $q_0$ and $q_5$ should be understood as the broadcast of $hello$, whereas for $\node_3$ it should be understand as the broadcast of $hey$.
	% The local run of node $\node_1$ is the local run of agent $a_1$ of the run described above. 
	% By completing partial local runs by fresh integers in the other registers, one can verify that all nodes are labeled by local runs of the protocol (where the broadcast between $q_0$ and $q_5$ is with $hello$ for $\node_2$, and with $hey$ for $\node_3$).

	We explain why this tree is an "unfolding tree@@sg". Condition \ref{item:condition1_initial_value_sg} is trivially satisfied. 
	Condition \ref{item:condition3_boss_node_sg} holds at every node because the local run of each node exactly broadcasts the "specification@@sg" of the node. Condition  \ref{item:condition2_non_initial_value_sg} is satisfied at $\node_1$: $\vinput{2}{\localrunlabel{\node_1}}= \exready \cdot \exgotwo = \speclabel{\node_2}$ and $\vinput{3}{\localrunlabel{\node_1}}= \exready \cdot \exgothree = \speclabel{\node_3}$.
	It is also satisfied at $\node_2$, $\node_3$ and $\node_5$ because their local runs only receive $\exready$ and they each have a child with "specification@@sg" $\exready$. 
	It is trivially satisfied at $\node_4$ and $\node_6$ as their "local runs" have no reception. 
%	\corto{shorten?} \nico{plutôt non je dirais}
	% Values received in $\localrunlabel{\node_1}$ are $x_2$ and $x_3$, hence from condition \ref{item:condition2_non_initial_value_sg}, node $\node_1$ has two children $\node_2$ and $\node_3$. Note that $\vinput{x_2}{\localrunlabel{\node_2}} = \vinput{x_3}{\localrunlabel{\node_3}} = \epsilon$\lu{si on modifie la condition, on peut enlever cette phrase}. As $\spec(\node_1) = \epsilon$, condition \ref{item:condition3_boss_node_sg} is trivially true for $\node_1$. Note that nodes $\node_2$ and $\node_3$ don't receive any message on their respective local runs and so condition \ref{item:condition2_non_initial_value_sg} is trivially true. Furthermore, $\voutput{x_2}{\localrunlabel{\node_2}} = hello \cdot ack = \spec(\node_2)$ and $\voutput{x_3}{\localrunlabel{\node_3}} = hey \cdot ack = \spec(\node_3)$
\end{example}


\begin{figure}[t]
	\centering
	\input{Figures/tree-example-sign}
	\vspace{-0.5cm}
	\caption{Example of an unfolding tree derived from $\run$. Grids correspond to "local runs", a column of a grid is a "local configuration". Transition $\atrans_{ij}$ is the transition between state $q_i$ and state $q_j$, for example $\atrans_{01} = (q_0, \rec{\exready}{2}{\enregact}, q_1)$. If $\atrans$ is a reception of $m\in \messages$, $\extlabel{\atrans}{v}$ corresponds to receiving message $(m,v)$; if $\atrans$ is a broadcast of $m \in \messages$, $\intlabel{\atrans}$ corresponds to broadcasting of $(m,\mathsf{id})$ where $\mathsf{id}$ is the value in the first register of the agent. Initial values of "reception-only" registers are irrevelant and written as $\quotemarks{\_}$. Colors correspond to message types.}
	\label{fig:ex-unfolding-tree-signature}
\end{figure}
%	\todo{relire cette légende}
%We say that an "unfolding tree" $\tau$ ""covers@ut"" a state $q_f$ if the "local run" labeling its root goes through $q_f$. 

\begin{lemma}
\label{lem:coverability_witness_sg}
Given a "signature protocol" $\prot$ with a state $q_f$, $q_f$ is coverable in $\prot$ if and only if there exists an "unfolding tree@@sg" whose root is labelled by a "local run" covering $q_f$. We call such an "unfolding tree@@sg" a ""coverability witness@@sg"".
\end{lemma}
\begin{proof}
Given a "run" $\run$, agent $a$ \emph{satisfies a "specification@@sg"} $w \in \messages^*$ in $\run$ if the sequence of "message types" broadcast by $a$ admits $w$ as "subword".% if such an agent $a$ exists, we say that $\run$ satisfies "specification@@sg" $w$.   

% Suppose that we have such an "covrability witness@@sg" $\tree$. 
We prove the following property by strong induction on the depth of $\node$: for every $\node$ in $\tree$, there exists a "run" $\run$ with an agent $a$ satisfying the "specification@@sg" $\speclabel{\node}$ and whose "local run" in $\run$ is $\localrunlabel{\node}$. This is trivially true for leaves of $\tree$ because their "local runs" have no reception hence are actual "runs" by themselves. 
Let $\node$ a node of $\tree$, $\localrun := \localrunlabel{\node}$ and $\aval_1, \dots, \aval_c$ the values received in $\localrun$. 
These values are "non-initial" thanks to condition~\ref{item:condition1_initial_value_sg}; applying condition \ref{item:condition2_non_initial_value_sg} gives the existence of corresponding children $\node_1, \dots, \node_c$ in $\tree$. 
We apply the induction hypothesis on the subtrees rooted in $\node_1, \dots, \node_c$ to obtain "runs" $\run_1, \dots, \run_c$ satisfying the "specifications@@sg" of the children of $\node$. 
Up to renaming agents, we can assume the set of agents of these runs are disjoint; up to renaming values, we can assume that $\aval_j = \valuelabel{\node_j}$ for all $j$ and that all agents start with distinct values. 
We build an "initial run" $\run$ whose "agents" is the union of the "agents" of the $c$ runs along with a fresh agent $a$. In $\run$, we make $\run_1$ to $\run_c$ progress in parallel and make $a$ follow the "local run" $\localrun$, matching each reception with value $v_j$ in $\localrun$ with a broadcast in $\run_j$. 
This is possible because, for all $j$, $\vinput{v_j}{\localrun} \subword \speclabel{\node_j} \subword \voutput{v_j}{\run_j}$ (by \ref{item:condition3_boss_node_sg}). 

Conversely, we prove the following by induction on the length of $\run$: for every "initial run" $\run$, for every agent $a$ in $\run$ and for every $v \in \nats$, there exists an "unfolding tree" whose root has as "local run" the projection of $\run$ onto $a$ and as "specification@@sg" the $v$-"output" of $a$ in $\run$. If $\run$ is the empty run, consider the "unfolding tree" with a single node whose "local run" and "specification@@sg" are empty. Suppose now that $\run$ has non-zero length, let $a$ an agent in $\run$, $v \in \nats$ and let $\run_p$ the prefix run of $\run$ of length $\size{\run}-1$.
Let $\tree_1$ the "unfolding tree" obtained by applying the induction hypothesis to $\run_p$, $a$ and $v$, and consider $\tree_2$ obtained by simply appending the last step of $a$ in $\run$ to the "local run" at the root of $\tree_1$. If this last step is a broadcast, we obtain an "unfolding tree"; if the broadcast value is $v$, we append the broadcast "message type" to the "specification@@sg" at the root of $\tree_2$ and we are done. 
Suppose that, in the last step of $\run$, $a$ performs a reception $(q, \rec{m}{i}{\anact},q')$ of a message $(m,\aval')$. We might need to adapt $\tree_2$ to respect condition \ref{item:condition2_non_initial_value_sg} at the root. Let $a'$ the agent broadcasting in the last step of $\run$. Let $\tree_3$ the "unfolding tree@@sg" obtained by applying the induction to $\run_p$, $a'$ and $v'$. Let $\tree_4$ the "unfolding tree@@sg" obtained by appending the last broadcast to the "local run" at the root of $\tree_3$ and the corresponding "message type" to the "specification@@sg" at the root of $\tree_3$. Attaching $\tree_4$ below the root of $\tree_2$ gives an "unfolding tree@@sg" satisfying the desired properties. 
% Note that this construction may generate more children than needed at the root - maybe another child was already there to witness broadcasts of $a'$ in $\run_p$, in which case this child may be deleted. 
\end{proof}


	The "unfolding tree" $\tree$ of Figure~\ref{fig:ex-unfolding-tree-signature} is built from $\run$ of Example~\ref{ex:protocol-signature} using the previous procedure.
	 Observe that the "unfolding tree" $\tree$  is a "coverability witness@@sg" for $q_4$. However, one can find a smaller "coverability witness@@sg". 
	Indeed, in the right branch of $\tree$, $\node_5$ and $\node_6$ have the same "specification@@sg", therefore $\node_5$ can be deleted and replaced with $\node_6$. In fact, we would have also been able to shorten the tree if we only had $\speclabel{\node_5} \subword \speclabel{\node_6}$; we will use this argument to bound the size of the smallest "coverability witness@@sg".   

\subsubsection{Bounding the Size of the Unfolding Tree}
In all the following, we fix a positive instance $(\prot,q_f)$ of \COVER with $r+1$ registers (\emph{i.e.}, $r$ registers used for reception) and a  "coverability witness@@sg" $\tree$ of minimal size.
The following observation will be useful towards bounding the length of branches of a "coverability witness@@sg":

\begin{lemma}
\label{lem:no_subword_in_branch_sg}
If a "coverability witness@@sg" $\tau$ for $(\prot, q_f)$ of minimal size has two nodes $\node, \node'$ with $\node$ a strict ancestor of $\node'$ then  $\speclabel{\node}$ cannot be a subword of $\speclabel{\node'}$. 
\end{lemma}
\begin{proof}
Otherwise, replacing the subtree rooted in $\node$ with the one rooted in $\node'$ would contradict minimality of $\tree$.
\end{proof}

We would now like to use the "Length function theorem" to bound the height of $\tree$, using the previous lemma. To do so, we need a bound on the "size@@treesg" of a node with respect to its depth. The following lemma allows us to bound the "local run" of an agent between two local configurations: we argue that if the "local run" is long enough we can replace it with a shorter one that can be executed using the same input. This will in turn let us bound the "local run" of a node with respect to the "size@@sg" of its "specification@@sg", which is the first step towards our goal.

\begin{lemma}
\label{lem:towerbound_signature}
There exists a primitive recursive function $\towerfun$ such that, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ with $\size{u'} <~\towerfun(\size{\prot},r)$ and for all value $v' \in \nats$, there exists $v \in \nats$ such that  $\vinput{v'}{u'} \subword \vinput{v}{u}$. 
\end{lemma}
\begin{proof}
Let $\towerfun(n,0) = n+1$ and $\towerfun(n,k+1) = \towerfun(n,k) \cdot ({\size{\transitions}}^{2\towerfun(n,k)}+1)$ for all $k$. Observe that $\towerfun(n,k)$ is a tower of exponentials of height $k$, which is primitive-recursive although non-elementary. Register $i \geq 2$ is ""active@@sg"" in $u$ if $u$ has some $\quotemarks{\enregact}$ action on register $i$. Let $u$ a "local run", $k$ the number of "active@@sg" registers in $\localrun$, $n := \size{\prot}$ and $M := \towerfun(n,k)$.
We prove by induction on the number $k$ of "active@@sg" registers in $u$  that if $\size{u} >\towerfun(n,k)$ then $u$ can be shortened. 
 

If $k=0$, any state repetition can be removed. Suppose that $\size{u} > \towerfun(n,k+1)$ and that the set $I$ of "active@@sg" registers of $u$ is such that $\size{I} = k+1$. If there exists an infix run of $u$ of length $M$ with only $k$ "active@@sg" registers, we shorten $u$ using the induction hypothesis. Otherwise, every sequence of $M$ steps in $u$ has a $\quotemarks{\enregact}$ on every register of $I$. Because there are $\size{\transitions}^M$ such sequences and $\size{\localrun} > M \cdot (\size{\transitions}^{2M} +1)$, one sequence $s \in \transitions^{2M}$ appears twice (disjointly) in $\localrun$: in infix run $u_1$ first, then in infix run $u_2$. Furthermore an action $\quotemarks{\enregact}$ is performed on each register in each half of $s$. We shorten $u$ by removing all steps between $u_1$ and $u_2$ and merging $u_1$ and $u_2$ (see \cref{fig:proof-pumping-signed}). To merge them, for each $i \in I$, let $j$ the index of the first $\quotemarks{\enregact}$ on register $i$ in $s$; we replace in $u_1$, from step $j$ onwards, the values of all receptions involving $i$ by the corresponding value $v$ in $u_2$. 
 This guarantees that all equality and disequality tests still pass. However, it could be that, by letting $u'$ the obtained run, we do not have $\vinput{v}{u'} \subword \vinput{v}{u}$ because $v$ appears in $u_1$ on several registers: observe that in \cref{fig:proof-pumping-signed}, if $v_1 = v_2$ then the shortening operation may interleave the receptions of messages with that value in the two run segments, then we may not have $\vinput{v_1}{u'} \subword \vinput{v_2}{u}$. This is why we made sure every register was renewed \textbf{twice}. We replace all values appearing between the first and last $\quotemarks{\enregact}$ with distinct fresh values (hatched blocks in \cref{fig:proof-pumping-signed}). We then have $\vinput{v}{u'} \subword \vinput{v}{u}$ for every value that appeared in $u$ and for all fresh values $v'$ there is a $v$ such that $\vinput{v'}{u'} \subword \vinput{v}{u}$. Moreover, $u'$ is shorter than $u$; we conclude by iterating this shortening procedure.
\end{proof}

% \luin{if we have some place left, fig to explain proof of above lemma?}
%peu probable qu'on ait la place :(
\begin{figure}
	\resizebox*{!}{4.5cm}{
	\input{Figures/fig-illustration-signed-pumping-v2}
	}
	\caption{Illustration of the proof of \cref{lem:towerbound_signature}: $s \in \transitions^{M}$ corresponds to the repeating sequence of transitions of length $M$. We introduce fresh values so, in the shortened run, for all registers (except the first one), the value between the first and last $\quotemarks{\enregact}$ of $s$ never appears elsewhere in the local run: every hatched block corresponds to a never-seen-before value, in particular $v_2' \neq v_2$. 
%		For example, if $v_1 = v_2$, we transform the r
%		We make sure that we shorten the run so the new $\quotemarks{\enregact}$ actions are made on fresh values. If it was not the case on $u_2$ (here for example value $v$ is not fresh as it appeared before in the run), we introduce a new value never seen before (here value $v'$).
	}
	\label{fig:proof-pumping-signed}
\end{figure}



Using the previous lemma, we may bound the size of a node in $\tree$: we bound the "size@@localrun" of its "local run" with respect to the one of its "specification", and then bound its specification with respect to the size of its father, if it exists. Thanks to this lemma. we will be able to bound the size of a node with respect to its depth, by induction. We will then apply the "Length function theorem" to bound the height of the tree, and then its total size. 

\begin{lemma}
\label{lem:bounds_tree_sg}
For all nodes $\node, \node'$ in $\tree$: \begin{enumerate}
\item \label{item:bound_node_1_sg} $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot}, r)+1) \size{\speclabel{\node}}$,
\item \label{item:bound_node_2_sg} if $\node$ is the child of $\node'$, $\size{\speclabel{\node}} \leq (\towerfun(\size{\prot}, r)+1) \, \size{\speclabel{\node'}}$,
%\item \label{item:bound_node_3_sg} if $\node$ is the child of $\node'$, $\size{\node} \leq (\size{\node'}+1) \, (\towerfun(\size{\prot},r)+1)$.
\end{enumerate} 
\end{lemma}
\begin{proof}
For \ref{item:bound_node_1_sg}, if $\node$ is not the root, we identify in $\localrunlabel{\node}$ the broadcasts witnessing $\speclabel{\node}$ and shorten the "local run" between these steps using Lemma~\ref{lem:towerbound_signature}. We can also remove the suffix after the last of these broadcasts. The node $\node_r$ at the root of $\tree$ has empty "specification" by minimality of $\tree$ but must cover $q_f$ hence $\size{\localrunlabel{\node_r}} \leq \towerfun(\size{\prot},r)$ thanks to Lemma~\ref{lem:towerbound_signature}, proving \ref{item:bound_node_1_sg}.
For \ref{item:bound_node_2_sg}, we observe that, by minimality of $\tree$, $\size{\speclabel{\node}} \leq \max_{v \in \nats} \size{\vinput{v}{\localrunlabel{\node'}}} \leq \size{\localrunlabel{\node'}}$ and apply \ref{item:bound_node_1_sg}. 
%For \ref{item:bound_node_3_sg}, we use $\size{\node} = \size{\speclabel{\node}} + \size{\localrunlabel{\node}}$ and combine \ref{item:bound_node_1_sg} and \ref{item:bound_node_2_sg}.  
\end{proof}


\begin{proposition}
\label{prop:bounded_witness_sg}
There exists a function $h$ of class $\Ffunction{\omega^{\size{\messages}-1}}$ s.t. $\size{\tree} \leq h(\size{\prot})$. 
\end{proposition}
\begin{proof}
Let $n := \size{\prot}$, let $r+1$ be the number of registers in $\prot$. Thanks to Lemma~\ref{lem:no_subword_in_branch_sg}, for all $\node \ne \node'$ in 
$\tree$ with $\node$ ancestor of $\node'$, $\speclabel{\node}$ is not a subword of $\speclabel{\node'}$.  Let $\node_1, \dots, \node_m$ the node appearing in a branch of $\tree$, from root to leaf. The sequence $\speclabel{\node_1}, \dots, \speclabel{\node_m}$ is a "bad sequence".
For all $i \in \nset{1}{m}$, $\size{\speclabel{\node_{i+1}}}  \leq (\towerfun(n,r)+1) \, \size{\speclabel{\node_i}}$ by Lemma~\ref{lem:bounds_tree_sg}. By direct induction, $\size{\speclabel{\node_i}}$ is bounded by $g^{(i)}(n)$ where $g: n \mapsto (n+1)  \, \towerfun(n,n)$ is a primitive-recursive function. Let $h$ of class $\Ffunction{\omega^{\size{\messages}-1}}$ the function obtained when applying the "Length function theorem" on $g$ and $\messages$; we have $m \leq h(n)$. 

By immediate induction, thanks to the second item of Lemma~\ref{lem:bounds_tree_sg}, any node $\node$ at depth $d$ is such that $\size{\speclabel{\node_i}} \leq (\towerfun(n,r)+1)^{d+1}$, which, using the first item of Lemma~\ref{lem:bounds_tree_sg}, bounds the size of every node by $h'(n) = (\towerfun(n,n)+1)^{h(n) + 2}$. 
% (initialization thanks to Lemma~\ref{lem:towerbound_signature}). 
By minimality of $\tree$, the number of children of a node is bounded by the number of values appearing in its "local run" hence by $h'(n)$, so the total number of nodes in $\tree$ is bounded by $h'(n)^{h(n)+1}$ and the "size@@treesg" of $\tree$ by $f(n) := h'(n)^{h(n)+2}$. Because $\Ffunction{\omega^{\size{\messages}-1}}$ is closed by composition with primitive-recursive functions, $f$ is in $\Ffunction{\omega^{\size{\messages}-1}}$.
\end{proof}

The previous argument shows that \COVER for "signature protocols" is decidable and lies in complexity class $\Fcomplexity{\omega^\omega}$. Because the hardness from Proposition~\ref{prop:reduction-LCS} holds for "signature protocols", \COVER is in fact complete for this complexity class.

We now extend this method to the general case. 

%%%%%%%%%%%%%%%%%%%

\section{Coverability Decidability in the General Case}
\label{sec:cover-general-case}

\subsection{Generalizing Unfolding Trees}
\label{sec:unfolding-trees-general}
In the general case, a new phenomenon appears: an agent may broadcast a value that it did not have initially but that it received and stored. In particular, an agent starting with value $v$ could broadcast $v$ then require someone else to make a broadcast with value $v$ as well. For example, in the run described in \cref{ex:example-1}, $a_1$ receives message $(m_4, 1)$ to reach $q_4$; in this example, $1$ is initially a value of $a_1$ that $a_2$ receives and rebroadcasts to $a_1$.

 We now have two types of specifications. \emph{"Boss specifications"} describe the task of broadcasting with its own initial value; this is the "specification@@sg" we had in "signature protocols" and, as before, it consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. \emph{"Follower specifications"} describe the task of broadcasting with a non-initial value received previously. More precisely, a "follower specification" is a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$ asking to broadcast a message $(\followmessagespec,v)$ under the condition of previously receiving the sequence of "message types" $\followwordspec$ with value $v$.

% As before, a "boss specification" consists of a word $\bossspec \in \messages^\ast$ describing a sequence of "message types" that should be all broadcast with the same value. A "follower specification" consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that one must be able to broadcast $\followmessagespec$ with value $v$ after receiving the sequence $\followwordspec$ with value $v$. 

A key idea for this proof is that if an agent that had $v$ initially receives some message $(m,v)$, then intuitively we can isolate a subset of agents that did not have $v$ initially but that are able to broadcast $(m,v)$ after receiving a sequence of messages with that value. We can then copy them many times in the spirit of the "copycat principle". Each copy receives the necessary sequence of messages in parallel, and they then provide us with an unbounded supply of messages $(m,v)$. In short, if an agent (or set of agents) is able to broadcast $(m,v)$ while not having $v$ as an "initial value", then we can consider that we have an unlimited supply of messages $(m,v)$.

\begin{example}

\label{ex:decomposition}
Assume that we have three agents $a_1,a_2$ and $a_3$ and let $v$ a value initially in $a_1$. Consider an execution where the following happens with value $v$: $a_1$ broadcasts $\textsf{a} \cdot \textsf{b}$, then $a_2$ broadcasts $\textsf{c}$, then $a_1$ broadcasts $\textsf{a}^3$ then $a_3$ broadcasts $\textsf{b}$. The "follower specification" corresponding to $a_2$'s task is of the form $(w, \textsf{c})$ where $w \subword \textsf{a} \cdot \textsf{b}$: $a_2$ must broadcast $(c,v)$, after receiving a subword of $\textsf{a} \cdot \textsf{b}$ with that value. By contrast, $a_3$'s "follower specification" may be of the form $(w \cdot w', \textsf{c})$ where $w \subword \textsf{a} \cdot \textsf{b}$ and $w' \in \set{\textsf{a},\textsf{c}}^*$ is a subword of $\textsf{a}^3$ enriched with as many $\textsf{c}$ as desired, because $a_2$ may be cloned at will (we may add many fresh agents which mimic $a_2$'s execution, receiving the same messages, meaning that we can obtain as many broadcasts $\textsf{c}$ with $v$ as $a_3$ needs).
%(we may mimic $a_2$'s execution with disjoints set of agents until the first reception on $v$ $a_2$ performs, all new agents then perform the same reception and go on with their execution on a similar fashion until broadcasting $\textsf{c}$). 
For example, one could have $w= \textsf{b} $ and $w' = \textsf{c} \cdot \textsf{a} \cdot \textsf{c}^4 \cdot \textsf{a} \cdot \textsf{c}^2$. This idea is formalized in the appendix with the notion of "decomposition"; in this case, the previous condition becomes: $w \cdot w'$ \emph{"admits decomposition"} $(\textsf{a} \cdot \textsf{b}, \textsf{c}, \textsf{a}^3)$.   
\end{example}
% Therefore, if one later needs an agent to broadcast $(m',v)$ then this agent is allowed  hence from a finite set of message types which can be sent with value $v$, there is an infinite set of possible $\followwordspec$ to chose: if a message $(m, v)$ is sent from the agent with initial value $v$ then the "copycat principle" does not apply, however, if $(m, v)$ is sent from an agent without $v$ as initial value, message type $m$ can appear as many times as one wants in $\followwordspec$ once it has been sent once. 
%For instance, in the protocol described in \cref{fig:ex1}, message ($m_6, )

In our new "unfolding trees", a node is either a "boss node" or a "follower node", depending on its type of specification. 
A "follower node" $\node$ with "follower specification" $(\followwordspec, \followmessagespec)$ is allowed to receive sequence of messages $\followwordspec$ with value $\valuelabel{\node}$ (which must be "non-initial") without it being broadcast by its children. 
Other conditions are similar to the ones for "signature protocols": if $\node$ is a node and $v \ne \valuelabel{\node}$ a "non-initial" value received in its "local run", $\node$ must have a "boss" child broadcasting this word. Moreover, for each $(m,v)$ received where $v$ is an "initial value" of the "local run", $\node$ must have a "follower" child that is able to broadcast the message after receiving previous messages with value $v$; the formal statement is more technical because it takes into account the observation of Example~\ref{ex:decomposition}. 
The formal definition of "unfolding tree" is given in \cref{app:def-trees}.


\begin{example}
	Figure~\ref{fig:ex-unfolding-tree} depicts the unfolding tree associated to $a_1$ in the execution of \cref{ex:example-1}. 
	Observe that the "follower node" $\node_3$ has a $m_2$ reception that is not matched by its children; this is possible because $m_2$ is in $\followwordspec(\node_3)$ and the "local run" at $\node_1$ broadcasts $(m_2,1)$ before receiving $(m_6,1)$.  
\end{example}
\begin{figure}[t]
	\begin{center}
			% \resizebox{\textwidth}{!}{
					\input{Figures/tree-example1}
				% }
		\end{center}
	\vspace*{-0.5cm}
	\caption{Example of an "unfolding tree". $\delta_{ri}$ (resp. $\delta_{bi}$) denotes the reception (resp. broadcast) transition of message $m_i$ in the protocol described in \cref{fig:ex1}. Initial values which are never broadcast are omitted and written as $\quotemarks{\_}$.}\label{fig:ex-unfolding-tree}
%	\vspace*{-0.5cm}
\end{figure}

A ""coverability witness"" is again an "unfolding tree" whose root covers $q_f$, with the extra condition that the root is a "boss node" (a "follower node" implicitely relies on its parent's ability to broadcast). 

\begin{restatable}{proposition}{treessoundcomplete}
	\label{prop:trees-sound-complete}
	An instance of \COVER $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}
\begin{proof}[Proof sketch]
	The proof is quite similar to the one of Lemma~\ref{lem:coverability_witness_sg}, but is made more technical by the addition of "follower" nodes. 
	When translating an "unfolding tree" to a "run", if the root of the tree is a "follower node" $\node$ of specification $(\followwordspec, \followmessagespec)$, then we actually obtain a "partial run", \emph{i.e.}, a "run" except that the receptions from $\followwordspec$ are not matched by broadcasts in the "run". We then need to interleave the runs of the parent of $\node$ with (several copies of) its follower children, as detailed in Lemma~\ref{lem:tree-to-run-technical}.
	For the translation from "run" to tree, we inductively construct the tree by extracting from the run the agents and values responsible for satisfying the specifications of each node and analysing the messages they receive to determine their set of children (as in Example~\ref{ex:decomposition}). See Appendix~\ref{app:trees-sound-complete} for the proof.
%	\corto{A relire} 
	% % The translation from "run" to tree works by induction on the length of the "run". We first define in a natural way what it means for a "run" to satisfy a "specification". We consider a "run" $\run$ and isolate a well-chosen agent $a$, whose "local run" witnesses that the "specification" is satisfied. We call the induction hypothesis with the "specifications" expressing what $a$ needs to receive from other agents. Each such "specification" is satisfied by a strict prefix of $\run$ (the only exception being if $a$ satisfies a "boss specification" with value $v$ and the last step of $\run$ is a broadcast with $v$ by another agent; in this case, we use the induction hypothesis on $\run$ but with a follower specification, hence the induction is well-founded).
	% We construct an "unfolding tree" by labeling the root with the "specification" and the "local run" of $a$, and attaching below it the subtrees obtained by induction hypothesis.
	% The translation from tree to "run" consists in an induction on the tree. A key concept is the one of "partial run", which extends the notion of "local run" to a subset of agents: in a "partial run", some receptions called \emph{external} are not matched by a broadcast. This is meant to represent the behavior of a subtree of the "unfolding tree": if the root of an "unfolding tree" is a "follower node" with "specification" $(\followwordspec, \followmessagespec)$ then the corresponding "partial run" receives an external sequence $\followwordspec$. The inductive step applies the induction hypothesis to the children of the "root" to obtain partial runs and merges them with the "local run" of the root by branching broadcasts to the right external receptions. 
	% 
\end{proof}





\subsubsection{Bounding the Size of the Unfolding Tree.}
\label{sec:tree-bounds}

Our aim is again to bound the "size@@tree" of a minimal "coverability witness". In the following, we fix an instance $(\prot,q_f)$ with $r$ registers and a "coverability witness" of minimal size. We start by providing new conditions under which a branch can be shortened; for "boss specifications", it is the condition of Lemma~\ref{lem:no_subword_in_branch_sg} but for "follower specifications", the subword relation goes the opposite direction because the shorter the requirement $\followwordspec$, the better.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\node \ne \node'$ be two nodes of $\tree$ such that $\node$ is an ancestor of $\node'$. If one of those conditions holds, then $\tree$ can be shortened  (contradicting its minimality):
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; 
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$.
	\end{itemize} 
\end{restatable}

We can generalize \cref{lem:towerbound_signature} to bound the size of a node by the number of messages that it must broadcast times a primitive-recursive function $\towerfun(\size{\prot},r)$. The proof is more technical than the one of \cref{lem:towerbound_signature} but the idea is essentially the same. The formal statement and the proof can be found in Appendix~\ref{app:tower-lemma} (\cref{lem:short-local-runs}). 
One can therefore bound the size of a node with respect to the size of the nodes that it must broadcast to.

It is however much harder to bound the size of the "coverability witness" in the general case than it was in the "signature" case. Indeed, the broadcasts no longer go only from children to parents in the "unfolding tree". If $\node$ is the parent of $\node'$, then $\node'$ broadcasts to $\node$ if $\node'$ is a "boss node", but $\node$ broadcasts to $\node'$ if $\node'$ is a "follower node", in which case $\node'$ only broadcasts one message to $\node$. Therefore, we cannot in general bound $\size{\node}$ with respect to $\size{\node'}$ nor $\size{\node'}$ with respect to $\size{\node}$, making us unable to apply the "Length function theorem" immediately. 

This leads us to arrange the "unfolding tree" so that long broadcast sequences are sent upwards, using the notion of "altitude" depicted in Figure~\ref{fig:rearrange-tree}, formally defined as follows:

The ""altitude"" of the root is $0$, the altitude of a "boss node" is the altitude of its parent minus one, and the altitude of a "follower node" is the altitude of its parent plus one.
We denote the "altitude" of $\node$ by $\altitude{\node}$.
This way the nodes of maximal "altitude" are the ones that do not need to send long sequences of messages. We will bound the size of nodes with respect to their "altitude", from the highest to the lowest, and then use the "Length function theorem" to bound the maximal and minimal "altitudes".


% note that this time the bound is on the exact number of registers (and not the number of registers minus one). We shall refer to this lemma as the Tower Function Lemma as it bounds "local runs" length by a function $\psi(n,k)$ which is in fact a tower of exponentials of height $k$ where each floor is a polynomial in $n$.

% Previously, \cref{lem:no_subword_in_branch_sg,lem:towerbound_signature} lead us to the "Length function theorem". We were able to bound the size of a node with respect to the nodes to which it must send long words of messages (in the signature protocol: from leaves to root), i.e. we could find a bound for a node $\node$ with respect to its parent's size. From what we argued above, we can not do so in the general case.
%However, this is not possible for "follower nodes", as it goes in the opposite direction: a node now might need to send long sequence of messages to its "follower node" child, in order for this node to repeat a value. 
% We will thus rearrange the tree in a convenient manner. 

% A new version of \cref{lem:no_subword_in_branch_sg} can be found below: \cref{lem:shortening-branches} provides two ways of shortening an "unfolding tree", its proof can be found in Appendix~\ref{app:proofs-reduction-branches}. 
%and \cref{lem:short-local-runs}~is the direct general case version of \cref{lem:towerbound_signature}.






%\cref{lem:no_subword_in_branch_sg} is then replaced by the following lemma, which 





%We now show that there is a computable bound on the "size@@tree" of the "unfolding tree" achieving a given specification and labeled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem"; however, this theorem requires a bound on the lengths of the words. In fact, there is no reason to think that the lengths of the labels of the children of a node can be bounded with respect to the length of the label of that node. 
%
%
%In order to bound the size of the nodes, we now wish to adapt \cref{lem:towerbound_signature}~to the general case.
%We use the following result, which essentially states that if there is a "local run" between two local configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function and which does not require larger inputs than the previous one.

%\begin{restatable}{lemma}{lemShortLocalRuns}
%	\label{lem:short-local-runs}
%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "protocol" with $r$ registers, for every local run $\localrun: (q,\localdata) \step{*} (q', \localdata')$, there exists $u' : (q,\localdata) \step{*} (q',\localdata')$ such that $\size{u'} < \towerfun(\size{\prot},r)$ and for all value $v \in \nats$,  $\vinput{v}{u'} \subword \vinput{v}{u}$. 
%%	\\
%%	
%%	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers, for every "local run" $\localrun_0: (q_0, \localdata_0) \step{*} (q_f, \localdata_f)$ in $\prot$, for every section $\localrun : (q, \localdata) \step{*} (q, \localdata')$ of $\localrun_0$,  for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun''} \leq \towerfun(\size{\prot},r)$ and:
%%	\begin{enumerate}
%%		\item for all $\aval' \in \nats \setminus V$, there exists $\aval$ a "non-initial" value of $\localrun_0$ such that $\vinput{\aval'}{\localrun'}\subword \vinput{\aval}{\localrun}$,
%%		\item for all $\aval \in V$, $\vinput{\aval}{\localrun'} \subword \vinput{\aval}{\localrun}$. 
%%	\end{enumerate}
%\end{restatable}
%
%\begin{proof}[Proof sketch]
%	
%	
%	The proof follows the same reasoning as the proof of \cref{lem:towerbound_signature}, but this time all registers should be taken into consideration.
%	\luin{pour le moment j'ai juste déplacé l'ancien énoncé en annexe, vérifier si on peut adapter le lemme tower "signé" et sa preuve plus simplement}
%	
%%	First, as for \cref{lem:towerbound_signature}, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the "run" using an induction on the number of registers. We then manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the "local run" we may add some fresh values to it (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are less constraining than the ones that were in the original "run". For technical reasons, we want to prevent fresh values added in the proof from mimicking "initial" values of the agent.\lu{je crois que c'est pour les local disequality tests qui ne sont plus là désormais, à enlever?}
%%	See Appendix~\ref{app:tower-lemma} for the full proof.
%	
%	

% Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\begin{remark}\lu{déplacer si manque de place ?}
%	The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight: one may need a "local run" of length a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
%\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \end{remark}
%\begin{definition}
%	Let $\tree$ an "unfolding tree". We define the ""altitude"" of a node $\node$ of $\tree$, written $\altitude{\node}$, recursively as follows:
%	\begin{itemize}
%		\item The altitude of the root is $0$,
%		\item The altitude of a "boss node" is the altitude of its parent minus one,
%		\item The altitude of a "follower node" is the altitude of its parent plus one.
%	\end{itemize}
%\end{definition}

\begin{figure}[t]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of a tree. The root is in red, black solid arrows connect parents to children, blue dashed arrows highlight that long words of messages are sent upwards.}
	\label{fig:rearrange-tree}
\end{figure}

We bound the size of a node with respect to the size of its neighbors of higher altitude. The idea is similar to the one for Lemma~\ref{lem:bounds_tree_sg}, the size of the neighbors bounds the number of messages that this node needs to send, and then we can apply Lemma~\ref{lem:short-local-runs} (which generalizes Lemma~\ref{lem:towerbound_signature}) to bound the local run of the node.
The proof of this lemma can be found in Appendix~\ref{app:proofs_bounds}.

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\node$ be a node of $\tree$ such that all neighbors of $\node$ of higher altitude have size bounded by $K$.
	Then $\size{\node} \leq (\towerfun(\size{\prot}, r)+2) \, (\size{\messages} \, r \, K + K)$, with $\psi$ the primitive-recursive function defined in Lemma~\ref{lem:short-local-runs}. 
\end{restatable}

The rest of the proof is sketched here and detailed in Appendix~\ref{app:proofs_bounds}. 
By inductively applying the previous result, we obtain the existence of a primitive-recursive function $f_0$ (depending only on $\size{\prot}$ and not on $\tree$) such that, given a node $\node$ in $\tree$, $\size{\node} \leq f_0(\altmax - \altitude{\node})$ where $\altmax$ denotes the maximal altitude in $\tree$ (Lemma~\ref{lem:bound-length-at-height-h}).

We now bound $\altmax$. Consider a branch of $\tree$ with a node at "altitude" $\altmax$; we follow this branch from the root and, for every $j \in \nset{1}{\altmax}$, set $\node_{j}$ as the first node of the branch at altitude $j$ (Figure~\ref{fig:max-height-bound} in the appendix); all such nodes are necessarily "follower nodes" as they are above their parent. Sequence $\node_{\altmax}, \dots, \node_2, \node_1$ is so that the $i$th term is at altitude $\altmax-i$ hence its size is bounded by $f_0(i)$. With the observation of Lemma~\ref{lem:shortening-branches}, we apply the "Length function theorem" to bound $\altmax$ (Lemma~\ref{lem:bound-max-height} in the appendix).

This yields in turn a bound on the size of the root of $\tree$ as its altitude ($0$) has a bounded difference with the maximal one. Another application of the "Length function theorem", this time with "boss nodes", allows us to bound the minimal altitude of a node of this tree (Lemma~\ref{lem:bound-min-height}).
	
Once we have bounded both the maximal and minimal altitudes, we can infer a bound on the size of all nodes using Lemma~\ref{lem:bound-length-at-height-h}, and then on the length of branches: by minimality, a branch cannot have two nodes with the same specification. 
The bound on the "size@@tree" of the tree then follows from the observation that bounding the size of nodes of $\tree$ also allows to bound their number of children.
 

% \begin{restatable}{proposition}{PropBoundTreeSize}
% 	\label{prop:bound-tree-size}
% 	There exists a function $f$ of class $\Ffunction{\omega^{\size{\messages}+1}}$ s.t. $\size{\tree} \leq f(\size{\prot})$.
% \end{restatable}

%\subsubsection{Decidability}
%\label{sec:decidability-end}

We obtain a computable bound (of the class $\Ffunction{\omega^\omega}$) on the "size@@tree" of a minimal "coverability witness", if it exists. 
Our decidability procedure computes that bound, enumerates all trees of "size@@tree" below the bound and checks for each of them whether it is "coverability witness". Details can be found in Appendix~\ref{app:proofs_bounds} and Appendix~\ref{app:decidable_cover}.

\decidablecover*


