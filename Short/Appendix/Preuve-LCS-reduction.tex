\section{Proof of Proposition~\ref{prop:reduction-LCS}}
\label{app:reduction-lcs}

\propReductionLCS*
\nico{j'ai fait un passage pour réduire, n'hésitez pas à remettre un coup. Eventuellement on peut aussi faire une figure et dire ``ca se voit que ça marche''}
\begin{proof}
	It is sufficient to prove that it is as hard as reachability for lossy channel systems with a single channel, which corresponds to a single finite-state machine that has the ability to buffer symbols in a lossy FIFO queue \cite{Schnoebelen2002verifying}. We present here a polynomial-time reduction.
	Let $\los := (\lstates,\Sigma, \ltransitions, \lstate_0)$ be a "lossy channel system", where $\lstates$ is a finite set of locations, $\Sigma$ is a finite alphabet, $\lstate_0$ is an initial state and $\ltransitions \subseteq \lstates \times \Sigma^* \times \set{!, ?} \times \lstates$; $\quotemarks{!}$ corresponds to a "push" (writing at the end of the channel) and $\quotemarks{?}$ to a "pop" (reading at the beginning the channel). A configuration of $\los$ is a pair in $\lstates \times \Sigma^*$ denoting the location and the content of the channel. There exists a step from $(\lstate,w)$ to $(\lstate',w')$ using transition $\ltrans \in \ltransitions$, denoted $(\lstate,w) \lstep{\ltrans} (\lstate',w')$, when
	\begin{itemize}
		\item $\ltrans = (\lstate,u,!,\lstate')$ for some $u \in \Sigma^*$ and $w' \subword w \cdot u$ (a ""push""),
		\item $\ltrans = (\lstate,u,?,\lstate')$ for some $u \in \Sigma^*$ and $u \cdot w' \subword w$ (a ""pop"")
	\end{itemize}
	where $\subword$ denotes the "subword" order, which encodes the lossiness of the channel: letters in the channel may get lost. 
	
	The existence of such a transition is denoted $(\lstate,w) \lstep{} (\lstate',w')$, and its transitive closure is denoted $\lstep{*}$. The (control-state) ""reachability problem@@lcs"" asks, given $\los$ and two locations $\lstate_s, \lstate_f \in \lstates$, whether $(\lstate_s,\epsilon) \lstep{*} (\lstate_f, w)$ for some $w$. 
	
	We construct a "signature protocol" $\prot$ with two registers and a state $q_f$ that may be covered if and only if $(\los, q_i, q_f)$ is a positive instance of the "reachability problem@@lcs". In $\prot$, agents will organize in chains where each agent encodes a step of the execution in the "lossy channel system". An agent $a$ stores the identifier of the previous agent in the chain then tests for equality so that messages from other agents are ignored. The predecessor will send a location of the system and (a subword of) the content of the channel. $a$ will in turn broadcast to the next agent in the chain, sending the new location of the system and the new content of the channel which $a$ rebroadcasts on-the-fly letter by letter as it receives it. $a$ only modifies a bit the beginning of the channel if it decides to encode a "pop" and the end of the channel if it decides to encode a "push". Messages might get lost, which is why we are able to encode "lossy channel systems" but not non-lossy ones.
	
	\AP From the initial state $q_0$ of $\prot$, agents non-deterministically decide whether they are ""root"" (at the beginning of their chain) or ""link"". A "root" agent directly broadcasts its identifiers and the initial configuration $(\lstate_0,\epsilon)$, with sequence of transitions $\br{\mathsf{init}}{1}, \br{\mathsf{q_0}}{1}, \br{\mathsf{\#}}{1}$ which gets to $\finstate{\lstate_0} \in Q$. The symbol $\mathsf{\#} \in \Sigma$ is the final symbol meaning that the channel was fully broadcast. 
	
	A "link" agent first receives a broadcast with an identifier which it stores as the one of its predecessor, then broadcasts its own identifier. This construction guarantees that "link" agents have exactly one predecessor. It does not guarantee, however, than all agents are in the same chain or that any agent is the predecessor of at most one agent. Concretely, there is a sequence of two transitions from $q_0$ labeled by $\rec{\mathsf{init}}{2}{\enregact}, \br{\mathsf{init}}{1}$ that gets to $\waitstate \in Q$. 
	From $\waitstate$, there is, for every $\lstate \in \lstates$, a transition labeled by $\rec{\mathsf{\lstate}}{2}{\eqtestact}$ that goes to state $\startstate{\lstate} \in Q$. 
	For every transition $\ltrans = (\lstate, \op, \lstate') \in \ltransitions$ in $\los$ (\emph{i.e.}, every transition of $\ltransitions$ whose source is location $\lstate$), there is a transition in $\prot$ labeled by $\br{\mathsf{\lstate'}}{1}$ that goes from $\startstate{\lstate}$ to $\transstateone{\ltrans} \in Q$. 
	Transitions from $\transstateone{\ltrans}$ in $\prot$ depend on $\ltrans$. For a "pop" transition $(\lstate, u, ?, \lstate')$, the agent first must receive $u$ then the channel which it rebroadcasts, whereas for a "push" transition $\ltrans= (\lstate, u,!, \lstate')$, it first receives and rebroadcasts the channel then also broadcasts $u$. Either way, it goes to $\finstate{\lstate'}$ which is a deadlock. 
	% Formally:
	% \begin{itemize}
	% 	\item If $\ltrans=(\lstate, u,?, \lstate')$ is a "pop" then $\prot$ has a sequence of transitions from $\transstateone{\ltrans}$ to $\transstatetwo{\ltrans} \in Q$ labeled by $\rec{\mathsf{u_1}}{2}{\eqtestact}, \rec{\mathsf{u_2}}{2}{\eqtestact}, \dots, \rec{\mathsf{u_k}}{2}{\eqtestact}$ where $u = u_1 u_2 \cdots u_k$. Moreover, there is, for every $x \in \Sigma$, a loop on $\transstatetwo{\ltrans}$ labeled with the sequence of actions $\rec{\mathsf{x}}{2}{\eqtestact}, \br{\mathsf{x}}{1}$. There is also a sequence of  transitions from $\transstatetwo{\ltrans}$ to $\finstate{\lstate'}$ labeled by $\rec{\mathsf{\#}}{2}{\eqtestact}, \br{\mathsf{\#}}{1}$.
	% 	\item If $\ltrans= (\lstate, u,!, \lstate')$ is a "push" then there is, for every $x \in \Sigma$, a loop on $\transstateone{\ltrans}$ labeled with sequence of actions $\rec{\mathsf{x}}{2}{\eqtestact}, \br{\mathsf{x}}{1}$. There also is a sequence of transitions from $\transstateone{\ltrans}$ to $\transstatetwo{\ltrans}$ labeled by $\br{\mathsf{u_1}}{1}, \br{\mathsf{u_2}}{1}, \dots, \br{\mathsf{u_k}}{1}$ where $u = u_1 \cdot u_2 \cdots u_k$. From $\transstatetwo{\ltrans}$, there is  a sequence of transitions going to $\finstate{\lstate'}$ labeled by $\rec{\mathsf{\#}}{2}{\eqtestact}, \br{\mathsf{\#}}{1}$.
	% \end{itemize}
	Finally, the objective state of our system is $q_f := \finstate{\lstate_f}$.
	
	We claim that $(\prot, q_f)$ is a positive instance of \COVER if and only if $(\los, \lstate_f)$ is a positive instance of the reachability problem for "lossy channel systems".
	First, suppose that there exists $w \in \Sigma^*$ such that $(\lstate_0, \epsilon) \lstep{*} (\lstate_f, w)$. Decompose the witness into $(\lstate_0, w_0) \lstep{} (\lstate_1, w_1) \lstep{} (\lstate_2, w_2) \cdots \lstep{} (\lstate_n,w_n)$ with $\lstate_n = \lstate_f$ and $w_n =w$. 
	We build an "initial run" of $\prot$ that "covers" $q_f$. It has set of agents $\agents := \set{0,\dots, n}$. Agent $0$ becomes the "root" and for all $i \geq 1$, agent $i$ becomes a "link" with predecessor agent $i-1$. By induction on $i$, we build an execution using agents $0$ to $i$ such that agent $i$ ends on state $\finstate{\ltrans_i}$ and the sequence of "message types" sent by agent $i$ admits as subword $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_i \cdot \mathsf{\#}$. For $i=0$, this condition is met as agent $0$ becomes "root". When the construction has been done up until agent $i$, we make agent $i+1$ do the following. It receives from agent $i$ state $l_i$ and goes to $\startstate{l_i}$. It then moves to $\transstateone{\ltrans}$ where $\ltrans = (\lstate_i, \op, \lstate_{i+1})$ is the transition of step $(\lstate_i, w_i) \lstep{} (\lstate_{i+1}, w_{i+1})$. Doing so, it broadcasts $\mathsf{\lstate_{i+1}}$. It then follows the branch corresponding to $\ltrans$. 
	\begin{itemize}
		\item if $\ltrans =(\lstate_i, u,!, \lstate_{i+1})$ is a "push" then $w_{i+1} \subword w_i \cdot u$; write $w_{i+1} = w_{i}' \cdot u'$ where $w_i' \subword w_i$ and $u' \subword u$. 
		% Agent $i+1$ receives $w_i'$ in full and rebroadcasts it while looping on $\transstateone{\ltrans}$. It then broadcasts $u$ to get to $\transstatetwo{\ltrans}$. It finally receives $\mathsf{\#}$ from agent $i$ and rebroadcasts it, going to state $\finstate{\lstate_{i+1}}$. 
		The word broadcast by agent $i+1$ is $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w'_i \cdot u \cdot \mathsf{\#}$ which admits as subword $\mathsf{init} \cdot \mathsf{\lstate_{i+1}} \cdot w_{i+1} \cdot \mathsf{\#}$.
		\item if $\ltrans =(\lstate_i, u,?, \lstate_{i+1})$ is a "pop" then $u \cdot w_{i+1} \subword w_i$; write $w_{i} = u' \cdot w_{i+1}'$ where $w_{i+1} \subword w_{i+1}'$ and $u \subword u'$. 
		% Overall, agent $i+1$ receives from agent $i$ a sequence of "message types" $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot u \cdot w_{i+1}' \cdot \mathsf{\#}$ (some messages may get lost). 
		% From $\transstateone{\ltrans}$, agent $i+1$ receives $u$ and goes to $\transstatetwo{\ltrans}$. It then receives $w_{i+1}'$ in full and rebroadcasts it while looping on $\transstatetwo{\ltrans}$. It finally received $\mathsf{\#}$ from agent $i$ and rebroadcasts it, going to state $\finstate{\lstate_{i+1}}$.
		Agent $i+1$ first receives $u'$ which admits as subword $u$ hence it passes the "pop" part. Its word broadcast is then $\mathsf{init} \cdot \mathsf{\lstate_{i+1}} \cdot w_{i+1}'  \cdot \mathsf{\#}$ which admits as subword $\mathsf{init} \cdot \mathsf{\lstate_{i+1}} \cdot w_{i+1} \cdot \mathsf{\#}$.
	\end{itemize}
	This concludes the induction step.
	When applied to $i=n$, this builds an "initial run" where agent $n$ ends on $\finstate{\lstate_n}$, which is a witness that $(\prot, q_f)$ is positive.
	
	Suppose now that $(\prot, q_f)$ is positive. Let $\run: \config_0 \step{*} \config_f$ where $\config_f$ covers $q_f$. Agents in $\run$ are arranged in chains where a given chain starts with a "root" then has "link" agents each storing the value of their predecessor in the chain (some agents may be in no chain but these agents can be ignored). All chains are finite because $\agents$ is finite; morever, there can be no cycle because a "link" agent first store its predecessor's value then broadcast its own. Consider in $\run$ a chain of agents $a_0, \dots, a_n$ such that $a_0$ is the "root" and $a_n$ covers $q_f$. 
	
	From the "run" $\run$ projected on this chain, it is quite simple to build an execution of $\los$ that covers $q_f$. By structure of the protocol, because $a_n$ covers $q_f$, every agent $a_i$ ends on some $\finstate{\lstate_i}$ and broadcasts a word of the form $\mathsf{init} \cdot \lstate_i \cdot w_i \cdot \mathsf{\#}$; this can be proven with an immediate backwards induction. It then suffices to analyse the behavior of $a_{i+1}$ to prove that $(\lstate_i, w_i) \lstep{} (\lstate_{i+1}, w_{i+1})$. In particular, because $a_0$ is a "root", $\lstate_0 = \lstate_s$ and $w_0 = \epsilon$, which concludes the proof. 
\end{proof}

% By structure of the "protocol", in order to broadcast a sequence $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_i \cdot \mathsf{\#}$, an agent needs to receive a sequence $\mathsf{init} \cdot \mathsf{\lstate_{i}}' \cdot w'_i \cdot \mathsf{\#}$ from its predecessor with $(\lstate'_i, w'_i) \lstep{} (\lstate_i, w_i)$. Hence its predecessor needs to broadcast $\mathsf{init} \cdot \mathsf{\lstate_{i-1}} \cdot w_{i-1} \cdot \mathsf{\#}$ with $\mathsf{\lstate_{i-1}} = \mathsf{\lstate_{i}}'$ and $w_{i-1} \subword w_i'$, thus $(\lstate_{i-1}, w_{i-1}) \lstep{} (\lstate_i, w_i)$.
% Because $a_n$ covers $\finstate{\lstate_f}$, it must receive a sequence of the form $\mathsf{init} \cdot \mathsf{\lstate_f} \cdot w_n \cdot \mathsf{\#}$, hence by induction we obtain a sequence of configurations $(\lstate_0, w_0) \lstep{} (\lstate_1, w_1) \lstep{} (\lstate_2, w_2) \cdots \lstep{} (\lstate_n,w_n)$ with $\lstate_n = \lstate_f$ and $w_0 = \epsilon$ (as $a_0$ broadcasts $init \lstate_0 \mathsf{\#}$). 
% We have proven that $(\lstate_0, \epsilon) \lstep{*} (\lstate_f, w_n)$ and the instance of $\los$ is positive. 
