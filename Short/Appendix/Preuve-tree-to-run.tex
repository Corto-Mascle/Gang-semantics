\subsection{Proof of Lemma~\ref{lem:tree-to-run}}
\label{app:tree-to-run}

\LemTreeToRun*

We start by defining "partial runs" as "runs" where some broadcasts are missing: We allow processes to receive messages that were not broadcast by anyone. We will construct inductively "partial runs" from the tree, that we will then compose to obtain complete "runs", by executing them in parallel matching missing broadcasts in a partial run with the broadcast of the other.

\begin{definition}
	Let $\config, \config'$ two configurations. 
	
	An ""internal message@@global"" from $\config$ to $\config'$, denoted $\config \intmessage{m}{v} \config'$, is defined when there is a "step" $\config \step{} \config'$ in which an agent broadcasts a message $(m,v)$. 
	
	An ""external message@@global"" from $\config$ to $\config'$, denoted $\config \extmessage{m}{v} \config'$ is defined when for all agents $a$, either there is a "local step" $\config(a) \extbr{m}{v} \config'(a)$ or $\config(a) = \config'(a)$.
	
	A ""partial step"" $\config \pstep{} \config'$ is defined if either $\config \intmessage{m}{v} \config'$ or $\config \extmessage{m}{v} \config'$ for some $m \in \messages$, $v\in \nats$.
	A ""partial run"" is a sequence of "partial steps" $\config_0 \pstep{} \config_1  \pstep{} \cdots \pstep{} \config_k$. We write $\config \pstep{\run} \config'$ the existence of such a "partial run" $\run$ from $\config$ to $\config'$.
	Note that a "local run" can be seen as a "partial run" with a single agent.
	
	We define the $v$-""projection"" $\intro*\vproj{\aval}{\run}$ of $\run$, which is the word $(b_0, x_0) \cdots (b_\ell, x_\ell) \in (\messages \times \set{in, out})^*$ obtained from $\run$ by mapping every "external message@@global" $\config \extmessage{m}{v} \config'$ to $(m, in)$, every "internal message@@global" $\config \intmessage{m}{v} \config'$ to $(m, out)$, and everything else to $\varepsilon$.
	
	\AP The $v$-""input@@partial"" $\vinput{v}{\run}$ (resp. $v$-""output@@partial"" $\voutput{v}{\run}$) of a "partial run" $\run$ is the sequence $m_0 \cdots m_k$ such that the projection on $\messages \times \set{in}$ (resp. $\messages\times \set{out}$) of $\vproj{v}{\run}$ is $(m_0, in) \cdots (m_k, in)$ (resp. $(m_0, out)\cdots(m_k, out)$).
	
	\AP A "partial run" is ""initial@@partial"" if it starts in an "initial configuration".
	
	\AP Given a "partial run" $\run$ and a value $v \in \nats$ appearing in $\run$, $v$ is ""initial@@partial"" in $\run$ if it is "initial" for some agent in $\run$. Note that this is not always true for "partial runs", unlike for "runs", because it could be that $v$ was received in $\run$ through an "external message@@global". 
	
	For all configurations $\config$ over $\agents$ and $\config'$ over $\agents'$ such that $\agents \cap \agents' = \emptyset$, we write $\config \sqcup \config'$ for the configuration over $\agents \cup \agents'$ such that $\config \sqcup \config'(a)$ is $\config(a)$ if $a \in \agents$ and $\config'(a)$ if $a \in \agents'$. 
	
\end{definition}


We are now ready to prove Lemma~\ref{lem:tree-to-run}.

\LemTreeToRun*

We actually prove a stronger statement by induction on the "unfolding tree".
The induction property is as follows. For every "unfolding tree" $\tree$:
\begin{itemize}
	\item if $\tree$ satisfies a "boss specification" $w \in \messages^*$, then there exists an "initial run" $\run$ satisfying $w$.
	\item if $\tree$ satisfies a "follower specification" $(\followwordspec, \followmessagespec)$ then there exist an "initial partial run" $\run$ and a value $v$ such that $\Input{\run} \in (\messages\times \set{v})^*$, $\vinput{v}{\run} \subword \followwordspec$, and $\voutput{v}{\run}$ contains $\followmessagespec$.
\end{itemize}

Let $\tree$ be a "unfolding tree", let $\node$ be its root.

We see $u := \localrunlabel{\node}$ as a "partial run" with a single agent. Recall that by definition of an "unfolding tree", $u$ starts with distinct values in all its registers, hence it is an "initial partial run".
We are going to compose $u$ with some runs given by the children of $\node$ to construct a run satisfying the properties above.
Let $V$ be the set of values appearing in $u$ and $V_{init}$ be the set of "initial@@partial" values of $u$.

We set $\run := u$, seen as a "partial run". We will use the induction hypothesis on the children of $\node$ to obtain partial runs with which we will complete $\run$.

\subsubsection{Step 1: "Non-initial@@partial" Values}
\label{sec:tree-to-run-step-one}

For each non-initial value $v$ of $u$, $\node$ has a "boss" child labelled by a word $bw$ such that $\vinput{v}{u} \subword bw$.
By induction hypothesis, there is an "initial run" $\run'$ satisfying $bw$.
We can rename values so that $bw$ is broadcast in $\run'$ with value $v$.

We then extend $\run$ by adding fresh agents which execute $\run'$ without receiving anything from the previous agents. On the ohter hand, we can use the broadcasts made by the new agents to fill in the missing broadcasts over value $v$.

This gives us a "run" $\run$ which no longer has any missing broadcasts on $v$, and whose behaviour on other values of $V$ is unaffected.

\subsubsection{Step 2: "Initial@@partial" Values}
\label{sec:tree-to-run-step-two}

We proceed in the same way as in the previous part: the goal is now to use the "partial runs" yielded by the "follower" children to eliminate the "input@@partial" over each "non-initial@@partial" value of $u$, except maybe for $\valuelabel{\node}$, which requires a special case.

\Huge TODO \normalsize

\subsubsection{Step 3: $\valuelabel{\node}$}

In this final part, we use Lemma~\ref{lem:follower-composition-output} to complete the "partial run" previously obtained so that it has enough output on $\valuelabel{\node}$ to satisfy the specification of $\node$. In fact, if $\node$ is a "follower node", the "partial run" constructed so far suffices. If $\node$ is a "boss node", we need to apply Lemma~\ref{lem:follower-composition-output}.

In Section~\ref{sec:tree-to-run-step-two} we constructed an "initial partial run" $\widehat{\run}$ such that for all $v \in \nats$:
\begin{itemize}
	\item If $v = \valuelabel{\node}$ then $\vproj{v}{\widehat{\run}} = \vproj{v}{u}$
	
	\item If $v \neq \valuelabel{\node}$ then $\vinput{v}{\widehat{\run}} = \epsilon$
\end{itemize}  

We have two cases: either $\mu$ is a "boss node" or a "follower node".

If $\mu$ is a "boss node" then there exists a decomposition $\decsymb=(w_0, m_1, \ldots, w_\ell)$ such that $\bosslabel{\node} \in \langdec{\decsymb}$ and $u$ can be split into $u_0, \cdots, u_\ell$ so that for all $i \in \nset{1}{\ell}$, $w_i \subword \voutput{v}{u_i}$ and $\vinput{v}{u_i} \in \set{m_0, \ldots, m_{i-1}}^*$ and $\node$ has a child $\node_i$ such that $\followlabelmessage{\mu_i} = m_i$ and $\followlabelword{\node_i} \in \langdec{\decsymb_i}$, with $\decsymb_i = (w_0, m_1, \ldots, w_{i-1})$.

As $\bosslabel{\node} \in \langdec{\decsymb}$, we have $\bosslabel{\node} = w'_0 \cdots w'_\ell$ where for all $i$ the projection of $w'_i$ on $\messages\setminus\set{m_1, \ldots, m_{i-1}}$ is a subword of $w_i$. 

We repeat the arguments from Section~\ref{sec:tree-to-run-step-two}, but we use Lemma~\ref{lem:follower-composition-output} instead of Lemma~\ref{lem:follower-composition-completion} to obtain an "initial run" $\Tilde{\run}$ such that,
\begin{itemize}	
	\item $\vinput{v}{\Tilde{\run}} = \epsilon$ for all $v \in \nats$
	
	\item $\bosslabel{\node} \subword \voutput{\valuelabel{\node}}{\Tilde{\run}}$
\end{itemize}

If $\tree$ satisfies a "boss specification" $w$  then $w \subword \bosslabel{\node} $ and thus $w \subword \voutput{\valuelabel{\node}}{\Tilde{\run}}$.
As a result, $\Tilde{\run}$ satisfies $w$ as well.
If $\node$ is a "follower node" then the run $\widehat{\run}$ previously constructed is such that  

\begin{itemize}	
	\item $\vinput{v}{\Tilde{\run}} = \epsilon$ for all $v \neq \valuelabel{\node}$
	
	\item $\vinput{\valuelabel{\node}}{\widehat{\run}} = \voutput{\valuelabel{\node}}{\localrunlabel{\node}} \subword \followlabelword{\node}$
	
	\item $\voutput{\valuelabel{\node}}{\widehat{\run}} = \voutput{\valuelabel{\node}}{\localrunlabel{\node}}$ contains $\followlabelmessage{\node}$
\end{itemize}

Hence $\widehat{\run}$ satisfies the required properties.
This concludes our induction.