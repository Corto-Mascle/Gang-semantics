\subsection{Proof of Lemma~\ref{lem:tree-to-run}}
\label{app:tree-to-run}

\LemTreeToRun*

We start by defining "partial runs" as "runs" where some broadcasts are missing: We allow processes to receive messages that were not broadcast by anyone. We will construct inductively "partial runs" from the tree, that we will then compose to obtain complete "runs", by executing them in parallel matching missing broadcasts in a partial run with the broadcast of the other.

\begin{definition}
	Let $\config, \config'$ two configurations. 
	
	A ""partial step"" $\config \pstep{} \config'$ is defined if either $\config \step{} \config'$ (normal "step") or there exist $m \in \messages$, $v\in \nats$ such that for all agent $a$ either $\config(a) = \config'(a)$ or $\config(a) \extbr{\delta}{v} \config'(a)$ with $\delta$ a transition receiving "message type" $m$ (""missing broadcast"").
	
	A ""partial run"" is a sequence of "partial steps".
	Note that a "local run" can be seen as a "partial run" with a single agent.A "partial run" is ""initial@@partial"" if it starts in an "initial configuration".
	
	
	\AP The $v$-""input@@partial"" $\vinput{v}{\run}$ (resp. $v$-""output@@partial"" $\voutput{v}{\run}$) of a "partial run" $\run$ is the sequence $m_0 \cdots m_k$ of "message types" corresponding to "missing broadcasts" (resp. "broadcasts") in $\run$.
\end{definition}


We are now ready to prove Lemma~\ref{lem:tree-to-run}.

\LemTreeToRun*

We actually prove a stronger statement by induction on the "unfolding tree".
The induction property is as follows. For every "unfolding tree" $\tree$:
\begin{itemize}
	\item if $\tree$ satisfies a "boss specification" $w \in \messages^*$, then there exists an "initial run" $\run$ satisfying $w$.
	\item if $\tree$ satisfies a "follower specification" $(\followwordspec, \followmessagespec)$ then there exist an "initial partial run" $\run$ and a value $v$ such that $\Input{\run} \in (\messages\times \set{v})^*$, $\vinput{v}{\run} \subword \followwordspec$, and $\voutput{v}{\run}$ contains $\followmessagespec$.
\end{itemize}

Let $\tree$ be a "unfolding tree", let $\node$ be its root.

We see $u := \localrunlabel{\node}$ as a "partial run" with a single agent. Recall that by definition of an "unfolding tree", $u$ starts with distinct values in all its registers, hence it is an "initial partial run".
We are going to compose $u$ with some runs given by the children of $\node$ to construct a run satisfying the properties above.
Let $V$ be the set of values appearing in $u$ and $V_{init}$ be the set of "initial@@partial" values of $u$.

We set $\run := u$, seen as a "partial run". We will use the induction hypothesis on the children of $\node$ to obtain partial runs with which we will complete $\run$.

\subsubsection{Step 1: "Non-initial@@partial" Values}
\label{sec:tree-to-run-step-one}

For each non-initial value $v$ of $u$, $\node$ has a "boss" child labelled by a word $bw$ such that $\vinput{v}{u} \subword bw$.
By induction hypothesis, there is an "initial run" $\run'$ satisfying $bw$.
We can rename values so that $bw$ is broadcast in $\run'$ with value $v$, and $\run'$ has no other shared value with $\rho$.

We then extend $\run$ by adding fresh agents which execute $\run'$ without receiving anything from the previous agents. On the other hand, we can use the broadcasts made by the new agents to fill in the missing broadcasts over value $v$.

This gives us a "run" $\run$ which no longer has any missing broadcasts on $v$, and whose behaviour on other values of $V$ is unaffected.

\subsubsection{Step 2: "Initial@@partial" Values}
\label{sec:tree-to-run-step-two}

We proceed in the same way as in the previous part: the goal is now to use the "partial runs" yielded by the "follower" children to eliminate the "input@@partial" over each "non-initial@@partial" value of $u$, except maybe for $\valuelabel{\node}$, which requires a special case.

Let $v$ be an "initial value" of $u$, and $\decsymb = (w_0, m_1, w_1, \ldots, m_\ell, w_\ell)$ the associated "decomposition" (from \ref{item:condition2_initial_value}). We can split $u$ into $u_0, \ldots, u_\ell$ with $w_i \subword \voutput{\aval}{\localrun_i}$ and $\vinput{\aval}{\localrun_i} \in \set{m_1, \dots, m_{i-1}}^*$ for all $i$. 

As the previous modifications of $\run$ did not alter its behavior with respect to $v$, we can also split the current $\run$ into $\run_0, \ldots, \run_\ell$ with $w_i \subword \voutput{\aval}{\run_i}$ and $\vinput{\aval}{\run_i} \in \set{m_1, \dots, m_{i-1}}^*$ for all $i$. 

By definition of an "unfolding tree", $\node$ has a "follower" child $\node_j$ for each $j$ labelled by $\followlabelmessage{\node_j} = m_j$ and $\followlabelword{\node_j} \in \langdec{\decsymb_j}$ with $\decsymb_j = (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$. 

By induction hypothesis, this means that there exists an "initial partial run" $\Tilde{\run}_j$ whose only missing broadcasts are on $v$ (we can rename values to make them match), $\vinput{v}{\Tilde{\run}} \subword \followlabelword{\node_{j}}$ and that broadcasts $\followlabelmessage{\node_{j}}$ with value $v$. We can even cut that run right after that broadcast so that it ends with it. 

We can split $\Tilde{\run}_j$ into $\Tilde{\run}_{j, 0}, \ldots, \Tilde{\run}_{j,j-1}$ so that each  $\vinput{v}{\Tilde{\run}_{j, i}} \subword \Tilde{w_i}$ where $\Tilde{w_i}$ can be obtained by adding letters from $\set{m_1, \ldots, m_j}$ to $w_i$.

We can compose each $\run$ with $\Tilde{\run}_{j}$ by running them in parallel over disjoint sets of agents and matching each $\Tilde{\run}_{j, i}$ with $\run_i$ so that the broadcasts of $\run_i$ with value $v$ forming $w_i$ are received in $\Tilde{\run}_{j, i}$ and the only remaining missing broadcasts in that part of the run are of $m_1, \ldots, m_i$.
We obtain a run section whose "$v$-output" still contains $w_i$ and whose "$v$-input" only contains $m_1, \ldots, m_i$. 

Finally, we can use the last operation of $\Tilde{\run}_{j, i}$, which is a broadcast of $m_j$ with value $v$, at any point during the rest of the run, to either extend the "$v$-output" of some $\run_k$ with $k \geq j$ or complete a missing broadcast.
This construction is illustrated in Figure
\begin{figure}
	\input{../Figures/Fig-tree-to-run}
	\caption{An illustration of the composition operation from the proof of Lemma~\ref{lem:tree-to-run}}.
	\label{fig:tree-to-run}
\end{figure}
If $\val = \valuelabel{\node}$ then we have $\bosslabel{\node} \in \langdec{\decsymb}$, and we need to ensure that $\bosslabel{\node}$ is broadcast in $\run$ with value $\val$.
Let $\bossspec_0, \ldots, \bossspec_\ell$ such that $\bosslabel{\node} \subword \bossspec_0\cdots\bossspec_\ell$ and for all $j$, $\bossspec_j$ can be obtained by adding letters from $\set{m_1,\ldots, m_j}$ in $w_j$.
We apply the above composition operation to extend the output of each $\run_{i}$ so that it subsumes $\bossspec_i$ while making sure that its "input" is still only made of $m_1, \ldots, m_i$ with value $v$. 

Then, in all cases, we apply this composition operation to complete the missing broadcasts: while there is a missing broadcast of some letter $m_i$, we compose $\run$ with $\Tilde{\run}_i$ to fill it, while possibly adding some missing broadcasts of $m_1, \ldots, m_{i-1}$.
This procedure terminates as the number of missing broadcasts of $m_\ell, m_{\ell-1}, \ldots, m_1$ decreases for the lexicographic order at each step.

In the end we obtain a run with no missing broadcast on $v$, no missing broadcasts on values outside of $V$ and whose behavior on all other values of $V$ is unaffected. Furthermore if $v = \valuelabel{\node}$ then the $v$-output resulting run subsumes $\bosslabel{\node}$. We set $\run$ to be this new "run".

We have shown how to complete $u$ into a "partial run" satisfying the "specification" of $\node$ using the "runs" obtained from its "boss" and "follower" children. This proves the lemma by induction on the "unfolding tree" (there is no need for a base case as the construction applies even if $\node$ has no children).