\usepackage[utf8]{inputenc}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}

\usepackage[demo]{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[]{todonotes}
\usepackage[notion, quotation, electronic]{knowledge}
%replace electronic with paper to remove colours
\usepackage{extarrows}
\usepackage[normalem]{ulem}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{booktabs}
%\usepackage{array}
%\usepackage{changepage}
\usepackage{enumitem}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{multidef}
\usepackage{xspace}
\usepackage{mathrsfs}
\usepackage{thm-restate}


\usetikzlibrary{arrows,calc,automata,fit,shapes,positioning}
\tikzset{AUT style/.style={>=angle 60,initial text= ,every edge/.append,every state/.style={minimum size=20,inner sep=2}}}


%\newenvironment{proofsketch}{\noindent\emph{Proof sketch.}}{\hfill$\square$}

% for proof sketch
\let\llncsproof\proof
\renewcommand{\proof}[1][]{%
  \ifx!#1!\else\renewcommand{\proofname}{#1}\fi
  \llncsproof
}

%theorems
\declaretheorem[name=Fact]{fact}
\declaretheorem[name=Observation]{observation}
\makeatletter
\let\c@proposition\c@theorem
\let\c@corollary\c@theorem
\let\c@lemma\c@theorem
\let\c@definition\c@theorem
\let\c@example\c@theorem
\let\c@remark\c@theorem
\let\c@fact\c@theorem
\let\c@observation\c@theorem
\makeatother


\let\saveendexample\endexample
\def\endexample{\qed\saveendexample}
\let\saveendproof\endproof
\def\endproof{\qed\saveendproof}
%%% Basic Math

\newcommand{\nats}{\mathbb{N}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\powerset}[1]{2^{#1}}
\newcommand{\step}[1]{\xrightarrow{#1}}
\newcommand{\extlabel}[2]{\mathsf{ext}(#1,#2)} % message type + value
\newcommand{\intlabel}[1]{\mathsf{int}(#1)}
\newcommand{\locallabel}{\lambda} % variable name for something that may either be a \extlabel or a \intlabel
\newcommand{\extbr}[2]{\xrightarrow{\extlabel{#1}{#2}}}
\newcommand{\intstep}[1]{\xrightarrow{\intlabel{#1}}}
\newcommand{\size}[1]{|#1|}
\newcommand{\length}[1]{\mathsf{len}(#1)}
\newcommand{\nset}[2]{[#1,#2]} %interval of natural numbers
%%% Complexity classes

% \newcommand{\poly}{\text{\sc{P}}\xspace}
% \newcommand{\conp}{\textsc{coNP}\xspace}
% \newcommand{\pspace}{\text{\sc{PSpace}}\xspace}
% \newcommand{\expt}{\textsc{ExpTime}\xspace}
% \newcommand{\nexpt}{\textsc{NExpTime}\xspace}
% \newcommand{\exps}{\textsc{ExpSpace}\xspace}
\multidef{\text{\sc{#1}}\xspace}{co,coNP,NP,PSPACE,coPSPACE,NPSPACE,PTIME,EXPTIME,EXPSPACE,NEXPTIME, LOGSPACE, TOWER, BNRA}
\newcommand{\Fcomplexity}[1]{\mathbf{F}_{#1}} % the Falpha complexity class
\newcommand{\Fomegaomega}{\Fcomplexity{\omega^{\omega}}}
\newcommand{\Ffunction}[1]{\mathscr{F}_{#1}}
\newcommand{\COVER}{\textsc{"Cover"}\xspace}

%%% Genral definition
\newcommand{\prot}{\mathcal{P}} %protocol
\newcommand{\transitions}{\Delta} % transitions
\newcommand{\atrans}{\delta}

% greek letters
\renewcommand{\a}{\alpha}
\newcommand{\config}{\gamma}
\renewcommand{\epsilon}{\varepsilon}


%%% BNRA syntax

\newcommand{\brone}[1]{\textbf{br}(#1)}
% for reception, first argument is message type and second is operation made with the register
\newcommand{\recone}[2]{\textbf{rec}(#1, #2)}

\newcommand{\br}[2]{\textbf{br}(#1, #2)}
% for reception, first argument is message type and second is operation made with the register
\newcommand{\rec}[3]{\textbf{rec}(#1, #2, #3)}
\newcommand{\loc}[3]{\textbf{loc}(#1,#2,#3)}
\newcommand{\recmulti}[2]{\textbf{rec}(#1, #2)}
\newcommand{\brsymb}{\textbf{br}}
\newcommand{\recsymb}{\textbf{rec}}
\newcommand{\locsymb}{\textbf{loc}}

\newcommand{\actions}{\mathsf{Actions}}
\newcommand{\anact}{\alpha}
\newcommand{\enregact}{\downarrow}
\newcommand{\dummyact}{{*}}
\newcommand{\diseqtestact}{{\ne}}
\newcommand{\eqtestact}{{=}}




% projection of a configuration on state part and register part
\newcommand{\st}[1]{\mathsf{st}(#1)}
\newcommand{\data}[1]{\mathsf{data}(#1)}

% a register value
\newcommand{\aval}{v}
\newcommand{\avalbr}{v_{\brsymb}}
%messages
\newcommand{\messages}{\mathcal{M}}
\newcommand{\amessage}{m}
\newcommand{\wordproj}[2]{\pi_{#2}(#1)}
\newcommand{\regnum}{r}
\newcommand{\operations}{\mathsf{Op}}
\newcommand{\op}{\mathsf{op}}

%font for variables in queries
\newcommand{\var}[1]{\mathsf{#1}}
\newcommand{\varz}{\var{z}}
\newcommand{\varset}{\mathsf{Var}}

\newcommand{\query}{\phi}

\newcommand{\apath}{\pi} % hoping that this does not beak anything
\newcommand{\run}{\rho}
% \newcommand{\Runs}[1]{Runs_{#1}}
\newcommand{\runsize}[1]{||#1||}
\newcommand{\agents}{\mathbb{A}}
\knowledgenewrobustcmd{\statesin}[1]{\mathsf{\cmdkl{cov}}\cmdkl{(}#1\cmdkl{)}}
\knowledgenewrobustcmd{\valsof}[1]{\mathsf{\cmdkl{val}}\cmdkl{(}#1\cmdkl{)}}
\knowledgenewrobustcmd{\agentsof}[1]{\mathsf{\cmdkl{ag}}\cmdkl{(}#1\cmdkl{)}}

\newcommand{\allconfigs}{\Gamma}

\knowledgenewrobustcmd{\lessthan}{~\cmdkl{\trianglelefteq}~}

% gangs
\newcommand{\boss}{\mathsf{b}}
\newcommand{\clique}{\mathsf{K}}
\newcommand{\gang}{\mathsf{G}}
\newcommand{\gangset}{\mathcal{G}}
\newcommand{\gangconfigs}{\mathcal{G}}
\knowledgenewrobustcmd{\gangof}[2]{\mathsf{\cmdkl{gang}}_{#1}\cmdkl{(}#2\cmdkl{)}}
\knowledgenewrobustcmd{\bossof}[2]{\mathsf{\cmdkl{\mathsf{\boss}}}_{#1}\cmdkl{(}#2\cmdkl{)}}
\knowledgenewrobustcmd{\cliqueof}[2]{\mathsf{\cmdkl{\clique}}_{#1}\cmdkl{(}#2\cmdkl{)}}
\newcommand{\noboss}{\bot}

\newcommand{\cliquesucc}[3]{\overrightarrow{#1^{#2,#3}}}

% abstract semantics
\newcommand{\covset}{S}
\newcommand{\aconfig}{\sigma}
\newcommand{\aconfigs}[1]{\Sigma_{#1}}
\newcommand{\allaconfigs}{\Sigma}
\newcommand{\aconfiginit}{\aconfig_0}
\newcommand{\aconfiginitset}{\allaconfigs_{\mathsf{init}}}
\newcommand{\arun}{\nu}

\knowledgenewrobustcmd{\absproj}[2]{\cmdkl{\mathsf{abs}}_{#1}\cmdkl{(}#2\cmdkl{)}}

% some standard names useful in proofs
\newcommand{\agentbr}{a_{\brsymb}} %agent broadcasting
\newcommand{\agentboss}{a_{\mathsf{boss}}}
\newcommand{\statebr}{q_{\brsymb}}


% 

\newcommand{\val}{v}
\newcommand{\trace}[1]{\mathsf{tr}(#1)}
\knowledgenewrobustcmd{\Input}[1]{\cmdkl{\mathsf{In}}(#1)}
\knowledgenewrobustcmd{\vinput}[2]{\cmdkl{\mathsf{In}}_{#1}(#2)}
\knowledgenewrobustcmd{\Output}[1]{\cmdkl{\mathsf{Out}}(#1)}
\knowledgenewrobustcmd{\voutput}[2]{\cmdkl{\mathsf{Out}}_{#1}(#2)}
\knowledgenewrobustcmd{\vproj}[2]{{#2}\cmdkl{|}_{#1}}

\newcommand{\inputword}{in}
\newcommand{\Outputword}{out}


\newcommand{\decsymb}{\mathtt{dec}}
\newcommand{\subdec}{\unlhd}
\knowledgenewrobustcmd{\langdec}[1]{\cmdkl{\mathcal{L}}^{\mathtt{#1}}}

\newcommand{\tree}{\tau}
\newcommand{\node}{\mu}

\knowledgenewrobustcmd{\localrunlabel}[1]{\cmdkl{\mathbf{lr}}(#1)}
\knowledgenewrobustcmd{\valuelabel}[1]{\cmdkl{\mathbf{val}}(#1)}
\knowledgenewrobustcmd{\bosslabel}[1]{\cmdkl{\mathbf{bw}}(#1)}
\knowledgenewrobustcmd{\followlabelword}[1]{\cmdkl{\mathbf{fw}}(#1)}
\knowledgenewrobustcmd{\followlabelmessage}[1]{\cmdkl{\mathbf{fm}}(#1)}
\knowledgenewrobustcmd{\speclabel}[1]{\cmdkl{\mathbf{spec}}(#1)}
\newcommand{\spec}{\mathsf{spec}}
\newcommand{\bossspec}{\mathsf{bw}}
\newcommand{\followwordspec}{\mathsf{fw}}
\newcommand{\followmessagespec}{\mathsf{fm}}



%Target problem
\newcommand{\TARGET}{\textsc{"Target"}\xspace}
\newcommand{\Loc}{\text{Loc}}
\newcommand{\cpt}{\ensuremath{\mathtt{x}}}
\newcommand{\Cpt}{\ensuremath{\mathtt{X}}}
\newcommand{\dec}[1]{\ensuremath{\mathtt{#1}-}}
\newcommand{\inc}[1]{\ensuremath{\mathtt{#1}+}}
\newcommand{\testz}[1]{\ensuremath{\mathtt{#1}=0?}}
\newcommand{\stepMM}[1]{\xrightarrow{#1}}
\newcommand{\altitude}[1]{\mathbf{alt}(#1)}
\newcommand{\altmax}{\mathbf{altmax}}
\newcommand{\altmin}{\mathbf{altmin}}


%local stuff
\newcommand{\localrun}{u}
\newcommand{\localdata}{\nu}

%partial runs

\newcommand{\pstep}[1]{\step{#1}_{p}}
\newcommand{\inttest}{\pstep{\locsymb}}
\newcommand{\intmessage}[2]{\pstep{\brsymb, #1, #2}}
\newcommand{\extmessage}[2]{\pstep{\recsymb, #1, #2}}
	
%bounding functions
\newcommand{\towerfun}{\psi}
\newcommand{\repexp}[2]{\mathsf{repexp}(#1,#2)}
\newcommand{\Vinit}{W}

\knowledgenewrobustcmd{\subword}{~\cmdkl{\preceq}~}
\newcommand{\supword}{\succeq}

\newcommand{\binrel}[3]{#1 \mathrel{#2} #3}

\newcommand{\los}{\mathcal{L}}
\newcommand{\lstep}[1]{\xrightarrow{#1}_{\los}}

\newcommand{\lstates}{L}
\newcommand{\lstate}{l}
\newcommand{\ltrans}{d}
\newcommand{\ltransitions}{D}
\newcommand{\startstate}[1]{\mathbf{s}(#1)}
\newcommand{\transstateone}[1]{\mathbf{t}(#1)}
\newcommand{\transstatetwo}[1]{\mathbf{u}(#1)}
\newcommand{\finstate}[1]{\mathbf{f}(#1)} %final states of protocol for encoding of LCS, argument is corresponding state of the LCS
\newcommand{\waitstate}{\mathbf{wait}}
\newcommand{\predfun}{\mathbf{pred}}
\newcommand{\popact}[1]{\mathsf{read}(#1)}
\newcommand{\pushact}[1]{\mathsf{write}(#1)}
%a trace
\newcommand{\atrace}{\mathsf{tr}}

%elimination of equality
\newcommand{\map}{\mathsf{map}}
\newcommand{\idmap}{\mathsf{id}}
\knowledgenewrobustcmd{\memoryproj}[1]{\cmdkl{\mathsf{mem}}(#1)}
\knowledgenewrobustcmd\perfproj[1]{\cmdkl{\mathsf{perf}}(#1)}

\newcommand{\tuple}[1]{\langle #1 \rangle}

% example of signature protocol
\newcommand{\exready}{\textsf{rdy}}
\newcommand{\exgotwo}{\textsf{go}}
\newcommand{\exgothree}{\textsf{stop}}
%unfolding trees in tikz, with 3 registers
\newcommand{\regbar}[2]{
	\node (reg1) at (#1, #2+0.15-0.5) {reg $1$};
	\node (reg2) at (#1, #2+0.15-1) {reg $2$};
	\node (reg3) at (#1, #2+0.15-1.5) {reg $3$};
}

\newcommand{\regbartworeg}[2]{
	\node (reg1) at (#1, #2+0.15-0.5) {reg $1$};
	\node (reg2) at (#1, #2+0.15-1) {reg $2$};
}

% arguments: x and y-cord of start + state + content of registers & fillings
\newcommand{\onerow}[9]{
\draw  (#1,#2) rectangle (#1+1, #2-0.5);
\draw[fill = #5, opacity = 0.4]  (#1,#2) rectangle (#1+1, #2-0.5);
\draw  (#1,#2-0.5) rectangle (#1+1, #2-1);
\draw[fill = #7, opacity = 0.4]  (#1,#2-0.5) rectangle (#1+1, #2-1);
\draw  (#1,#2-1) rectangle (#1+1, #2-1.5);
\draw[fill = #9, opacity = 0.4]  (#1,#2-1) rectangle (#1+1, #2-1.5);
\node [] (state) at (#1 +0.5 ,#2 + 0.2) {#3};
\node[] (reg1) at (#1 +0.5 ,#2 + 0.25 - 0.5) {#4};
\node[] (reg2) at (#1 +0.5 ,#2 + 0.25 -1) {#6};
\node[] (reg3) at (#1 +0.5 ,#2 + 0.25 -1.5) {#8};
}
\newcommand{\transtable}[3]{
	\node [align = center] at (#1, #2+0.2) {$\rightarrow$};
	\node [align = center, font = {\scriptsize}] at (#1,#2+0.6) {#3};
}


\newcommand{\onerowtworeg}[7]{
	\draw  (#1,#2) rectangle (#1+1, #2-0.5);
	\draw[fill = #5, opacity = 0.4]  (#1,#2) rectangle (#1+1, #2-0.5);
	\draw  (#1,#2-0.5) rectangle (#1+1, #2-1);
	\draw[fill = #7, opacity = 0.4]  (#1,#2-0.5) rectangle (#1+1, #2-1);
%	\draw  (#1,#2-1) rectangle (#1+1, #2-1.5);
%	\draw[fill = #9, opacity = 0.4]  (#1,#2-1) rectangle (#1+1, #2-1.5);
	\node [] (state) at (#1 +0.5 ,#2 + 0.2) {#3};
	\node[] (reg1) at (#1 +0.5 ,#2 + 0.25 - 0.5) {#4};
	\node[] (reg2) at (#1 +0.5 ,#2 + 0.25 -1) {#6};
%	\node[] (reg3) at (#1 +0.5 ,#2 + 0.25 -1.5) {#8};
}

%skulls are cool
\usepackage{skull}
\usetikzlibrary{backgrounds}

%cref
\creflabelformat{listlem}{#2\thethm.#1#3}

%quotes in math mode
\DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
\DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}
\newcommand{\quotemarks}[1]{\mlq #1 \mrq}

