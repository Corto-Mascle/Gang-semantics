\section{Cover decidability}
\label{sec:cover-decidability}

This section is dedicated to the proof of the main result of this paper:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for \BNRA{}s is decidable. Moreover, the problem is $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

Thanks to Proposition~\ref{prop:loc-eq-test-elimination}, we may assume that our protocols have no "local equality tests" (the complexity class $\Fomegaomega$ is stable by exponential reduction). 

The intuition of our decidability procedure is as follows. 
Consider a given run when an agent $a$ covers some state $q$; we want to understand $a$ needs from other agents in order to cover $q$. It might need to receive a sequence $w \in \messages^*$ of messages all with the same value, so that it stores the value of the first such message and tests further messages for equality.
From the other agents' perspective, they have to broadcast $w$ with the same value in every broadcast. We later call such a request a \emph{"boss specification"}.  
Agent $a$ might also broadcast messages with some value $\aval$ that it had initially, then require to receive messages with that same value. 
From the other agent's perspective, they have to broadcast a given message $(\amessage,\aval)$ after receiving $w$ with value $\aval$. We later call such a request a \emph{"follower specification"}.

The two roles identified previously are the key to the decidability procedure. Thanks to the copycat principle, we will be able to consider runs in which a given agent only plays one such role. To represent such executions, we define the notion of "unfolding trees"; an "unfolding trees" represents all such roles, dependencies between them and how they are carried out. The decidability procedure will rely on a bound of the minimum "size@@tree" of the "unfolding tree" one has to consider.

We will proceed as follows. In Section~\ref{sec:decidability-defs}, we introduce several usefuls notions. In Section~\ref{sec:decidability-tree-unfoldings}, we define the notion of "unfolding tree". In Section~\ref{sec:tree-bounds}, we bound the size of the "unfolding trees" that we have to consider; this is in fact the most technical part of this article. Finally, in Section~\ref{sec:decidability-end}, we conclude by expliciting our decidability procedure. 


\subsection{Useful definitions}
\label{sec:decidability-defs}

In this section, we define a notion of "local run"; a "local run" may be seen as the projection of a "run" onto a given agent. In this local vision, we do not consider the origin of the messages received.
	
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$, and $\atrans =(q, \alpha, q')$ is either a "broadcast" or a "local test" and if it is "local test" on register $i$ and $j$, $\localdata(i) \ne \localdata(j)$.  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and one of the following cases holds:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either an "reception step" or an "internal step". 
	\AP A ""local run"" is a sequence $\localrun$ of "local steps" $(q_0, \nu_0) \step{\locallabel_1} (q_1, \nu_1) \step{\locallabel_2} \cdots \step{\locallabel_k} (q_k, \nu_k)$ where, for all $i$, $\locallabel_i \in \set{\extlabel{\atrans}{\aval} \mid \atrans \in \transitions, \aval \in \nats} \cup \set{\intlabel{\atrans} \mid \atrans \in \transitions}$. 

	Finally, the ""input"" $\Input{\localrun} \in (\messages \times \nats)^*$ of a "local run" $\localrun$ is the sequence of messages of its "reception steps". Its ""output"" $\Output{\localrun} \in (\messages \times \nats)^*$ is the sequence of messages broadcast in $\localrun$. The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. Formally, $\vinput{\aval}{\localrun}$ (resp. $\voutput{\aval}{\localrun}$) is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ (resp. $\Output{\localrun}$) on $\messages \times \set{\aval}$. 
 
	A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. 
	$w \in \messages^*$ ""admits decomposition"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w \subword w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding letters from $\set{m_1, \ldots, m_{j-1}}$. 
	We denote by $\langdec{\decsymb}$ the language of words that admit decomposition $\decsymb$. 
	The idea of this definition is as follows: the message $m_i$ is broadcast by some agent that we are able to duplicate, but this agent needs to receive $w_{i-1}$ first; therefore, once $w_i$ has been broadcast, $m_i$ can be bradcast at will. The subword condition encoded the idea that messages may be lost. 

%	The ""input"" of a "local run" $\localrun$ is the sequence $\Input{\localrun} \in (\messages \times \nats)^*$ containing messages types and values of its "reception steps".
%	Similarly, its ""output"", which we denote by $\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of (internal) broadcast steps made in $\localrun$.
%	Given a value $v \in \nats $, the $v$-input $\vinput{\aval}{\localrun} $(resp. the $v$-output $\voutput{\aval}{\localrun}$) of $\localrun$ is defined as the sequence of messages of $\Input{\localrun}$ (resp. $\Output{\localrun}$) that have value $\aval$. Formally, $\vinput{\aval}{\localrun}$ is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ on $\messages \times \set{\aval}$. 
%	


\subsection{Unfolding trees}
\label{sec:decidability-tree-unfoldings}

An \emph{unfolding tree} is a description of a run achieving some goal. Each node is assigned a local run and a specification of the role of this local run. 

We mentioned those specifications earlier: they are of two types, \emph{boss} and \emph{follower}. A \emph{boss specification} consists of a word $\bossspec \in \messages^*$ describing a sequence of message types that should be broadcast, in that order, all with the same value. A \emph{follower specification} consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that assuming that all message types of $\followwordspec$ are broadcast in that order with a common value $v$, the agents should be able to later broadcast $\followmessagespec$ with that same value.

To witness the realization of a specification, we start by isolating an agent $a$. In the case of a boss specification, it is the agent which had the value with which the word is broadcast initially. If it is a follower one $(\followwordspec, \followmessagespec)$, it is the first agent that broadcasts the message $\followmessagespec$ with the desired value.

Let $\localrun$ be the "local run" of an agent $a$, for $a$ to be able to perform its "local run" it may need to receive some sequences of messages along with some values. Each of this reception leads to an action (it might be a dummy action) on one of $a$'s registers.
Due to the fact that each message contains a single value, and to the "copycat principle" which allows us to make many copies of a run in parallel, we can assume that messages carrying different values come from disjoint sets of agents which do not communicate with each other. This actually requires a non-trivial proof, but we focus on the intuition for now.

Let $v$ be a value and $m_1, \dots m_k$ the sequence of message types received with $\val$. We distinguish two possible situations: either (i) agent $a$ received value $\val$ earlier but did not have it initially, or (ii) value $\val$ was in some register $r$ at the start. 

 In case (i), we need to verify that some agents are able to send the sequence $m_1 \dots m_k$ with the same value. For instance, we justified in \cref{example-2} that state $q_3$ was not coverable, this is due to the fact that messages $m_1$ and $m_2$ cannot be sent with the same values. Hence $a$ requires some set of agents to satisfy the boss specification $m_1 \cdots m_k$.

Assume now we are in situation (ii). The only way for $a$ to receive some message with value $\val$ is if some other agents \emph{repeat} the value after storing it (because $a$ is the only holder of value $v$ in the first place). As a consequence, agent $a$ necessarily broadcast some messages with $v$. Name $w_0$ the sequence of messages agent $a$ broadcast with $v$ before receiving message $m_1$ (with value $\val$), then we need to check that some agent is able to send the message $m_1$ after receiving (a subword of) $w_0$, each message with value $\val$. This  means that $a$ needs some set of agents to satisfy the follower specification $(w_0, m_1)$.
Note that, as any number of agents can receive the sequence $w_0$, any number of agents can send the message $m_1$. Hence from that point on we can consider that we have an unlimited access to broadcasts of $m_1$ with $v$. 
Say now that later $a$ requires to receive a message $m_2 \neq m_1$, and let $w_1$ be the sequence of messages it has broadcast between the receptions of $m_1$ and $m_2$, then we need a set of agents satisfying $(w_1', m_2)$ with $w_1'$ obtained by concatenating $w_0$ with $w_1$ to which we can as many $m_1$ as needed.

Hence in order to certify that a specification is achievable, we have a root describing the behavior of agent $a$, to which we attach subtrees witnessing the necessary specifications in order for $a$ to be able to complete its local run.

%We can repeat the argument to $m_3$ and so on: note $w_2$ the sequence of messages broadcast by agent $a$ with register $r$ between receiving $m_2$ and $m_3$, an agent whose role is to send message $m_3$ might have received any sequence $w'_0\cdot w'_1 \cdot w'_2$ where: $w'_0$ is any subword of $w_0$, $w'_1$ is any subword of $w_1$ where some $m_1$ were inserted, and $w'_2$ is any subword of $w_2$ where some $m_1$ and $m_2$ were inserted. A "follower specification" in that case should be the word $w'_0 \cdot w'_1 \cdot w'_2$ among with message $m_3$, and should be read as:
%\begin{center}
%		{The role of a set of agents with "follower specification" $w, m$ is to send message $m$ with a value, after receiving the sequence of messages $w$ with the same value. In addition, this value shall not be any of the initial values of the agent}.
%%\end{center}
%Even in this case we write a set of agents rather than an agent because this agent might need some other agents in order to perform its task.


We may now formally define our unfolding trees which abstractly represent executions. 
\AP An ""unfolding tree"" $\tree$ over $\prot$ is
a finite tree where each node $\node$ has three labels:
\begin{itemize}
	\item The first one is a local run of $\prot$, written $\localrunlabel{\node}$. 
	
	\item The second one is a value, written $\valuelabel{\node}$.
	
	\item The third one is a ""specification"" $\speclabel{\node}$, which is either a word $\bosslabel{\node} \in \messages^*$ (""boss specification"") or a pair $(\followlabelword{\node}, \followlabelmessage{\node}) \in \messages^* \times \messages$ (""follower specification""). In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"".
\end{itemize} 

%A node represents a "local run" witnessing that some "role" can be carried out. The role is represented with its "specification" and its value is necessary to check that the "local run" is a valid witness.\lu{pas sure de cette phrase..}
%The root node should have a "local run" reaching the final state to cover. It should be seen as a boss node, however its value nor its exact specification (the word $\bosslabel{\node}$) are relevant as they shall not be used.\lu{dire plus de choses là dessus ?}

For a "follower node" $\node$, we will need to represent the possible sequences for $\followlabelword{\node}$ depending on the available messages. Remember that for the "local run" $\localrun$ of agent $a$ earlier, there was an infinite number of possible sequences $w_0' \cdot w_1' \cdot w_2'$ because any number of $m_1$ and $m_2$ could be added to the subwords of $w_2$. We find a way to describe all the possible sequence from $(w_0, m_1, w_1, m_2, w_2)$ in the following way:


As we argued earlier, the set of sequences $w_0' \cdot w_1' \cdot w_2'$ is exactly the language $\langdec{\decsymb}$ for $\decsymb = (w_0, m_1, w_1, m_2, w_2)$.

For $\aval$ appearing in a "local run", $\aval$ is ""initial"" if its appears in $u$'s first "local configuration", and ""non-initial"" otherwise. \nicoin{a enlever?}


We now state some conditions on the links between a node and its children.
Let $\node$ a node of $\tree$. 
The conditions expressed below state two things. First, that the "specifications" of its children are witnesses that messages received in the "local run" $\localrunlabel{\node}$ can be broadcast by other agents (Conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value})
Second, that $\node$ is a witness that its "specification" is carried out (Conditions \ref{item:condition3_follower_node} and \ref{item:condition4_boss_node}).
\begin{enumerate}[{Condition} (i)]
	\item \label{item:condition1_non_initial_value} For every non-initial value $\aval \ne \valuelabel{\node}$ of $\localrun$, $\node$ has a child $\node'$ which is a "boss node" such that $\vinput{\aval}{\localrun}$ is a subword of $\bosslabel{\node'}$.
	
	\item \label{item:condition2_initial_value} For every initial value $\aval$ appearing in $\localrun$, there is a "decomposition" $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$ s.t.:
	\begin{itemize}
		\item $\localrun$ may be split into successive "local runs" $\localrun_0, \dots, \localrun_{\ell}$ where, for all $i \in \nset{1}{\ell}$, $w_i \subword \voutput{\aval}{\localrun_i}$ and $\vinput{\aval}{\localrun_i} \in \set{m_1, \dots, m_{i-1}}^*$
		\item for all $i \in [1,\ell]$, $\node$ has a child $\node_i$ which is a "follower node" such that $\followlabelmessage{\node_i} = m_i$ and $\followlabelword{\node_i} \in\langdec{\decsymb_i}$ where $\decsymb_i = (w_0, m_1, w_1, \ldots, m_{i-1}, w_{i-1})$.	\end{itemize}
	
	\item \label{item:condition3_follower_node} If $\node$ is a "follower node" then $\aval$ is not an initial value of $\localrun$, $\vinput{\aval}{\localrun} = \followlabelword{\node}$ and 
	$\voutput{\aval}{\localrun}$ contains $\followlabelmessage{\node}$.

	\item \label{item:condition4_boss_node} If $\node$ is a "boss node", then $\valuelabel{\node}$ is an "initial value" of $\localrunlabel{\node}$ and the associated "decomposition" $\decsymb$ of \ref{item:condition2_initial_value} satisfies that $\bosslabel{\node} \in \langdec{\decsymb}$.
\end{enumerate}

Lastly, given $\tree$ an "unfolding tree", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@tree" of $\tree$ also takes into account the size of its nodes, so that a tree $\tree$ can be stored in space $O(\size{\tree})$ (by renaming the values appearing in $\tree$ if needed). 
%\luin{here should come more intuitions on the tree and some figures}
\begin{figure}
	\begin{center}
		\input{Figures/tree-example1}
	\end{center}
	\caption{Example of an unfolding tree}\label{fig-ex-unfolding-tree}
\end{figure}

\begin{example}
	In \cref{fig-ex-unfolding-tree}~we display an unfolding tree obtained from the execution presented in \cref{example-1}. Each node is labelled with a local run, a specification, and a value (we omit the one of the root). The local configurations are displayed as a state among with its two registers' values. For instance, the local run of the left bottom node of the tree is the sequence of two local configuration: the first one with state $q_0$, value of first register $x_3$, and second register $y_3$, and the second one with state $q_1$ and same registers' values.
	
	First, let us see why the tree is consistent with condition \ref{item:condition1_non_initial_value}.
	The only non-initial value of the root node is $y_2$ and its input is $m_4$, hence it has only one boss node child (the left middle node) and its specification contains $m_4$ (in this case, it is exactly $m_4$). The same holds for the left boss node with value $y_2$ (the only non-initial value is $x_3$ and its output is $m_2$) which has the bottom left node as a boss child. For the bottom left node, all its values are initials and hence it has no boss node child. The right node has one non-initial value : $x_1$. However, $x_1$ is also the value of the node, and so it should not have any boss node child. 
	
	The condition \ref{item:condition2_initial_value}~might be the harder to read. Take $x_1$ the initial value of the root node. Note that the output of the root node with value $x_1$ is $m_2$, and the input is $m_6$. As a consequence, the decomposition of the node should only be $(m_2, m_6, \epsilon)$, $(i = 1)$. Here the last word is $\epsilon$ because the local run of the root node stops after testing its first register value and it does not send anything afterwards. The root node should then have one follower node (the right node) such that its specification $\mathbf{fm}, \mathbf{fw}$ is such that $\mathbf{fm} = m_1$ and $\mathbf{fw} \in \langdec{dec_1}$. Note that $\mathtt{dec_1} = (m_2)$, and so $m_2 \in \langdec{dec_1}$. Note that for all other boss nodes (the two on the left), the input on initial is empty, so the decomposition is just composed of one word (the input word). As a consequence, the other boss nodes don't have follower nodes child.
	
	For condition \ref{item:condition3_follower_node}, the right node satisfies the condition: $x_1$ is not one of its initial value, its input is $m2$, and its output is $m_6$, hence the condition is satisfied.
	
	As for condition \ref{item:condition4_boss_node}, we can check that values of the boss nodes are indeed initial values of the "local runs" and the conditions on the decomposition described on condition \ref{item:condition2_initial_value}. As we said, we are not interested in the specification of the boss node and so we can choose any subword of the input (of the initial chosen value) of the local run.\lu{mal dit..} For all other boss nodes, we argue that their decomposition of a value is the single word made of the input of the value. For the bottom left node its input on $x_3$ is $m_2$ and as $m_2 \in \langdec{(m_2)}$, this satisfies the condition. For the left middle node, its input on $y_2$ is $m_4$ and so for the same reasons the condition is satisfied.
	
	
%	\luin{ici explications sur chacune des conditions}
	
	
	Note that if one wants to build a concrete execution of the protocol of Figure \ref{fig:ex1}~from the tree of Figure \ref{fig-ex-unfolding-tree}, the build execution should be over 4 agents (one agent per node). Each agent will play the role of a node of the tree. The agent playing the role of the bottom left node should broadcast its value among with message $m_2$ and stop. This message should be received by the agent playing the role of the boss node with value $y_2$, it will reach $q_5$ and store the value $x_3$ in its first register. It will then broadcast message $m_4$ among with value $y_2$ and stop. The latter broadcast should be received by the agent playing the role of the root node. This agent has broadcast messages $m_2$ before and reached $q_1$. When he broadcast message $m_2$ among with its value $x_1$, the message has been received by the agent playing role of the right node.
	The right node received $m_2$ among with $x_1$, it can then broadcast $m_2$ (which shall not be received) and reach $q_4$. From $q_4$ it can send message $m_6$ among with $x_1$. The message is reiceived by the agent playing the root node role, allowing him to reach $q_7$.
	
	
	

\end{example}


Our aim is to prove that we can study the \COVER problem directly on "unfolding trees". To do so, consider the following definition: 

\begin{definition}
\label{def:cov_witness}
We define a ""coverability witness"" as an "unfolding tree" whose root is a "boss node" whose local run covers $q_f$. 
\end{definition}

The following proposition expresses that this definition is sound, as indeed a "coverability witness" is a witness that \COVER is positive.
The proof can be found in Appendix~\ref{app:trees-sound-complete}.


\begin{restatable}{proposition}{treessoundcomplete}
\label{prop:trees-sound-complete}
An instance of $\COVER$ $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}

\begin{proof}[Proof sketch]
The translation from run to tree works by induction on the length of the run. We consider a run $\run$ achieving some specification and isolate a well-chosen agent $a$ (if it is a boss specification, the one with the value initially, if it is a follower one, the first agent to broadcast the given message). We consider, for each value appearing in its local run, the specification expressing what this agent needs to receive with that value in order to be able to satisfy the original specification. 
Each of those is satisfied by a strict prefix of $\run$ (except for a particular case where it is $\run$ itself which can only happen when going from a boss specification to a follower specification, which still allows the induction).

We construct a tree by labelling the root with the specification and the local run of $a$, and attaching to it subtrees obtained by induction hypothesis from the prefix runs.

The translation from tree to run consists in an induction on the tree. A key concept is the one of ``partial run'', which is a run in which some receptions have no broadcast, and thus the run needs to be completed with some broadcasts from another set of agents.
 Let $\tau$ be an unfolding tree. We show that if its root is labelled by a boss specification $\bossspec$ then there is a run in which $\bossspec$ is broadcast with a constant value. If it is labelled by a follower specification $(\followwordspec, \followmessagespec)$ then there is a ``partial run'' which requires a sequence of broadcasts of $\followwordspec$ over a constant value to broadcast $\followmessagespec$ itself with that same value.
 The induction then works by considering the runs obtained from the children of the root by induction hypothesis and then constructing a run using a parallel composition of those runs with the local run label of the root to eliminate the receptions without broadcasts and output the required sequence of messages. 
\end{proof}



\subsection{Bounding the size of the "unfolding tree"}
\label{sec:tree-bounds}

Our aim is now to provide bounds on the size of the "unfolding tree" that one has to consider for \COVER. To do so, we start with two simple observations. First, for "boss specifications", the longer the word broadcast, the better: if a word $\bossspec$ can be broadcast with a single value, then any subword of $\bossspec$ can also be received. 
% Therefore, if a branch of our tree has node $\node$ with "boss specification" $w$ and below has node $\node'$ "boss specification" $w'$ such that $w \subword w'$, then $\node'$ is better than $\node$ and one can shorten the tree by replacing $\node$ by $\node'$. 
For "follower specifications", it goes in the opposite direction: for a fixed $\followmessagespec$, the shorter the requirement $\followwordspec$, the better. The following lemma provides thus provides two ways of shortening an "unfolding tree". Its proof can be found in Appendix~\ref{app:proofs-reduction-branches}.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\tree$ be a "unfolding tree" whose root's local run covers $q_f$.
	Let $\node, \node'$ be two nodes of tree such that $\node$ is an ancestor of $\node'$. If:
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; or
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$
	\end{itemize}
	then there exists a smaller "unfolding tree" $\tree'$ whose root's local run covers $q_f$. 
\end{restatable}


We now show that there is a computable bound on the size of the "unfolding tree" achieving a given specification and labelled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem". 
However, this theorem cannot be simply applied on a branch of the tree, for several reasons: First there is no reason to think that the sizes of the labels of the children of a node can be bounded with respect to the label of that node, especially the "follower" ones.  Second, we can reduce the tree if we find either an \emph{increasing} pair of "boss" nodes or a \emph{decreasing} pair of "follower" ones. This is a problem as a branch can alternate between sequences of "bosses" and of "followers", making it impossible to apply the theorem.

In order to bound the size of the nodes, we use the following result, which essentially states that if there is a local run between two configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function, and which does not require larger inputs than the previous one.

\begin{restatable}{lemma}{lemShortLocalRuns}
	\label{lem:short-local-runs}
	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers per agent, for every "local run" $\localrun: (q, \localdata) \step{*} (q', \localdata')$ in $\prot$, for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$,  for every $\Vinit \subseteq V$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun'} \leq \towerfun(\size{\prot} + \size{\Vinit},r)$ and:
	\begin{enumerate}
		\item \label{item:shorterrun_anyvalue} for all $\aval' \in \nats \setminus V$, there exists $\aval \in \nats \setminus \Vinit$ such that $\vinput{\aval'}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$,
		\item \label{item:shorterrun_oldvalues} for all $\aval \in V$, $\vinput{\aval}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$. 
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	First, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the run using an induction on the number of registers. Once we have proven this, we manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the run we may end up adding some fresh values to the run (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are always less constraining than the ones that were in the original run. The set $W$ should be thought of as the set of initial values of the run we are trying to shorten, which we do not want new value to mimic for technical reasons.
	The full proof can be found in Appendix~\ref{app:tower-lemma}.
\end{proof}




\begin{remark}
The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight in the sense that one may need a "local run" as large as a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \nico{à réduire / passer en annexe, idéalement décrire le protocole pour de vrai en annexe avec une figure mais long à faire}
% \end{remark}

\begin{figure}[h]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of the tree}
	\label{fig:rearrange-tree}
\end{figure}


Instead, we observe that a node demands input from its "boss" children while it sends output to its "follower" children. We thus rearrange the tree as in Figure~\ref{fig:rearrange-tree}, to make it so that long sequences of messages are sent upwards. We formalize this with the notion of altitude:



\begin{definition}
	We define the ""altitude"" of a node $\node$, written $\altitude{\node}$, in a "unfolding tree" recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$
		
		\item The altitude of a "boss node" is the altitude of its father minus one
		
		\item The altitude of a "follower node" is the altitude of its father plus one.
	\end{itemize}
\end{definition}

We now use the previous lemma to bound the label of each node $\node$ with respect to its neighbours of higher altitude, i.e., its "follower" children and its father if it is a "boss node". The idea is that those are the nodes that define the messages that $\localrunlabel{\node}$ should output to satisfy the tree conditions.

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\prot$ be a "protocol" over $\regnum$ registers, let $\node$ be a node of an "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $\bossspec$.
	Let $K$ be such that for all "follower" child $\node_f$ of $\node$, $\size{\followlabelword{\node_f}} \leq K$.
	We have the following properties:
	
	\begin{enumerate}				
		\item  If $\node$ is a "boss node" then 
		\begin{itemize}
			\item If $\node$ is the root of $\tree$ then $\bosslabel{\node} = w$, otherwise $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$ with $\node'$ its father
			
			\item In both cases $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) + 1)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK \Big]$
		\end{itemize}
		
		\item If $\node$ is a "follower node" then 
		\begin{itemize}			
			\item $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) +1)\Big[ 1 + \size{\messages}rK \Big]$
			
		\end{itemize}
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	A node $\node$ has at most $\size{\messages}$ "follower" children for each initial value, hence at most $\size{\messages}r$ in total, each one of them requires at most $K$ messages. The node $\node$ may have to output $\bosslabel{\node}$ extra messages to satisfy its specification if it is a "boss node", or just one $\followlabelmessage{\node}$ otherwise.
	
	In all cases we obtain a bound on the number of messages $\localrunlabel{\node}$ needs to broadcast. We mark the positions at which $\localrunlabel{\node}$ sends them and use Lemma~\ref{lem:short-local-runs} to bound the sections of run between two of those broadcasts by $\towerfun(\size{\prot},r)$, yielding the bounds above.
\end{proof}

This lemma lets us bound the labels of the nodes of maximal altitude, and then by applying it inductively we can bound the labels of all nodes at a given altitude $i$ depending on its difference with the maximal one $\altmax-i$ (Lemma~\ref{lem:bound-length-at-height-h}). We then use those results to bound the size of the tree.

 
\begin{restatable}{proposition}{PropBoundTreeSize}
	\label{prop:bound-tree-size}
	There exists a function $f$ of the class $\Ffunction{\omega^{\size{\messages}+1}}$ such that for all "protocol" $\prot$, for all "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $w$, the size of $\tree$ is bounded by $f(\size{\prot} + \size{w}+1)$.
\end{restatable}

\begin{proof}[Proof sketch]
	We consider a branch reaching maximal altitude: we mark along that branch all the nodes that have a greater altitude than all the previous ones (see Figure~\ref{fig:max-height-bound}). They are necessarily "follower" nodes as "boss" nodes are below their father. This sequence (reversed) is so that the $i$th term is at altitude $\altmax-i$ and we can bound its size with respect to $i$ with the previous arguments. Along with Lemma~\ref{lem:shortening-branches}, this allows us to apply the "Length function theorem" on that sequence to bound its length, hence we bound the maximal altitude (Lemma~\ref{lem:bound-max-height}).
	
	This yields in turn a bound on the root label, as its altitude ($0$) has a bounded difference with the maximal one. Another application of the "Length function theorem", this time with "boss nodes" lets us bound the minimal altitude of a node of this tree (Lemma~\ref{lem:bound-min-height}).
	
	Once we have bounded both the maximal and minimal altitudes, we can infer a bound on the size of all node labels (Lemma~\ref{lem:bound-node-size}), and then on branches as we can shorten branches as soon as they have two nodes with the same specification.
	The bound on the size of the tree then follows from the observation that as nodes have bounded local runs, they only see a bounded amount of values and thus need a bounded amount of children.
\end{proof}


\subsection{Decidability}
\label{sec:decidability-end}

We have shown that "unfolding trees" were a sound and complete abstraction for coverability in Section~\ref{sec:decidability-tree-unfoldings} and proven that there was a computable bound (of the class $\Ffunction{\omega^\omega}$) on the size of a minimal "unfolding tree" witnessing coverability, if it exists, in Sections~\ref{sec:tree-bounds}. Essentially, we then obtain decidability of the problem via the procedure computing that bound and then enumerating all trees below that size, checking for each one of them whether it is a valid "unfolding tree" witnessing coverability. We are skipping some details here, which are treated in the proof in Appendix~\ref{app:decidability}

\decidablecover*


