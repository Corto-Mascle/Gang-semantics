\section{Cover decidability}
\label{sec:cover-decidability}

This section is dedicated to the proof of the main result of this paper:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for \BNRA{}s is decidable. Moreover, the problem is $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

Thanks to Proposition~\ref{prop:loc-eq-test-elimination}, we may assume that our protocols have no "local equality tests" (the complexity class $\Fomegaomega$ being stable by exponential reduction). 

The intuition of our decidability procedure is as follows. 
Consider a given run and a given agent $a$ that covers some state $q$. We are interested in what the agent needs from other agents to cover $q$. The agent $a$ might need to receive a sequence $w \in \messages^*$ of messages that all have the same value, so that it stores the value of the first such message then tests equality with the stored value upon reception of following messages. 
From the other agents' perspective, this means that someone (or several agents) are required to broadcast $w$ with the same value in every broadcast. We later call such a request a \emph{"boss specification"}.  
Moreover, the agent $a$ might first broadcast messages with some value $\aval$ that it had initially and require to receive from other agents messages with this same value $\aval$. 
From the other agent's perspective, this means that someone, after receiving sequence of messages $w$ all with the same value $\aval$, is required to broadcast a given message $\amessage$ with value $\aval$. We later call such a request a \emph{"follower specification"}.

The two roles identified previously are the key to the decidability procedure. While, in the original run, it could be that some agent plays several such roles\lu{it would be nice to have such an example in the execution example and cite it there}, we will in fact show, thanks to the copycat principle, that one might consider that each agent only plays one such role. We will use what we will name an "unfolding tree" as a way to list all "roles" needed for a local run to happen, and, in the same time, to verify that each of this "role" can be carried out.

Hence, an interesting unfolding tree is an "unfolding tree" with root a local run covering the state to cover $q_f$.
%We will define an "unfolding tree" of a local run where each node provides a witness that a given "role" can be carried out. 
We will then provide bounds on the size of the "unfolding tree" that we have to consider, and conclude that a decidability procedure can simply guess such an "unfolding tree". 

We will proceed as follows. In Section~\ref{sec:decidability-defs}, we introduce several usefuls notions. In Section~\ref{sec:decidability-tree-unfoldings}, we define the notion of "unfolding tree". In Section~\ref{sec:tree_bounds}, we \nico{metre à jour apres fusion} provide useful arguments towards shortening branches of a tree. In Section~\ref{sec:local-bounds}, we provide useful arguments towards bounding the size of a given node of the tree. In Section~\ref{sec:tree-bounds}, we bound the overall size of the tree. In Section~\ref{sec:decidability-end}, we conclude by proving our decidability procedure. 


\subsection{Useful definitions}
\label{sec:decidability-defs}

We first need to define what is a "local run". A "local run" may be understood as the projection of a "run" onto a given agent. Among with "local runs", we define "local configurations" and "local steps".  When a "local step" describes the broadcast of a message we name it an "internal step", whereas when it describes a reception of a message with a certain value, we name it an "reception step". We also define a "trace" of a "local run" as the sequence of message types broadcast and received (and the received value when it is a reception) in the "local run".
	
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$, and $\atrans =(q, \alpha, q')$ is either a "broadcast" or a "local test" and if it is "local test" on register $i$ and $j$, $\localdata(i) \ne \localdata(j)$.  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and one of the following cases holds:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either an "reception step" or an "internal step". 
	\AP A ""local run"" is a sequence $\localrun$ of "local steps" $(q_0, \nu_0) \step{\locallabel_1} (q_1, \nu_1) \step{\locallabel_2} \cdots \step{\locallabel_k} (q_k, \nu_k)$ where, for all $i$, $\locallabel_i \in \set{\extlabel{\atrans}{\aval} \mid \atrans \in \transitions, \aval \in \nats} \cup \set{\intlabel{\atrans} \mid \atrans \in \transitions}$. 
	
	\AP A ""trace"" is a sequence in $(\set{\extlabel{\atrans}{\aval} \mid \atrans \in \transitions, \aval \in \nats} \cup \set{\intlabel{\atrans} \mid \atrans \in \transitions})^*$. The ""trace"" of a "local run" $\localrun$ is the "trace" $\trace{\localrun}$ containing the message types and values that $\localrun$ receives and broadcasts. Given a "trace" $\atrace$, we write $(q,\localdata) \step{\tau} (q',\localdata')$ to express that there exists a "local run" of "trace" $\atrace$ from $(q,\localdata)$ to $(q',\localdata')$. %peut-être qu'on peut mettre une partie de ça en annexe au niveau de la preuve du lemme tower

	

	Finally, we define the "input" and "output" of a "local run" $\localrun$: the "input", denoted by $\Input{\localrun} \in (\messages \times \nats)^*$, is the sequence containing messages types and values of its "reception steps". The output, denoted by $\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages types and values broadcast made in the "local run". The $\val$-input $\vinput{\aval}{\localrun} $ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of the "reception steps" (resp. the internal broadcasts steps) with value $\val$ made in $\localrun$. Formally, $\vinput{\aval}{\localrun}$ (resp. $\voutput{\aval}{\localrun}$) is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ (resp. $\Output{\localrun}$) on $\messages \times \set{\aval}$. 
	\nicoin{faire le point sur ce qui peut aller en annexe là-dedans}
%	The ""input"" of a "local run" $\localrun$ is the sequence $\Input{\localrun} \in (\messages \times \nats)^*$ containing messages types and values of its "reception steps".
%	Similarly, its ""output"", which we denote by $\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of (internal) broadcast steps made in $\localrun$.
%	Given a value $v \in \nats $, the $v$-input $\vinput{\aval}{\localrun} $(resp. the $v$-output $\voutput{\aval}{\localrun}$) of $\localrun$ is defined as the sequence of messages of $\Input{\localrun}$ (resp. $\Output{\localrun}$) that have value $\aval$. Formally, $\vinput{\aval}{\localrun}$ is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ on $\messages \times \set{\aval}$. 
%	


\subsection{Unfolding trees}
\label{sec:decidability-tree-unfoldings}

An \emph{unfolding tree} is a description of a run achieving some goal. Each node is assigned a local run and a specification of the role of this local run and its descendants in the global run.

We mentioned those specifications earlier: they are of two types, \emph{boss} and \emph{follower}. A \emph{boss specification} consists of a word $\bossspec \in \messages^*$ describing a sequence of message types that should be broadcast, in that order, all with the same value. A \emph{follower specification} consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that assuming that all message types of $\followwordspec$ are broadcast in that order with a common value $v$, the agents should be able to later broadcast $\followmessagespec$ with that same value.

To witness the realization of a specification, we start by isolating an agent $a$. In the case of a boss specification, it is the agent which had the value with which the word is broadcast initially. If it is a follower one $(\followwordspec, \followmessagespec)$, it is the first agent that broadcasts the message $\followmessagespec$ with the desired value.

Let $\localrun$ be the "local run" of an agent $a$, for $a$ to be able to perform its "local run" it may need to receive some sequences of messages along with some values. Each of this reception leads to an action (it might be a dummy action) on one of $a$'s registers.
Due to the fact that each message contains a single value, and to the "copycat principle" which allows us to make many copies of a run in parallel, we can assume that messages carrying different values come from disjoint sets of agents which do not communicate with each other. This actually requires a non-trivial proof, but we focus on the intuition for now.

Let $v$ be a value and $m_1, \dots m_k$ the sequence of message types received with $\val$. We distinguish two possible situations: either (i) agent $a$ received value $\val$ earlier but did not have it initially, or (ii) value $\val$ was in some register $r$ at the start. 

 In case (i), we need to verify that some agents are able to send the sequence $m_1 \dots m_k$ with the same value. For instance, we justified in \cref{example-2} that state $q_3$ was not coverable, this is due to the fact that messages $m_1$ and $m_2$ cannot be sent with the same values. Hence $a$ requires some set of agents to satisfy the boss specification $m_1 \cdots m_k$.

Assume now we are in situation (ii). The only way for $a$ to receive some message with value $\val$ is if some other agents \emph{repeat} the value after storing it (because $a$ is the only holder of value $v$ in the first place). As a consequence, agent $a$ necessarily broadcast some messages with $v$. Name $w_0$ the sequence of messages agent $a$ broadcast with $v$ before receiving message $m_1$ (with value $\val$), then we need to check that some agent is able to send the message $m_1$ after receiving (a subword of) $w_0$, each message with value $\val$. This  means that $a$ needs some set of agents to satisfy the follower specification $(w_0, m_1)$.
Note that, as any number of agents can receive the sequence $w_0$, any number of agents can send the message $m_1$. Hence from that point on we can consider that we have an unlimited access to broadcasts of $m_1$ with $v$. 
Say now that later $a$ requires to receive a message $m_2 \neq m_1$, and let $w_1$ be the sequence of messages it has broadcast between the receptions of $m_1$ and $m_2$, then we need a set of agents satisfying $(w_1', m_2)$ with $w_1'$ obtained by concatenating $w_0$ with $w_1$ to which we can as many $m_1$ as needed.

Hence in order to certify that a specification is achievable, we have a root describing the behavior of agent $a$, to which we attach subtrees witnessing the necessary specifications in order for $a$ to be able to complete its local run.

%We can repeat the argument to $m_3$ and so on: note $w_2$ the sequence of messages broadcast by agent $a$ with register $r$ between receiving $m_2$ and $m_3$, an agent whose role is to send message $m_3$ might have received any sequence $w'_0\cdot w'_1 \cdot w'_2$ where: $w'_0$ is any subword of $w_0$, $w'_1$ is any subword of $w_1$ where some $m_1$ were inserted, and $w'_2$ is any subword of $w_2$ where some $m_1$ and $m_2$ were inserted. A "follower specification" in that case should be the word $w'_0 \cdot w'_1 \cdot w'_2$ among with message $m_3$, and should be read as:
%\begin{center}
%		{The role of a set of agents with "follower specification" $w, m$ is to send message $m$ with a value, after receiving the sequence of messages $w$ with the same value. In addition, this value shall not be any of the initial values of the agent}.
%%\end{center}
%Even in this case we write a set of agents rather than an agent because this agent might need some other agents in order to perform its task.


We may now formally define our unfolding trees which abstractly represent executions. 
\AP An ""unfolding tree"" $\tree$ over $\prot$ is
a finite tree where each node $\node$ has three labels:
\begin{itemize}
	\item The first one is a local run of $\prot$, written $\localrunlabel{\node}$. 
	
	\item The second one is a value, written $\valuelabel{\node}$.
	
	\item The third one is a ""specification"" $\speclabel{\node}$, which is either a word $\bosslabel{\node} \in \messages^*$ (""boss specification"") or a pair $(\followlabelword{\node}, \followlabelmessage{\node}) \in \messages^* \times \messages$ (""follower specification""). In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"".
\end{itemize} 

%A node represents a "local run" witnessing that some "role" can be carried out. The role is represented with its "specification" and its value is necessary to check that the "local run" is a valid witness.\lu{pas sure de cette phrase..}
%The root node should have a "local run" reaching the final state to cover. It should be seen as a boss node, however its value nor its exact specification (the word $\bosslabel{\node}$) are relevant as they shall not be used.\lu{dire plus de choses là dessus ?}

For a "follower node" $\node$, we will need to represent the possible sequences for $\followlabelword{\node}$ depending on the available messages. Remember that for the "local run" $\localrun$ of agent $a$ earlier, there was an infinite number of possible sequences $w_0' \cdot w_1' \cdot w_2'$ because any number of $m_1$ and $m_2$ could be added to the subwords of $w_2$. We find a way to describe all the possible sequence from $(w_0, m_1, w_1, m_2, w_2)$ in the following way:

A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. 

We say that $w \in \messages^*$ ""admits decomposition"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w \subword w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding letters from $\set{m_1, \ldots, m_{j-1}}$.
We denote by $\langdec{\decsymb}$ the language of words that admit decomposition $\decsymb$. 

As we argued earlier, the set of sequences $w_0' \cdot w_1' \cdot w_2'$ is exactly the language $\langdec{\decsymb}$ for $\decsymb = (w_0, m_1, w_1, m_2, w_2)$.

For $\aval$ appearing in a "local run", $\aval$ is ""initial"" if its appears in $u$'s first "local configuration", and ""non-initial"" otherwise. \nicoin{a enlever?}


We now state some conditions on the links between a node and its children.
Let $\node$ a node of $\tree$. 
The conditions expressed below state two things. First, that the "specifications" of its children are witnesses that messages received in the "local run" $\localrunlabel{\node}$ can be broadcast by other agents (Conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value})
Second, that $\node$ is a witness that its "specification" is carried out (Conditions \ref{item:condition3_follower_node} and \ref{item:condition4_boss_node}).
\begin{enumerate}[{Condition} (i)]
	\item \label{item:condition1_non_initial_value} For every non-initial value $\aval \ne \valuelabel{\node}$ of $\localrun$, $\node$ has a child $\node'$ which is a "boss node" such that $\vinput{\aval}{\localrun}$ is a subword of $\bosslabel{\node'}$.
	
	\item \label{item:condition2_initial_value} For every initial value $\aval$ appearing in $\localrun$, there is a "decomposition" $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$ s.t.:
	\begin{itemize}
		\item $\localrun$ may be split into successive "local runs" $\localrun_0, \dots, \localrun_{\ell}$ where, for all $i \in \nset{1}{\ell}$, $w_i \subword \voutput{\aval}{\localrun_i}$ and $\vinput{\aval}{\localrun_i} \in \set{m_1, \dots, m_{i-1}}^*$
		\item for all $i \in [1,\ell]$, $\node$ has a child $\node_i$ which is a "follower node" such that $\followlabelmessage{\node_i} = m_i$ and $\followlabelword{\node_i} \in\langdec{\decsymb_i}$ where $\decsymb_i = (w_0, m_1, w_1, \ldots, m_{i-1}, w_{i-1})$.	\end{itemize}
	
	\item \label{item:condition3_follower_node} If $\node$ is a "follower node" then $\aval$ is not an initial value of $\localrun$, $\vinput{\aval}{\localrun} = \followlabelword{\node}$ and 
	$\voutput{\aval}{\localrun}$ contains $\followlabelmessage{\node}$.

	\item \label{item:condition4_boss_node} If $\node$ is a "boss node", then $\valuelabel{\node}$ is an "initial value" of $\localrunlabel{\node}$ and the associated "decomposition" $\decsymb$ of \ref{item:condition2_initial_value} satisfies that $\bosslabel{\node} \in \langdec{\decsymb}$.
\end{enumerate}

Lastly, given $\tree$ an "unfolding tree", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@tree" of $\tree$ also takes into account the size of its nodes, so that a tree $\tree$ can be stored in space $O(\size{\tree})$. 
%\luin{here should come more intuitions on the tree and some figures}
\begin{figure}
	\begin{center}
		\input{Figures/tree-example1}
	\end{center}
	\caption{Example of an unfolding tree}\label{fig-ex-unfolding-tree}
\end{figure}

\begin{example}
	In \cref{fig-ex-unfolding-tree}~we display an unfolding tree obtained from the execution presented in \cref{example-1}. Each node is labelled with a local run, a specification, and a value (we omit the one of the root). The local configurations are displayed as a state among with its two registers' values. For instance, the local run of the left bottom node of the tree is the sequence of two local configuration: the first one with state $q_0$, value of first register $x_3$, and second register $y_3$, and the second one with state $q_1$ and same registers' values.
	
	First, let us see why the tree is consistent with condition \ref{item:condition1_non_initial_value}.
	The only non-initial value of the root node is $y_2$ and its input is $m_4$, hence it has only one boss node child (the left middle node) and its specification contains $m_4$ (in this case, it is exactly $m_4$). The same holds for the left boss node with value $y_2$ (the only non-initial value is $x_3$ and its output is $m_2$) which has the bottom left node as a boss child. For the bottom left node, all its values are initials and hence it has no boss node child. The right node has one non-initial value : $x_1$. However, $x_1$ is also the value of the node, and so it should not have any boss node child. 
	
	The condition \ref{item:condition2_initial_value}~might be the harder to read. Take $x_1$ the initial value of the root node. Note that the output of the root node with value $x_1$ is $m_2$, and the input is $m_6$. As a consequence, the decomposition of the node should only be $(m_2, m_6, \epsilon)$, $(i = 1)$. Here the last word is $\epsilon$ because the local run of the root node stops after testing its first register value and it does not send anything afterwards. The root node should then have one follower node (the right node) such that its specification $\mathbf{fm}, \mathbf{fw}$ is such that $\mathbf{fm} = m_1$ and $\mathbf{fw} \in \langdec{dec_1}$. Note that $\mathtt{dec_1} = (m_2)$, and so $m_2 \in \langdec{dec_1}$. Note that for all other boss nodes (the two on the left), the input on initial is empty, so the decomposition is just composed of one word (the input word). As a consequence, the other boss nodes don't have follower nodes child.
	
	For condition \ref{item:condition3_follower_node}, the right node satisfies the condition: $x_1$ is not one of its initial value, its input is $m2$, and its output is $m_6$, hence the condition is satisfied.
	
	As for condition \ref{item:condition4_boss_node}, we can check that values of the boss nodes are indeed initial values of the "local runs" and the conditions on the decomposition described on condition \ref{item:condition2_initial_value}. As we said, we are not interested in the specification of the boss node and so we can choose any subword of the input (of the initial chosen value) of the local run.\lu{mal dit..} For all other boss nodes, we argue that their decomposition of a value is the single word made of the input of the value. For the bottom left node its input on $x_3$ is $m_2$ and as $m_2 \in \langdec{(m_2)}$, this satisfies the condition. For the left middle node, its input on $y_2$ is $m_4$ and so for the same reasons the condition is satisfied.
	
	
%	\luin{ici explications sur chacune des conditions}
	
	
	Note that if one wants to build a concrete execution of the protocol of Figure \ref{fig:ex1}~from the tree of Figure \ref{fig-ex-unfolding-tree}, the build execution should be over 4 agents (one agent per node). Each agent will play the role of a node of the tree. The agent playing the role of the bottom left node should broadcast its value among with message $m_2$ and stop. This message should be received by the agent playing the role of the boss node with value $y_2$, it will reach $q_5$ and store the value $x_3$ in its first register. It will then broadcast message $m_4$ among with value $y_2$ and stop. The latter broadcast should be received by the agent playing the role of the root node. This agent has broadcast messages $m_2$ before and reached $q_1$. When he broadcast message $m_2$ among with its value $x_1$, the message has been received by the agent playing role of the right node.
	The right node received $m_2$ among with $x_1$, it can then broadcast $m_2$ (which shall not be received) and reach $q_4$. From $q_4$ it can send message $m_6$ among with $x_1$. The message is reiceived by the agent playing the root node role, allowing him to reach $q_7$.
	
	
	

\end{example}


There is a strong connection between runs of $\prot$ and "unfolding trees". In fact, the following proposition expresses that \COVER may be expressed as the existence of an "unfolding tree". 
The proof can be found in Appendix~\ref{app:trees-sound-complete}.


\begin{restatable}{proposition}{treessoundcomplete}
\label{prop:trees-sound-complete}
Let $(\prot,q_f)$ an instance of $\COVER$. $(\prot,q_f)$ is positive if and only if there exists an "unfolding tree" $\tree$ of $\prot$ such that the local run at the root of $\tree$ covers $q_f$.
\end{restatable}

\begin{proof}[Proof sketch]
The translation from run to tree works by induction on the length of the run. We consider a run $\run$ achieving some specification and isolate a well-chosen agent $a$ (if it is a boss specification, the one with the value initially, if it is a follower one, the first agent to broadcast the given message). We consider, for each value appearing in its local run, the specification expressing what this agent needs to receive with that value in order to be able to satisfy the original specification. 
Each of those is satisfied by a strict prefix of $\run$ (except for a particular case where it is $\run$ itself which can only happen when going from a boss specification to a follower specification, which still allows the induction).

We construct a tree by labelling the root with the specification and the local run of $a$, and attaching to it subtrees obtained by induction hypothesis from the prefix runs.

The translation from tree to run consists in an induction on the tree. A key concept is the one of ``partial run'', which is a run in which some receptions have no broadcast, and thus the run needs to be completed with some broadcasts from another set of agents.
 Let $\tau$ be an unfolding tree. We show that if its root is labelled by a boss specification $\bossspec$ then there is a run in which $\bossspec$ is broadcast with a constant value. If it is labelled by a follower specification $(\followwordspec, \followmessagespec)$ then there is a ``partial run'' which requires a sequence of broadcasts of $\followwordspec$ over a constant value to broadcast $\followmessagespec$ itself with that same value.
 The induction then simply consists in considering the runs obtained for the children of the root by induction and then constructing a run using a parallel composition of those runs with the local run label of the root to eliminate the receptions without broadcasts and output the required sequence of messages. 
\end{proof}



\subsection{Bounding the size of the nodes of the "unfolding tree"}
\label{sec:local-bounds}

Our aim is now to provide bounds on the size of the "unfolding tree" that one has to consider for \COVER. To do so, we start with two simple observations. First, for "boss specifications", the longer the word broadcast, the better: if a word $\bossspec$ can be broadcast with a single value, then any subword of $\bossspec$ can also be broadcast with a single value and so we don't need to check if subwords of $\bossspec$ can be broadcast with a single value. 
% Therefore, if a branch of our tree has node $\node$ with "boss specification" $w$ and below has node $\node'$ "boss specification" $w'$ such that $w \subword w'$, then $\node'$ is better than $\node$ and one can shorten the tree by replacing $\node$ by $\node'$. 
For "follower specifications", it goes in the opposite direction: for a fixed $\followmessagespec$, the shorter the requirement $\followwordspec$, the better. The following lemma provides two ways of shortening an "unfolding tree". Its proof can be found in Appendix~\ref{app:proofs-reduction-branches}.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\tree$ be a "unfolding tree" whose root's local run covers $q_f$.
	Let $\node, \node'$ be two nodes of tree such that $\node$ is an ancestor of $\node'$. If:
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; or
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$
	\end{itemize}

	then $\tree$ can be shortened into an "unfolding tree" $\tree'$ whose root's local run also covers $q_f$. 
\end{restatable}


The previous lemma however does not suffice to apply the length function theorem (Theorem~\ref{thm:lengthfcttheorem}); we need a bound on the size of the words appearing in branches. The following lemma will allow us to bound the size of a local run with respect to the sequence of messages that it needs to broadcast. 


\begin{restatable}{lemma}{lemShortRunOutput}
	\label{lem:short-run-for-output}
	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every "protocol" $\prot$ with $\regnum$ registers per agent, for every $w_{out} \in (\messages\times \nats)^*$, 
	for every "local run" $\localrun: (q, \localdata) \step{*} (q', \localdata')$ such that $w_{out} \subword \Output{\localrun}$ and for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that, denoting by $\Vinit$\corto{à réécrire, la notion d'initial values ne convient pas aux runs non initiaux} the set of initial values in $\localrun$, we have $\length{\localrun'} \leq \towerfun(\size{\prot}+\regnum, \regnum) (\size{w_{out}}+1)$, $w_{out} \subword \Output{\localrun'}$ and:
	\begin{enumerate}
		\item for all $\aval' \in \nats \setminus V$, there exists $\aval \in \nats\setminus \Vinit$ such that $\vinput{\aval'}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$,
		\item for all $\aval \in V$, $\vinput{\aval}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$. 
	\end{enumerate}
\end{restatable}

The high-level idea behind the proof of the previous protocol is as follows. First, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the run using an induction on the number of registers. Once we have proven this, we manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. The full proof can be found in Appendix~\ref{app:tower-lemma}.

\begin{remark}
The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight in the sense that one may need a "local run" as large as a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \nico{à réduire / passer en annexe, idéalement décrire le protocole pour de vrai en annexe avec une figure mais long à faire}
% \end{remark}


We are ready to state and prove the lemma which bound the size of a node from its parent's size.

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\prot$ be a "protocol" over $\regnum$ registers, let $\node$ be a node of an "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $\bossspec$.
	Let $K$ be such that for all "follower" child $\node_f$ of $\node$, $\size{\followlabelword{\node_f}} \leq K$.
	If $\node$ is not the root of $\tree$ then let $\mu'$ be its father. 
	We have the following properties:
	
	\begin{enumerate}				
		\item  If $\node$ is a "boss node" then 
		\begin{itemize}
			\item If $\node$ is the root of $\tree$ then $\bosslabel{\node} = w$, otherwise $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$
			
			\item In both cases $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) + 1)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK \Big]$
		\end{itemize}
	
		\item If $\node$ is a "follower node" then 
		\begin{itemize}			
			\item $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}}$
			
			\item $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) +1)\Big[ 1 + \size{\messages}rK \Big]$
			
		\end{itemize}
	\end{enumerate}
\end{restatable}

\subsection{Tree bounds}
\label{sec:tree-bounds}

In this section we show that there is a computable bound on the size of the "unfolding tree" achieving a given specification and labelled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the Length function theorem recalled earlier (Theorem~\ref{thm:lengthfcttheorem}). 
However, this theorem cannot be simply applied on a branch of the tree, for several reasons: First there is no reason to think that the sizes of the labels of the children of a node can be bounded with respect to the label of that node, especially the "follower" ones.  Second, we can reduce the tree if we find either an \emph{increasing} pair of "boss" nodes or a \emph{decreasing} pair of "follower" ones. This is a problem as a branch can alternate between sequences of "bosses" and of "followers", making it impossible to apply the theorem.

\begin{figure}[h]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of the tree}
	\label{fig:rearrange-tree}
\end{figure}


Instead, we observe that a node demands input from its "boss" children while it sends output to its "follower" children. We thus rearrange the tree as in Figure~\ref{fig:rearrange-tree}, to make it so that long sequences of messages are sent upwards. We formalize this with the notion of altitude:



\begin{definition}
	We define the ""altitude"" of a node $\node$, written $\altitude{\node}$, in a "unfolding tree" recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$
		
		\item The altitude of a "boss node" is the altitude of its father minus one
		
		\item The altitude of a "follower node" is the altitude of its father plus one.
	\end{itemize}
\end{definition}

We now look at the highest nodes in the rearranged tree: those are "follower" nodes which do not have "follower" children themselves (with the possible exception of the root). Hence all they have to do is send one particular message (assuming they receive some required input over the same value). Hence we can bound their size by applying Lemma~\ref{lem:short-local-runs}\corto{fix}, hence also bounding the output they require.
Once we have bounded the node labels of maximal altitude, we can bound the ones just below: indeed, the nodes above only require a bounded amount of input, and there cannot be many of them as a node needs at most $\size{\messages}r$ "follower" children ($\size{\messages}$ for each initial value). Hence we can also bound the length of local runs at that level, and thus also the required input of those nodes.
We iterate this in the following lemma to get a bound on the size of a node depending on the difference between its altitude and the maximal one.


\begin{restatable}{lemma}{lemBoundLengthHeightH}
	\label{lem:bound-length-at-height-h}
	Let $\prot$ be a protocol, let $\node$ be a node of a "unfolding tree" of minimal size labelled by $\prot$ satisfying a "boss specification" $w$.
	Let $\altmax$ be the maximal "altitude" in $\tau$, let $N = \size{w} + \size{\prot} +r +1$ and let $f_0 : \nats \to \nats$ be the function mapping each $n \in \nats$ to $f_0(n)=(N^2 \towerfun(N,N))^{n+1}$, with $\towerfun$ the function defined in Lemma~\ref{lem:short-run-for-output}.
	
	\begin{itemize}
		\item If $\node$ is a "boss node" then $\size{\bosslabel{\node}} \leq f_0(\altmax - \altitude{\node})$ and $\size{\localrunlabel{\node}} \leq f_0(\altmax - \altitude{\node}+1)$.
		
		\item If $\node$ is a "follower node" then $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}} \leq f_0(\altmax - \altitude{\node}+1)$.
	\end{itemize} 
\end{restatable}

We now consider a branch reaching maximal altitude: we mark along that branch all the nodes that have a greater altitude than all the previous ones. They are necessarily "follower" nodes as "boss" nodes are below their father. Thanks to Lemma~\ref{lem:bound-length-at-height-h}, this sequence (reversed) is so that the $i$th term is at altitude $\altmax-i$ and we can bound its size with respect to $i$. Along with Lemma~\ref{lem:shortening-branches}, this allows us to apply the "Length function theorem" on that sequence to bound its length, hence the following result bounding the maximal altitude.

\begin{restatable}{lemma}{lemBoundMaxHeight}
	\label{lem:bound-max-height}
	There exists a function $f_1$ of the class $\Ffunction{\omega^{\size{\messages}}}$ such that for all "protocol" $\prot$, for all "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $w$, the maximal altitude of a node of $\tree$ is bounded by $f_1(\size{\prot} + \size{w}+1)$.
\end{restatable}

The bound on the maximal altitude, along with Lemma~\ref{lem:bound-length-at-height-h}, gives us a bound on the size of the root. 
By using a similar argument as for the maximal altitude, we consider a branch reaching minimal altitude to obtain a "bad" sequence of "boss" nodes and apply the "Length function theorem" again to bound the minimal altitude.

\begin{restatable}{lemma}{lemBoundMinHeight}
	\label{lem:bound-min-height}
	There exists a function $f_2$ of the class $\Ffunction{\omega^{\size{\messages}+1}}$ such that for all "protocol" $\prot$, for all "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $w$, the absolute value of the minimal "altitude" of a node of $\tree$ is bounded by $f_2(\size{\prot} + \size{w}+1)$.
\end{restatable}

With the bounds on the maximal and minimal altitudes, Lemma~\ref{lem:bound-length-at-height-h} yields a bound on the size of all nodes in the tree.

\ifproofs
\begin{proof}
	Consequence of Lemmas~\ref{lem:bound-length-at-height-h}, \ref{lem:bound-max-height} and \ref{lem:bound-min-height} as $\Ffunction{\omega^{\size{\messages}+1}}$ is closed by composition with elementary functions.
\end{proof}
\fi

Finally, as we now have a bound on all nodes, we can easily bound the length of branches and the number of children of all nodes to get abound on the total size of the tree.

\begin{restatable}{proposition}{PropBoundTreeSize}
	\label{prop:bound-tree-size}
	There exists a function $f_4$ of the class $\Ffunction{\omega^{\size{\messages}+1}}$ such that for all "protocol" $\prot$, for all "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $w$, the size of $\tree$ is bounded by $f_4(\size{\prot} + \size{w}+1)$.
\end{restatable}




\subsection{Decidability}
\label{sec:decidability-end}

We have shown that "unfolding trees" were a sound and complete abstraction for coverability in Section~\ref{sec:decidability-tree-unfoldings} and proven that there was a computable bound (of the class $\Ffunction{\omega^\omega}$) on the size of a minimal "unfolding tree" witnessing coverability, if it exists, in Sections~\ref{sec:local-bounds} and~\ref{sec:tree-bounds}. Essentially, we then obtain decidability of the problem via the procedure computing that bound and then enumerating all trees below that size, checking for each one of them whether it is a valid "unfolding tree" witnessing coverability. We are skipping some details here, which are treated in the proof in Appendix~\ref{app:decidability}

\decidablecover*


