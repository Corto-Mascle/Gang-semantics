\section{Bounded witnesses for reachability}

\ifintuition
\subsection{Intuition}

Our aim is to prove the decidability of the coverability problem for BNRA which can only send a single value in each broadcast. The constructions will actually lead us to a decidability proof for specifications of two different types, both subsuming the coverability specification.

\paragraph*{Step 1 : simplification} In Lemma~\ref{lem:simple-reduction} we prove that all protocols, even those which can apply several operations when receiving a broadcast, can be simulated by a protocol with a single operation upon reception of a message and no $*$ operation. A previous lemma already allowed us to remove $\diseqtestact$, thus we only have to prove decidability for systems with one operation per reception and only $\enregact$ and $\eqtestact$ operations.

Lemma~\ref{lem:simple-reduction} is placed within the decidability proof as the constructions defined there may simplify the proof of the lemma (they allow us to prove that BRNA can simulate each other simply by proving that their local runs have the same behaviour).

\paragraph*{Step 2 : run decomposition} Say we have a global run $\rho$ in which an agent broadcasts a message $m_f$. We isolate the local run $u$ of the first agent $a$ broadcasting $m_f$.
In order to execute $u$, we need to receive a sequence of broadcast that matches the sequence of receive transitions in $u$. Let $v$ be a value appearing in $u$.

\begin{itemize}
	\item 
	Say $v$ is not an initial value of $u$, let $w \in \messages^*$ be the sequence of broadcasts received by $a$ with value $v$ in $u$. Then the exact value $v$ does not matter, all $a$ needs is to receive a series of broadcasts with the messages of $w$ all with the same value. This is possible if and only if there exists a global run $\run'$ and a value $v'$ such that $w$ is a subword of the series of broadcasts made in that run with value $v'$. Indeed, if there exists such a run, then $u$ can receive selected broadcasts from $\rho'$ (happening in parallel) in order to get the sequence $w$ of messages with the same value. Conversely, if $u$ receives a sequence $w$ all with the same value in $\rho$, then the prefix of $\rho$ ending just before the broadcast of $m_f$ by $u$ is a fitting candidate for $\rho'$.
	We do not take $\rho$ directly as witness as we want the runs to get shorter as we make the recursive calls.
	
	Here we have our first type of specification, given as a word $w \in \messages^*$. We ask that there exists a global run and a value $v'$ such that $w$ is a subword of the sequence of broadcasts made in the global run with value $v'$.
	
	
	\item 	
	Now suppose $v$ is an initial value of $u$. This situation is very different as other processes need $a$ to send some messages with this value in order to be able to send it back to him.
	The key observation is that once an agent $a'$ other than $a$ has managed to broadcast some message $m$ with value $v$, we have an unlimited supply of such broadcasts:
	Let $w$ be the series of messages broadcast by $a$ with value $v$ before $a'$ makes that broadcast, we now know that there is a global run which, if presented with an external series of broadcasts $w$ with the same value, can then broadcast $m$ with that value.
	We then extend this reasoning and consider the series of broadcast made with value $v$ through $\run$. It can be decomposed as  $(w_0, m_1, w_1, \ldots, m_\ell, w_\ell)$ where $w_0 \cdots w_\ell$ is the sequence of broadcasts made by $a$ with that value and the $m_j$ are placed at the moments where another agent manages for the first time to broadcast that message (from then on we have unlimited supplies of broadcasts with that value and message $m_j$). In particular $\ell \leq \size{\messages}$.
	
	All we have to do is to check for all $j$ that there exists a global run in which some agent broadcasts $m_j$ with a value $v$ that is not one of its initial ones, while having received a series of external broadcasts $w'$ which is of the form $w'_0\cdots w'_{j-1}$ where each $w'_i$ is obtained by adding some letters from $\set{m_0, \ldots, m_i}$ in $w_i$.
	If we have such a run, then with the copycat property we can add an  agent that copies 
	
	This forms our second type of specification, given by a decomposition $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}, m_j)$, which asks for a run that broadcasts $m_j$ with some value $v'$ which it does not have initially, while receiving a series of  external broadcasts with value $v'$ that match $(w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
\end{itemize}   

We can decompose any run satisfying one of those specifications into a local run (the one of the agent having the value initially in the first case, the one of the first agent which manages to broadcast $m_j$ while not having the value initially in the second case) and some number of specifications satisfied by smaller runs.

Hence we can turn a global run satisfying a given specification into a finite tree where nodes are labelled by local runs and specifications of one of the two types above.

\subsection{Bounds on the size of the minimal decomposition}

The previous section provides witnesses for the satisfiability of specifications, in the form of a tree decomposition.

However it is not clear that there is any bound on the size of those trees.

To provide such bounds, we need several observations.
We say that a local run is cheaper than another one if the set of children it spawns in the decomposition tree is easier to achieve: every child of the first run is a subword of a child of the second one.

 First of all we use Lemma~\ref{lem:short-local-runs}, essentially stating that we can reduce any section of a local run of length more than $f(|\prot|)$, where $f$ is a primitive recursive function, to obtain a shorter and cheaper local run.
 This new run may broadcast less messages, thus we cannot say that every local run can be reduced to one of size $f(\size{\prot})$.
 However, we can say that if there exists a local run making some sequence of $N$ broadcasts, then there is one of size at most $Nf(\size{\prot})$, as we can reduce the sections of runs between those broadcasts.
 
 We now define a notion of altitude of a node, which is not the same as its depth in the tree. Intuitively we put the children of a node $n$ below it if $n$ has to receive messages from them (first case in the previous subsection) and above it if $n$ has to send messages to them (second case).
 The altitude of the root is $0$, and the altitude of a child of a node $n$  is  the one of $n$ minus one if it is of the first type of specification, plus one otherwise.
 
 Nodes of minimal altitude (except maybe the root) are nodes of the second type which only have children of the first type, hence all they have to do is broadcast one single message (given by their father). Hence their length is at most $f(\size{\prot})$. 
 
 Now assume we have a bound $M$ on runs of altitude $h$. A run of altitude $h-1$ sees at most $r$ different initial values. Hence it has at most $\size{\messages}r$ children of the second type, and for each corresponding specification it has to make at most $M$ broadcasts, as each of those children makes at most $M$ receiving actions.
 Moreover, if it is of the first type, it also has to provide broadcasts for its father, but again his father has altitude $h$, thus will require at most $M$ broadcasts.
 
 Overall a local run at altitude $h-1$ needs to make a series of at most $M(\size{\messages} r +1)$ broadcasts. If that can be done, it can be done by a local run of length at most $[M(\size{\messages} r +1)](f(\size{\prot})+1)$.
 
 As a result, we can bound the size of a node of altitude $h$ by $g(\size{\prot}, hmax-h)$, where $hmax$ is the maximal altitude of the tree and $g$ is a primitive recursive function.
 
 This allows us to bound $hmax$: indeed consider the branch reaching the highest point in the tree. Along that branch we can extract a sequence of nodes of the second type $\node_0, \ldots, \node_{hmax}$ such that $\node_i$ has altitude $i$ for all $i$. If there are some $i<j$ such that $\node_i$ and $\node_j$ produce the same broadcast but $\node_j$ is cheaper then we can reduce the branch.
 The bounds on the lengths of the $\node_i$ and the latter property allow us to bound $hmax$ with a function from the class $F_{\omega^k}$ with $k = \size{\Sigma} +1$ (see, for instance, \cite{SchmitzS2011upperHigman}).
 
 This also gives us a bound on the size of the root (which is also in $F_{\omega^k}$). From there we bound the minimal altitude of a node of this tree. The argument is that in order to reach a minimal altitude $hmin$ with a branch, we need to have along that branch a subsequence of nodes of the first type $\node_0, \ldots, \node_{-hmin}$ such that $\node_i$ has altitude $-i$. If there exist $i<j$ such that $\node_i$ broadcasts a subword of $\node_j$ we can reduce the branch. Otherwise, the same results on bad sequences of words  for the subword order allow us to bound the minimal altitude of a node in that tree with a function of $F_{\omega^k}$.
 As both the minimal and maximal altitudes in the tree are bounded by such functions, the size of a node of that tree is also bounded by such a function (using the bound on nodes based on their altitude). This is also a bound on the branching of the tree, as the number of children of a node is bounded by the number of values seen in its local run, thus by the size of that run.
 
 The number of different nodes along a branch is also bounded, hence also the size of that branch (if the same node appears twice we can reduce the branch).
 This lets us bound the overall size of the tree with a function of $F_{\omega^k}$, yielding decidability and complexity of the problem.

\subsection{Formal proof}
\fi


\textbf{For now we assume that the BRNA do not contain $*$ operations and apply only one operation for each message received. The general case reduces to this one (lemma \ref{lem:simple-reduction}).}

% \begin{definition}
% 	An ""external broadcast"" is a transition between two configurations $\config \extbr{m, v} \config'$ such that $m \in \messages$, $v \in \nats$ and for all $a \in \agents$, either $\config'(a) = \config(a)$ or there exists a transition $(\st{\config}(a),\rec{m}{j}{\anact},\st{\config'}(a))$
% 	such that $\data{\config'}(a, j') = \data{\config}(a, j')$ for all $j' \neq j$ and one of the following cases holds:
% 		\begin{itemize}
% 			\item $\anact = \quotemarks{\dummyact}$ 
% 			and $\data{\config'}(a,j) = \data{\config}(a,j)$
% 			\item $\anact = \quotemarks{\enregact}$ and $\data{\config'}(a,j) = v$
% 			\item $\anact = \quotemarks{\eqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) =v$
% 			\item $\anact = \quotemarks{\diseqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) \ne v$.
% 		\end{itemize}
\begin{definition}[Local runs]			
	A ""local configuration"" is a pair $(q, \localdata) \in Q \times ([1,r] \to \nats)$. Intuitively, it describes the configuration of a single agent. 

	An ""external broadcast"" from $(q,\localdata)$ to $(q',\localdata')$ with transtion $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans = (q,\rec{m}{j}{\anact},q') \in \transitions$
	such that $\localdata(j') = \localdata(j')$ for all $j' \neq j$ and one of the following cases holds:
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ when receiving a message of the right type with value $\aval$.

	An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transtion $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\atrans$ is either a "broadcast" or a "local test" and an agent in $(q,\localdata)$ may perform this transition in isolation and get to $(q',\localdata')$. 

	A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either an "external broadcast" or an "internal step". 
	A ""local run"" is a sequence $\localrun$ of "local steps" $(q_0, \nu_0) \step{\locallabel_1} (q_1, \nu_1) \step{\locallabel_2} \cdots \step{\locallabel_k} (q_k, \nu_k)$, where for all $i$, $\locallabel_i \in \set{\extlabel{\atrans}{\aval} \mid \atrans \in \transitions, \aval \in \nats} \cup {\intlabel{\atrans} \mid \atrans \in \transitions}$. The sequence $\locallabel_1, \dots, \locallabel_k$ is called ""schedule"" of $\localrun$.


	The ""input"" of a "local run" $\localrun$ is the sequence $\Input{\localrun} \in (\messages \times \nats)^*$ containing messages types and values of its "external broadcasts".
	Similarly, its ""output"", which we denote by $\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of (internal) broadcasts steps made in $\localrun$.
	
	Given a value $v \in \nats $, the $v$-input $\vinput{\aval}{\localrun} $(resp. the $v$-output $\voutput{\localrun}{\aval}$) of $\localrun$ is defined as the sequence of messages of $\Input{\localrun}$ (resp. $\Output{\localrun}$) that have value $\aval$. Formally, $\vinput{\aval}{\localrun}$ is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ on $\messages \times \set{\aval}$.  
	
	
%	Its ""trace"" $\trace{u} \in Op^\messages_r$ is the sequence of operations executed by $u$.
	
	% A ""partial run"" is a sequence of configurations $\config_0 \cdots \config_k$  such that for all $i \in [1, k]$, either $\config_{i-1} \step{} \config_{i}$ or $\config_{i-1} \extbr{m, v} \config_{i}$ for some $m \in \messages$, $v\in \nats$. 

	% We define a preorder on "partial runs":
	% Given $\run, \run'$, $\run \unlhd \run'$ if for all $v \in \nats$, there exists $v' \in \nats$ such that $\vinput{v}{\run}$ is a subword of $\vinput{v}{\run'}$.
%	\cortoin{TO READ OVER}
\end{definition}

A key ingredient of our construction is the decomposition of words of messages. Say we have an execution and a value $v$ such that the sequence of messages broadcast in that execution with value $v$ is $w$. Let $w'$ the subword of $w$ of messages sent by the agent $a$ which had that value originally. Let $m$ be the first message sent by another agent with value $v$. This means that from the messages sent by $a$ before there is a set of agents that receives some of these messages and eventually sends back message $m$ with value $v$. An important remark is that we can copy this set of agents many times to obtain as many broadcasts with message $m$ and value $v$ as we want from this point in the run.

In general, if an agent other than $a$ sends a message with value $v$ then we can add agents to obtain that message with that value as many times as we want.
Therefore, we will describe the sequences of messages sent with a value $v$ as tuples $(w_0, m_1, \ldots, m_\ell, w_\ell)$, where $w_0 \cdots w_\ell$ is the sequence of messages sent by the agent $a$ which has that value initially and the $m_i$ mark, for every message of $\messages$ the first moment at which some agent other than $a$ broadcasts it with value $v$ (if that happens).

\begin{definition}
	A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. The set of decompositions over $\messages$ is denoted $\decset{\messages}$.
	
	We say that a word $w \in \messages^*$ ""decomposes as"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w = w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding some letters from $\set{m_1, \ldots, m_{j-1}}$.
	
	The language $\langdec{\decsymb}$ of $\decsymb$ is the set of words that decompose as $\decsymb$. We write $\langdecdown{\decsymb}$ for the subword closure of $\langdec{\decsymb}$.
	
	We define a preorder on decompositions:
	$\decsymb \subword \decsymb'$ if $\langdecdown{\decsymb} \subseteq \langdecdown{\decsymb'}$.
\end{definition}


\begin{definition}
	\label{def:tree-unfolding}
	A ""tree unfolding"" $\tree$ over a "protocol" $\prot$ is
	a finite tree where each node $\node$ has three labels:
	\begin{itemize}
		\item The first one is a local run of $\prot$, written $\localrunlabel{\node}$. 
		
		\item The second one is a value, written $\valuelabel{\node}$.
		
		\item The third one is a ""specification"" $\speclabel{\node}$, which is either a word $\bosslabel{\node} \in \messages^*$ (boss specification) or a pair $(\followlabelword{\node}, \followlabelmessage{\node}) \in \messages^* \times \messages$ (follower specification). In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"".
	\end{itemize} 
	
	It must satisfy the following conditions, where $\aval := \valuelabel{\node}$ and $\localrun := \localrunlabel{\node}$.

	\begin{itemize}
		\item[C1\namedlabel{unfoldingC1}{C1}] If it is a "boss node" then:
		\begin{itemize} 
			\item $\aval$ is an initial value of $\localrun$, 
			\item $\bosslabel{\node}$ decomposes as $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$, 
			\item $\localrun$ may be split into sucessive "local runs" $\localrun_0, \dots, \localrun_{\ell}$ where, for all $i \in \nset{1}{\ell}$, $\voutput{\aval}{\localrun_i} \subword w_i$ and $\vinput{\aval}{\localrun_i} \in \set{m_0, \dots, m_{i-1}}^*$, and
			\item  for all $i \in [1,\ell]$, $\node$ has a child $\node_i$ which is a "follower node" such that $\followlabelmessage{\node_i} = m_i$ and $\followlabelword{\node_i} \in\langdecdown{\decsymb_i}$ where $\decsymb_i = (w_0, m_1, w_1, \ldots, m_{i-1}, w_{i-1})$.
		\end{itemize}
		\item[C2\namedlabel{unfoldingC2}{C2}] If $\node$ is a "follower node" then $\aval$ is not an initial value of $\localrun$, $\vinput{\aval}{\localrun} = \followlabelword{\node}$ and 
		$\voutput{\aval}{\localrun}$ contains $\followlabelmessage{\node}$.
		
		\item[C3\namedlabel{unfoldingC3}{C3}] In both cases, for all value $\aval' \neq \aval$ broadcast or received at some point in $\localrunlabel{\node}$, one of the two following conditions is satisfied:
		\begin{itemize}
			\item[C3.1\namedlabel{unfoldingC3.1}{C3.1}]
			 $\aval$ is an initial value of $\localrun$, 
			there exists $\decsymb' = (w'_0, m'_1, w'_1, \ldots, m'_{\ell'}, w'_{\ell'})$, s.t. $\localrun$ may be split into sucessive "local runs" $\localrun'_0, \dots, \localrun'_{\ell}$ where, for all $i \in \nset{1}{\ell'}$, $\voutput{\aval'}{\localrun'_i} \subword w'_i$ and $\vinput{\aval'}{\localrun'_i} \in \set{m'_0, \dots, m'_{i-1}}^*$, and
			for all $i \in [1,\ell']$, $\node$ has a child $\node'_i$ which is a "follower node" such that $\followlabelmessage{\node'_i} = m'_i$ and $\followlabelword{\node'_i} \in\langdecdown{\decsymb'_i}$ where $\decsymb'_i = (w'_0, m'_1, w'_1, \ldots, m'_{i-1}, w'_{i-1})$.
			%  If $\aval'$ is an initial value of $\localrun$ then there exists a "decomposition" $\decsymb' = (w'_0, m'_1, w'_1, \ldots, m'_k, w'_k)$ 
			% where $w'_0 w'_1 \ldots w'_k = \voutput{\aval'}{\localrunlabel{\node}}$, for all $j \in [1,k]$ all receptions of $m'_j$ with value $\val'$ in $u$ happen after the broadcasts of $w'_0\cdots w'_{j-1}$ with value $\val'$, and for all $j \in [1,k]$ $\node$ has a child $\node'$ which is a "follower node" such that $\followlabelmessage{\node'} = m'_j$ and $\followlabelword{\node'} \in\langdecdown{\decsymb'_j}$ where $\decsymb'_j = (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.  
			
			\item[C3.2\namedlabel{unfoldingC3.2}{C3.2}] If $\aval'$ is not an initial value of $\localrun$ then $\node$ has a child $\node'$ which is a "boss node" such that $\vinput{\aval'}{\localrun}$ is a subword of $\bosslabel{\node'}$.
		\end{itemize}
	\end{itemize}
	
	
\end{definition}

%Old def

%\begin{definition}
%	\label{def:tree-unfolding}
%	A ""tree unfolding"" is
%	a finite tree where each node has three labels:
%	\begin{itemize}
%		\item The first one is a local run of $\prot$. 
%		
%		\item The second one is a value $v \in \nats$.
%		
%		\item The third one is a ""specification"", which is either a word $bw \in \messages^*$ or a pair $(fw, fm)$ with $fm \in \messages$ and $fw \in \messages^*$ a "decomposition". In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"". 
%	\end{itemize} 
%	
%	It must satisfy the following conditions:
%	Let $\node$ be a node of that tree, and $u$ and $v$ the local run and value labelling it. The following conditions must hold:
%	
%	\begin{itemize}
%		\item[C1\namedlabel{unfoldingC1}{C1}] If it is a "boss node" labelled by $w \in \messages^*$ then $v$ is an initial value of $u$ and there exists a decomposition $\decsymb = (w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$ such that
%		$w_0 \cdots w_\ell$ is the $v$-output of $u$, $w \in \langdec{\decsymb}$, and for all $j \in [1,\ell]$, $\node$ has a child which is a "follower node" with a label $\decsymb \subword ((w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j)$.
%		
%		\item[C2\namedlabel{unfoldingC2}{C2}] If it is a "follower node" labelled $(\decsymb, m)$ then $v$ is not an initial value of $u$, the $v$-input of $u$ is in $\langdec{\decsymb}$, and $m$ is broadcast at some point in $u$ with value $v$.
%		
%		\item[C3\namedlabel{unfoldingC3}{C3}] In both cases, for all $v' \neq v$ broadcast or received at some point in $u$,
%		\begin{itemize}
%			\item[C3.1\namedlabel{unfoldingC3.1}{C3.1}] If $v'$ is an initial value of $u$ then there exists a "decomposition" $\decsymb' = (w'_0, m'_1, w'_1, \ldots, m'_k, w'_k)$ where $w'_0 w'_1 \ldots w'_k$ is the $v'$-output of $u$, for all $j \in [1,k]$ all receptions of $m_j$ with value $v'$ in $u$ happen after the broadcasts of $w'_0\cdots w'_{j-1}$ with value $v'$, and for all $j \in [1,k]$ $\node$ has a child which is a "follower node" with a label $\decsymb \subword ((w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1}), m_j)$.  
%			
%			\item[C3.2\namedlabel{unfoldingC3.2}{C3.2}] If $v'$ is not an initial value of $u$ then $\node$ has a child which is a "boss node" labelled by $w'$ such that $\vinput{v}{u}$ is a subword of $w'$.
%		\end{itemize}
%	\end{itemize}
%	
%	
%\end{definition}


%\begin{remark}
% The conditions \ref{unfoldingC1}, \ref{unfoldingC2} and \ref{unfoldingC3} defined in Definition~\ref{def:tree-unfolding} only depend on the
%\end{remark}


\begin{definition}
	A "run" $\run$ satisfies a boss specification $\bossspec$ if there exists $\aval \in \nats$ such that $\bossspec$ is the sequence of messages sent with value $\aval$ through $\run$.
	
	A "run" $\run$ satisfies a follower specification $(\followwordspec, \followmessagespec)$ if there exists a value $\aval$ and an agent $a$ such that $\aval$ is not an initial value of $a$, the $\aval$-input of $a$ in $\run$ is $\followwordspec$ and agent $a$ broadcasts $\followmessagespec$ with value $\aval$ at some point.
	
	A "tree unfolding" satisfies a boss specification $\bossspec$ if its root $\node$ is a "boss node" and $\bossspec$ is a subword of its specification label $\bosslabel{\node}$.
	A "tree unfolding" satisfies a follower specification $(\followwordspec, \followmessagespec)$ if its root $\node$ is a "follower node" such that $\followmessagespec=\followlabelmessage{\node}$ and  $\followlabelword{\node}$ is a subword of $\followwordspec$.
\end{definition}

We will now prove that there exists a run satisfying a specification if and only if there exists a finite tree satisfying that same specification. To do so, we will build a tree from a run and conversely.


Also note that the interpretation of the "follower nodes" changes between the two directions: when building the tree a follower node labelled $(\followwordspec, \followmessagespec)$ means that there exists a global run in which some agent receives the sequence of messages $\followwordspec$ and broadcasts $\followmessagespec$, all with a value $\aval$ that is not one of its initial ones.
\nico{pas clair}

When building the run a follower node means that there exists a "partial run" which receives a series of external broadcasts which forms the word $fw$, with a value $v$ that it initially does not contain, and eventually broadcasts $m$ with that same value.

\begin{lemma}
	\label{lem:run-to-tree}
	Let $\prot$ be a protocol.
	If there exists a finite run $\run$ of $\prot$ satisfying some "specification" $\spec$ then there exists a finite "tree unfolding" $\tree$ labelled with local runs of $\prot$ satisfying $\spec$. \nico{pourquoi label par $\prot$?}
\end{lemma}

\ifproofs
\begin{proof}
	
	We proceed by strong induction on the lexicographic order on $\nats \times \set{boss, follower}$ with the length of $\run$ as the first component and the type of specification as the second, "boss" being considered higher than "follower". 
	
	Let $\run$ be a run, $spec \in \messages^* \cup \decset{\messages}$ a specification, assume the property is satisfied for all lower pairs of runs and specifications. We construct a root and attach subtrees to it so that conditions \ref{unfoldingC1} to \ref{unfoldingC3} are satisfied 
	
	We split our construction in four parts. The first part applies if $spec$ is a "boss specification", the second one if $spec$ is a "follower specification". 
	Those parts construct a local run $u$ and a value $v$, as well as the root and some children so that conditions \ref{unfoldingC1} and \ref{unfoldingC2} are satisfied.
	
	The third and fourth part construct children so that \ref{unfoldingC3.1} and \ref{unfoldingC3.2} are satisfied, respectively.
	
	\textbf{Case 1: The specification is a "boss specification"}
	
	Assume $spec$ is a "boss specification" $spec = w \in \messages^*$.
	There exists a value $v$ such that $w$ is a subword of the sequence of messages broadcast with value $v$ through $\run$. Let $w'$ be the latter sequence.
	If $w$ is empty then the tree decomposition with one node labelled with an empty local run, any value and $w$ satisfies $w$.	
	
	Otherwise let $a$ be the agent which has $v$ as an initial value, let $u$ be its local run in $\run$. We set $u$, $v$ and $w'$ to be the labels of the root of the tree unfolding we are constructing.
	We decompose $w'$ as $(w'_0, m_1, w'_1, \ldots, m_\ell, w'_\ell)$, where $w'_0\cdots w'_\ell$ is the sequence of messages broadcast by $a$ with value $v$, and the $(m_j)_{1\leq j\leq \ell}$ are the elements of $\messages$, placed at the times at which they are first broadcast by an agents other than $a$ with value $v$. If there is no such broadcast of a message $m$, then it does not appear as an $m_j$. This forms a "decomposition" of $w'$.
		
	For all $1 \leq j \leq \ell$ let us write $\decsymb_j$ for the "decomposition" $(w'_0, m_1, w'_1, \ldots, m_{j-1}, w'_{j-1})$. Let $\run_j$ be the prefix of $\run$ up until the first broadcast of $m_j$ with $v$ by some agent $a$ that does not have $v$ as an initial value, and let $\run'_j$ be $\run_j$ without that last step. By definition of $\decsymb$, the sequence of broadcasts with value $v$ in $\run'_j$ "decomposes as" $\decsymb_j$.
	In particular, the $v$-input of $a$ before it broadcasts $m_j$ with $v$ must decompose as $\decsymb_j$.
	 
	Hence $(\decsymb_j, m_j)$ is a "follower specification" satisfied by $\run_j$, which has a length smaller or equal to the one of $\run$. By induction hypothesis (recall that we make our induction on the length of $\run$ and on the type of specification), there is a "tree unfolding" satisfying it.
	
	We put that "tree unfolding" as a child of our root, hence we satisfy \ref{unfoldingC1}. We satisfy \ref{unfoldingC2} as the root we constructed is not a "follower node".
	
	\textbf{Case 2: The specification is a "follower specification"} 
	
	Assume $\spec$ is a "follower specification" $\spec = \decsymb \in \decset{\messages}$. 
	There exists a value $v$, an agent $a$ and a decomposition $\decsymb' \in \decset{\messages}$ such that $\decsymb \subword \decsymb'$ and the $v$-input of the local run $u$ of $a$ decomposes as $\decsymb'$. 
	
	We set our root to have as labels $u$, $v$ and $\decsymb'$, thus satisfying \ref{unfoldingC2}. We satisfy \ref{unfoldingC1} as the root is not a "boss node".
	
	\textbf{In both cases}
	
	We have constructed an agent $a$ and a value $v$ and set our root to be labelled by the local run $u$ of $a$ and $v$, and added children to that root so that conditions \ref{unfoldingC1} and \ref{unfoldingC2} are satisfied. We will now add some more children to satisfy condition \ref{unfoldingC3}.
	
	We can assume that the last step of $\run$ is a broadcast of a message with value $v$, as otherwise we can erase its last step to get a run that still satisfies the specification, but has a smaller length than $\run$, hence we can apply the induction hypothesis.
	
	Let $v' \neq v$ be a value broadcast or received in $u$. 
	
	\begin{itemize}
		\item If $v'$ is an initial value of $u$ then let $w'$ be the $v'$-"output" of $u$. Let $\decsymb' = (w'_0, m_1, w_1, \ldots, w'_k)$ be such that $w' = w'_0 \cdots w'_k$ and the $m_i$ mark the first time another agent sends each message of $\messages$ with value $v'$ in $\run$.  
		
		For all $j \in [1,k]$, all receptions of $m_j$ with value $v'$ in $u$ must happen after another agent has managed to broadcast it, hence after broadcasts of $w'_0 \cdots w'_{j-1}$ with value $v'$ have happened in $u$, by definition of $\decsymb'$.
		
		Let $j \in [1,k]$, let $a_j$ be the first agent other than $a$ to broadcast $m_j$ with value $v'$, and let $\run_j$ be the prefix of $\run$ up until that broadcast. The $v'$-input of $a_j$ in $\run_j$ is a subword of the sequence of messages broadcast with value $v'$ in $\run_j$, which decomposes as $\decsymb_j = (w'_0, m_1, w_1, \ldots, w'_{j-1})$.
		
		As the last step of $\run$ is a broadcast of $v$ and $v' \neq v$, all $\run_j$ are shorter than $\run$. Furthermore for all $j$, $\run_j$ satisfies the specification $(\decsymb_j, m_j)$.		
		
		By induction hypothesis, for all $j$ there exists a "tree unfolding" satisfying $(\decsymb_j, m_j)$. We add all those trees as children of our root.
		
		\item If $v'$ is not an initial value of $u$ then let $w'$ be the $v'$-input of $u$. 
		 As $\run$ ends with a broadcast of $v$ and $v' \neq v$, we can remove the last step of $\run$ to obtain a run $\run'$. As $w'$ is a subword of the sequence of messages broadcast in $\run$ with value $v'$, it is also the case for $\run'$.
		 Hence $\run'$ satisfies $w'$ as a specification, and has smaller length than $\run$. By induction hypothesis, there is a "tree unfolding" satisfying $w'$. We add it as a child of our root.
	\end{itemize}
	
	We added some "tree unfoldings" as children of the root so that conditions \ref{unfoldingC1} to \ref{unfoldingC3} are satisfied. We obtain a "tree unfolding" satisfying the specification.
\end{proof}
\fi



\begin{restatable}{lemma}{LemTreeToRun}
	\label{lem:tree-to-run}
	Let $\prot$ be a "protocol".
	If there exists a finite "tree unfolding" labelled by local runs of $\prot$ satisfying a "boss specification" $bw \in \messages^*$ then there exists  a finite "run" $\run$ of $\prot$ satisfying $bw$.
\end{restatable}

The proof can be found in the appendix.


\begin{lemma}
	\label{lem:local-to-global}
	If two protocols $\prot_1, \prot_2$ are such that for all local run $u_1$ of $\prot_1$, there is a local run $u_2$ of $\prot_2$ with the same initial values as $u_1$ and such that $\Input{u_1} = \Input{u_2}$ and $\Output{u_1} = \Output{u_2}$, then for all "boss specification" $bw \in \messages^*$, if $\prot_1$ has a run satisfying $\spec$ then so does $\prot_2$.
\end{lemma}
\ifproofs
\begin{proof}
	We infer this statement from the "tree unfoldings".
	
	Suppose $\prot_1$ satisfies a specification $\spec$, then by Lemma~\ref{lem:run-to-tree} there exists a "tree unfolding" $\tree_1$ labelled by local runs of $\prot_1$ satisfying $\spec$. 
	
	Let $\node$ be a node of $\tree_1$ labelled by a "local run" $u_1$ of $\prot_1$, a value $v$ and a "specification" $\spec$.  
	
	There exists a "local run" $u_2$ of $\prot_2$ with the same initial values, "input" and "output" as $u_1$. In particular they have the same $v$-input and $v$-output.
	
	We define $\tree_2$ as the tree obtained by replacing in the label of each node the local run of $\prot_1$ by a local run of $\prot_2$ with the same initial values, "input" and "output". The rest of the labels stays the same.
	
	Conditions \ref{unfoldingC1}, \ref{unfoldingC2} and \ref{unfoldingC3} are still satisfied on every node as they only talk about the initial values, "input" and "output" of each local run label, and the value and specification labels. None of those things have changed.
	Furthermore as the specification label of the root is the same for $\tree_1$ and $\tree_2$, $\tree_2$ satisfies $\spec$.
	
	By Lemma~\ref{lem:tree-to-run}, as $\spec$ is a "boss specification", there exists a "run" of $\prot_2$ satisfying $\spec$.
\end{proof}
\fi


\begin{lemma}
	\label{lem:simple-reduction}
	For all "protocol" $\prot$ there is a "simple protocol" $\prot'$ with one more register satisfying the same "boss specifications".
\end{lemma}
\ifproofs
\begin{proof}
	
	We construct $\prot'$ as follows: It has one more register than $\prot$, but stores in its state the current state of $\prot$ and a mapping $map : [1,r] \to [1,r+1]$ from registers of $\prot$ to its own registers.
	
	Intuitively, it is going to use its registers to store the different values that are in the registers of $\prot$, and the mapping to keep track of which registers contain which values.
	When a value is received it guesses whether it is one of the existing values or a fresh one, and updates the registers and the mapping accordingly.
	The extra register of $\prot'$ is not necessary, but simplifies the proof.
	We will first define a system with $\varepsilon$-transitions (transitions with no effect), which we will then eliminate. 
	
	
	Formally, we set $\prot = (Q, \messages, \Delta, q_0)$.
	The set of states of $\prot'$ is $Q \times ([1,r] \to [1,r])$, its initial state is $(q_0, id)$ where $id(i) = i$ for all $i \in [1,r]$. 
	
	There is a transition $(q, map) \xrightarrow{op} (q', map')$ in the following cases:
	
	\begin{itemize}
		\item $op = \br{m}{j}$ 
		$map = map'$ and $\prot$ has a transition $q \xrightarrow{\br{m}{i}} q'$ with $map(i)=j$.
		
		\item $op=\rec{m}{j}{\enregact}$ and $map^{-1}(j) =\emptyset$ and either
		\begin{itemize}
			\item there is a transition $q \xrightarrow{\rec{m}{i_0}{\enregact}} q'$ in $\prot$ such that for all $i \in [1,r]$, $map'(i) = map(i)$ if $i \neq i_0$ and $map'(i_0) = j$.
			
			\item or there is a transition $q \xrightarrow{\rec{m}{i_0}{\dummyact}} q'$ in $\prot$ and for all $i \in [1,r]$, $map'(i) = map(i)$.
		\end{itemize}
		
		\item $op = \rec{m}{j}{\eqtestact}$ and either
		\begin{itemize}
			\item there is a transition $q \xrightarrow{\rec{m}{i}{\eqtestact}} q'$ in $\prot$ such that $map(i)=j$ and $map'=map$.
			
			\item there is a transition $q \xrightarrow{\rec{m}{i_0}{\enregact}} q'$ in $\prot$ and $map'(i_0)=j$ and $map'(i) = map(i)$ for all $i \neq i_0$.
		\end{itemize} 
		
		\item $op = \rec{m}{j}{\diseqtestact}$ and there is a transition $q \xrightarrow{\rec{m}{i}{\diseqtestact}} q'$ in $\prot$ such that $map(i)=j$
		
		\item $op=\loc{j_1}{j_2}{\diseqtestact}$ and there is a transition $q \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} q'$ in $\prot$ such that $map(i_1)=j_1$ and $map(i_2) = j_2$.
	\end{itemize}

	
	We define the relation $\xrightarrow{\varepsilon}$ as $(q, map) \xrightarrow{\varepsilon} (q', map')$ if and only if $map=map'$ and there is a transition $q \xrightarrow{\loc{i_1}{i_2}{\eqtestact}} q'$ in $\prot$ such that $map(i_1)=map(i_2)$.
	Let $\xrightarrow{\varepsilon}^*$ be its transitive closure.
	
	For all transitions $(q,map) \xrightarrow{op} (q', map')$ we add transitions $(q,map) \xrightarrow{op} (q'', map'')$ for all $q'', map''$ such that $(q', map') \xrightarrow{\varepsilon}^* (q'', map'')$, to obtain $\prot'$.
	
	We prove by induction on $\size{u}$ that for all "local run" $u$ of $\prot$ there exists a "local run" $u'$ of $\prot'$ with the same "trace" and such that if the last configuration of $u$ is $(q,\nu)$ and the last configuration of $u'$ is $((q',map), \nu')$ then $(q', map') \xrightarrow{\varepsilon}^* (q, map')$, for all $i$, $\nu(i) = \nu'(map(i))$ and for all $i_1, i_2$, if $\nu(i_1)=\nu_{i_2}$ then $map(i_1) = map(i_2)$.  
	
	If $\size{u} = 0$, let $(q_0, \nu_0)$ be its initial configuration, then we simply set $u'$ as an empty "local run" with the initial configuration $((q_0, id), \nu'_0)$ where $\nu'_0(i) = \nu_0(i)$ for all $i \in [1,r]$ and $\nu_0(r+1)$ is a fresh value.
	
	If $\size{u}>0$, let $\Tilde{u}$ be $u$ without its last step. Let $(q, \nu)$ be the last "local configuration" of $u$, $(\Tilde{q}, \Tilde{\nu})$ the one of $\Tilde{u}$.
	
	By induction hypothesis there exists $\Tilde{u}'$ a local run of $\prot'$ with the same "trace" to a "local configuration" $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$ such that $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and for all $i \in [1,r]$, $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i)$.
	
	\begin{itemize}
		\item 
		If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\br{m}{i}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\br{m}{j}} (q, \Tilde{map}')$ with $j=\Tilde{map}'(i)$.
		
		We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\br{m}{j}} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$, $map' = \Tilde{map}'$ and $\nu' = \Tilde{\nu}'$. 
		This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\br{m}{j}} (q, \Tilde{map}')$.   
		
		The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, $\Tilde{map'} = map'$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,\Tilde{\nu}'(\Tilde{map}'(i)),out) = \trace{\Tilde{u}} (m,\Tilde{\nu}(i),out) = \trace{u}$.
		
		\item 
		If the last step of $u$ is an "external broadcast" $(\Tilde{q}, \Tilde{\nu}) \extbr{m, v} (q, \nu)$ then let $j\in [1,r+1]$ be such that $\Tilde{map}'^{-1}(j) = \emptyset$ (such a $j$ exists as $\size{map([1,r])} = r < r+1$). There is a transition $\Tilde{q} \xrightarrow{\rec{m}{i_0}{\alpha}} q$ in $\prot$ such that $\nu(i)=\Tilde{\nu}(i)$ for all $i\neq i_0$ and we are in one of the following cases:
		
		\begin{itemize}
			\item $\alpha=\enregact$, $\nu(i_0) = v$ and there exists $i_1 \neq i_0$ such that $\nu(i_1) = v$. Let $j_1=\Tilde{map}'(i_1)$
			There is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j_1}{\eqtestact}} (q, map')$ in $\prot'$ with $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and $map'(i_0) = j_1$.
			
			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j_1}{\eqtestact}} (q', map')$. 
			
			 We have $(q', map') = (q, map')$, $\nu'(map'(i_0)) = v = \nu(i_0)$ and $\nu'(map'(i)) = \Tilde{\nu}'(map'(i)) = \Tilde{\nu}(i) = \nu(i)$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			 Furthermore for all $i', i'' \in [1,r]\setminus\set{i_0}$, if $\nu(i') = \nu(i'')$ then $map'(i') = \Tilde{map}'(i') = \Tilde{map}'(i'') = map'(i'')$, and for all $i' \in [1,r]$, if $\nu(i')=\nu(i_0)$ then $\nu(i')=\nu(i_1)$ and thus $map'(i') = map'(i_1) = map'(i_0)$.
			 Thus the resulting $u'$ satisfies the conditions
			
			\item $\alpha=\enregact$, $\nu(i_0) = v$ and for all $i_1 \neq i_0$, $\nu(i_1) \neq v$. 
			There is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q, map')$ in $\prot'$ with $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and $map'(i_0) = j$.
			
			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu'(j') = \Tilde{\nu}'(j')$ for all $j' \neq j$ and $\nu'(j) = v$.
			
			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q', map')$. 
			
			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, we have $\nu'(map'(i_0)) = v = \nu(i_0)$ and $\nu'(map'(i)) = \Tilde{\nu}'(map'(i)) = \Tilde{\nu}(i) = \nu(i)$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
			\item $\alpha = \eqtestact$, $\nu(i_0) = \Tilde{\nu}(i_0) = v$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\eqtestact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$ and $j = \Tilde{map}'(i_0)$.
			
			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
			This step can be taken as $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i) = v$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\eqtestact}} (q', map')$.
			
			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
			\item $\alpha = \diseqtestact$ and $\nu(i_0) = \Tilde{\nu}(i_0) \neq v$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\diseqtestact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$ and $j = \Tilde{map}'(i_0)$.
			
			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
			This step can be taken as $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i) \neq v$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\diseqtestact}} (q', map')$.
			
			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$.
			
			\item $\alpha = \dummyact$ and $\nu(i_0) = \Tilde{\nu}(i_0)$. Then there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q, map')$ in $\prot'$ with $map' = \Tilde{map}'$.
			
			We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$ and $\nu' = \Tilde{\nu}'$.
			
			This step can be taken as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j}{\enregact}} (q', map')$.
			
			The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$, the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$, and $\trace{u'} = \trace{\Tilde{u}'} (m,v,in) = \trace{\Tilde{u}} (m,v,in) = \trace{u}$. 
		\end{itemize}
		
	\item 
	If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\eqtestact}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\varepsilon} (q, \Tilde{map}')$.
	
	We set $u' = \Tilde{u}'$. The last configuration of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$. It satisfies the conditions as $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}') \xrightarrow{\varepsilon} (q, \Tilde{map}')$ and the final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$.
		
	\item 
	If the last step of $u$ is $(\Tilde{q}, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} (q, \nu)$ then $\Tilde{\nu} = \nu$, and there is a transition $(\Tilde{q}, \Tilde{map}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} (q, \Tilde{map}')$ with $j_1=\Tilde{map}'(i_1)$ and $j_2=\Tilde{map}'(i_2)$.
	
	We add a step $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} ((q', map'), \nu')$ at the end of $\Tilde{u}'$ to obtain $u'$, where $q' = q$, $map' = \Tilde{map}'$ and $\nu' = \Tilde{\nu}'$. 
	This step can be taken as $\Tilde{\nu}'(j_1) = \Tilde{\nu}(i_1) \neq \Tilde{\nu}(i_2) = \Tilde{\nu}'(j_2)$ and $(\Tilde{q}', \Tilde{map}') \xrightarrow{\varepsilon}^* (\Tilde{q}, \Tilde{map}')$ and $(\Tilde{q}, \Tilde{map}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} (q, \Tilde{map}')$.   
	
	The resulting $u'$ satisfies the conditions as $(q', map') = (q, map')$ and the "traces" and final configurations of $u$ and $u'$ are the same as the ones of $\Tilde{u}$ and $\Tilde{u}'$.
\end{itemize}
	
	This concludes our first induction.
	
	We now prove by induction on $\size{u'}$ that for all "local run" $u'$ of $\prot'$ there exists a "local run" $u$ of $\prot$ with the same "trace" and such that if the last configuration of $u$ is $(q,\nu)$ and the last configuration of $u'$ is $((q',map), \nu')$ then $q=q'$ and for all $i$, $\nu(i) = \nu'(map(i))$.  
	
	If $\size{u'} = 0$, let $(q_0, \nu'_0)$ be its initial configuration, then we  set $u$ as an empty "local run" with the initial configuration $((q_0, id), \nu_0)$ where $\nu_0(i) = \nu'_0(i)$ for all $i \in [1,r]$.
	
	If $\size{u}>0$, let $\Tilde{u}'$ be $u'$ without its last step. Let $((q', map'), \nu')$ be the last "local configuration" of $u'$, $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}')$ the one of $\Tilde{u}'$.
	
	By induction hypothesis there exists $\Tilde{u}$ a local run of $\prot$ with the same "trace" as $u'$ to a "local configuration" $(\Tilde{q}, \Tilde{\nu})$ such that $\Tilde{q}'=\Tilde{q}$ and for all $i \in [1,r]$, $\Tilde{\nu}'(\Tilde{map}'(i)) = \Tilde{\nu}(i)$.
	
	\begin{itemize}
		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\br{m}{j}} ((q', map'), \nu')$, then $\Tilde{map}' = map'$ and there exists $q \in Q$ and $i \in [1,r]$ such that $map'(i)=j$ and $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\br{m}{i}} q'$ is a transition of $\prot$.
		
		As $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, there is a path in $\prot$ from $\Tilde{q}$ to $q$ consisting only of transitions labelled by operations of the form $\loc{i_1}{i_2}{\eqtestact}$ with $\Tilde{map}'(i_1) = \Tilde{map}'(i_2)$ and thus $\Tilde{\nu}(i_1) = \Tilde{\nu}(i_2)$.
		As a result, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
		
		We then append a step $(q, \Tilde{\nu}) \xrightarrow{\br{m}{i}} (q', \nu)$ at the end of that local run to obtain $u$. As $j = map(i)$, we have $\Tilde{\nu}(i) = \Tilde{\nu}'(j)$ and thus $\trace{u} = \trace{\Tilde{u}}(m, \Tilde{\nu}(i), out) = \trace{\Tilde{u}'}(m, \Tilde{\nu}'(j), out) = \trace{u'}$.
		
		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \extbr{m, v} ((q', map'), \nu')$, then there exists a transition  $(\Tilde{q}', \Tilde{map}') \xrightarrow{\rec{m}{j_0}{\alpha}} (q', map')$ and $i_0 \in [1,r]$ such that $map'(i) = \Tilde{map}'(i)$ for all $i\neq i_0$ and we are in one of the following cases:
		
		\begin{itemize}
			\item $\alpha = \enregact$ and $\nu'(j_0)=v$. Then there exists $q \in Q$ and $i \in [1,r]$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\beta}} q'$ is a transition of $\prot$
			
			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
			
			We have either
			\begin{itemize}
				\item $\beta=\enregact$ and $map'(i_0) = j_0$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu(i_0)=v$ and $\nu(i) = \Tilde{\nu}(i)$ for all $i \neq i_0$.
				
				\item $\beta=\dummyact$ and $map' = \Tilde{map}'$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu = \Tilde{\nu}$.
			\end{itemize}
			
			\item $\alpha = \eqtestact$ and $map'(i_0)=\Tilde{map}'(i_0)$ and $\nu'(j_0) = \Tilde{\nu}'(j_0) = v$. Then there exists $q \in Q$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\beta}} q'$ is a transition of $\prot$.
			
			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same  "trace" as $\Tilde{u}$.
			
			We have either
			\begin{itemize}
				\item $\beta=\eqtestact$ and $map' = \Tilde{map}'$ and $\Tilde{\nu}(i_0) = v$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu = \Tilde{\nu}$.
				
				\item $\beta=\enregact$. Then we add a step $(q, \Tilde{\nu}) \extbr{m,v} (q', \nu)$ at the end of the constructed local run to obtain $u$, with $\nu(i_0) = v$ and $\nu(i)=\Tilde{\nu}(i)$ for all $i \neq i_0$.
			\end{itemize}
			
			\item $\alpha = \diseqtestact$ and $map'(i_0)=\Tilde{map}'(i_0) \neq v$. Then there exists $q \in Q$ and $i_0 \in [1,r]$ such that $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\rec{m}{i_0}{\diseqtestact}} q'$ is a transition of $\prot$.
			
			Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same "trace" as $\Tilde{u}$.
			
			We add a step $(\Tilde{q}, \Tilde{\nu}) \extbr{m,v} (q, \nu)$ at the end to obtain $u$, with $\nu = \nu'$.
		\end{itemize}
	
		In all cases, the conditions are respected, as $\trace{u} = \trace{\Tilde{u}} (m,v, in) = \trace{\Tilde{u}'} (m,v, in) = \trace{u'}$.
		
		\item If the last step of $u'$ is $((\Tilde{q}', \Tilde{map}'), \Tilde{\nu}') \xrightarrow{\loc{j_1}{j_2}{\diseqtestact}} ((q', map'), \nu')$ then $map'=\Tilde{map}'$, $\nu' = \Tilde{\nu}'$, $\nu'(j_1) \neq \nu'(j_2)$ and there exists $q \in Q$ and $i_1, i_2 \in [1,r]$ such that $map'(i_1)=j_1$, $map'(i_2)=j_2$ and $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $q \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} q'$ is a transition of $\prot$.
		
		Like before, as $(\Tilde{q}, map') \xrightarrow{\varepsilon}^* (q, map')$ and $map'=\Tilde{map}'$, we can extend $\Tilde{u}$ into a "local run" to $(q, \Tilde{\nu})$ with the same "trace" as $\Tilde{u}$.
		
		
		We append a step $(q, \Tilde{\nu}) \xrightarrow{\loc{i_1}{i_2}{\diseqtestact}} (q', \nu)$ at the end of that local run to obtain $u$, with $\nu = \Tilde{\nu}$. We have $\Tilde{\nu}(i_1) = \Tilde{\nu}'(j_1) \neq \Tilde{\nu}'(j_2) = \Tilde{\nu}(i_2)$ and thus $\trace{u} = \trace{\Tilde{u}} = \trace{\Tilde{u}'} = \trace{u'}$.
	\end{itemize}

We have shown that $\prot$ and $\prot'$ produce the same set of "traces" from their "local runs". As the "input" and "output" of a local run depend only on its "trace", we obtain the result by Lemma~\ref{lem:local-to-global}.
\end{proof}
\fi

\begin{lemma}
	Let $\tree$ be a "tree unfolding" satisfying a specification $\spec$.
	Let $\node, \node'$ be two "boss nodes" of $\tree$, $\bossspec$ and $\bossspec'$ their specification labels.
	
	If $\node$ is an ancestor of $\node'$ and $\bossspec$ is a subword of $\bossspec'$ then there exists a smaller "tree unfolding" satisfying $\spec$.  
\end{lemma}

\ifproofs
\begin{proof}
	Let $\tree_{\node}$, $\tree_{\node'}$ be the subtrees rooted in $\node$, $\node'$ respectively. 
	Let $\tree'$ be the tree obtained by replacing $\tree_{\node}$ with $\tree_{\node'}$. The size of $\tree'$ is smaller than the one of $\tree$, as $\tree_{\node'}$ is a strict subtree of $\tree_{\node}$.
	
	If $\node$ is the root of $\tree$, then $\tree'$ is a "tree unfolding" with $\node'$ as root. As $\node$ is a "boss node" and $\tree$ satisfies $spec$, $spec$ is a "boss specification", and a subword of $w$. 
	As $w$ is a subword of $w'$, $spec$ is a subword of $w'$ and thus $\tree'$ satisfies $spec$.
	
	If  $\node'$ is not the root of $\tree'$ then let $\node''$ be the father of $\node$. We have to check that $\tree'$ is a "tree unfolding". 
	All nodes other than $\node''$ have the same children as before, thus the conditions of "tree unfoldings" are still respected for them.
	As for $\node''$, it has the same "follower" children, hence conditions \ref{unfoldingC1} and \ref{unfoldingC3.1} are respected. Condition \ref{unfoldingC2} only depends on its label, which hasn't changed.
	
	Finally, let $u''$ be the "local run" labelling $\node''$ and let $v'$ be a value that is not initial in $u''$. Either $\node''$ has a "boss" child other than $\node'$ such that $\vinput{v'}{u''}$ is a subword of its label, or $\vinput{v'}{u''}$ is a subword of $w$, which is a subword of $w'$, hence condition \ref{unfoldingC3.2} is satisfied. 
	
	As a result, in both cases $\tree'$ is a "tree unfolding" smaller than $\tree$ that satisfies $spec$. 
\end{proof}
\fi

\begin{lemma}
	Let $\tree$ be a "tree unfolding" satisfying a specification $spec$.
	Let $\node, \node'$ be two "follower nodes" of $\tree$, $(\decsymb,m)$ and $(\decsymb',m')$ the associated specifications.
	If $\node$ is an ancestor of $\node'$, $\decsymb' \subword \decsymb$ and $m=m'$ then there exists a smaller "tree unfolding" satisfying $spec$. 
\end{lemma}

\ifproofs
\begin{proof}
		Let $\tree_{\node}$, $\tree_{\node'}$ be the subtrees rooted in $\node$, $\node'$ respectively. 
	Let $\tree'$ be the tree obtained by replacing $\tree_{\node}$ with $\tree_{\node'}$. The size of $\tree'$ is smaller than the one of $\tree$, as $\tree_{\node'}$ is a strict subtree of $\tree_{\node}$.
	
	If $\node$ is the root of $\tree$, then $\tree'$ is a "tree unfolding" with $\node'$ as root. As $\node$ is a "follower node" and $\tree$ satisfies $spec$, $spec$ is a "follower specification". Let $(\decsymb_{spec}, m_{spec}) = spec$, we have $\decsymb \preceq \decsymb_{spec}$ and $m = m_{spec}$. 
	Hence we have $\decsymb' \preceq \decsymb \preceq \decsymb_{spec}$ and $m' = m = m_{spec}$, thus $\tree'$ satisfies $spec$.
	
	If  $\node'$ is not the root of $\tree'$ then let $\node''$ be the father of $\node$. We have to check that $\tree'$ is a "tree unfolding". 
	All nodes other than $\node''$ have the same children as before, thus the conditions of "tree unfoldings" are still respected for them.
	As for $\node''$, it has the same "boss" children, hence condition \ref{unfoldingC3.2} is respected. Condition \ref{unfoldingC2} only depends on its label, which hasn't changed.
	
	Let $u''$ and $v''$ be the local run and value labelling $\node''$.
	For condition \ref{unfoldingC1}, suppose $\node''$ is a "boss node" labelled by a word $w''$, then $v''$ is an initial value in $u''$. There exists a decomposition $\decsymb'' = (w_0, m_1, \ldots, w_\ell)$ such that $\voutput{v''}{u''} = w_0\cdots w_\ell$, $w''\in \langdecdown{\decsymb}$ and for all $j \in [1,\ell]$, $\node''$ has a child labelled $(\decsymb,m_j)$ with $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$ in $\tree$.
	For all $j$, either $\node''$ has a child labelled $(\decsymb,m_j)$ with $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$ in $\tree$ besides $\node$, in which case this child is still there in $\tree'$, or $\node$ is labelled $(\decsymb,m_j)$ for some $\decsymb \subword (w_0, m_1, \ldots, w_{j-1})$, in which case $\node'$ is labelled $(\decsymb', m_j)$ with  $\decsymb' \subword \decsymb \subword (w_0, m_1, \ldots, w_{j-1})$.
	Condition \ref{unfoldingC1} is still satisfied.
	
	Finally, let $v' \neq v''$ an initial value of $u$ broadcast or received at some point.
	Then there exists a decomposition $\decsymb'' = (w'_0, m'_1, \ldots, w'_\ell)$ such that $\voutput{v''}{u''} = w'_0\cdots w'_\ell$, and for all $j \in [1,\ell]$, all receptions of $m'_j$ with value $v'$ in $u''$ happen after the broadcasts of $w'_0\cdots w'_{j-1}$ with value $v'$, and for all $j \in [1,\ell]$ $\node$ has a child in $\tree$ which is a "follower node" with a label $\decsymb \subword (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
	If that child is not $\node$ then it is still there in $\tree'$. If it is $\node$, in $\tree'$ $\node''$ has $\node'$ as child, with a label $\decsymb' \subword \decsymb \subword (w_0, m_1, w_1, \ldots, m_{j-1}, w_{j-1})$.
	In both cases condition \ref{unfoldingC3.1} is satisfied.
	
	As a result, in both cases $\tree'$ is a "tree unfolding" smaller than $\tree$ that satisfies $\spec$. 
\end{proof}
\fi
%\begin{lemma}
%	Let $u_1$, $u_2$ be two local runs of a protocol $\prot$ with the same sequence of transitions, $(q_1, \nu_1)$ the first local configuration of $u_1$, $(q_2, \nu_2)$ the last one of $u_2$. Then there is a local run $u$ with the same sequence of transitions as $u_1$ and $u_2$ from $(q_1, \nu_1)$ to $(q_2, \nu_2)$. 
%\end{lemma}

\begin{figure}
	\input{Figures/fig-illustration-pumping}
	\caption{Illustration of the proof of Lemma~\ref{lem:short-local-runs}. Lines correspond to registers, and vertical separations are times at which the value of that register changes. If one register $i$ keeps the same value for a long enough time (on the left), we apply the induction hypothesis to shorten the projection of the run on the other registers. As the value of $i$ does not change, the resulting run is still valid. If all registers change values often (on the right), then if the run is long enough we can find two identical sequences of transitions during which all values are renewed. We can then obtain a shorter run by glueing them together as in the picture.}
\end{figure}


\begin{remark}
	The tower bound of Lemma~\ref{lem:short-local-runs} is tight, in the sense that some local runs may need to have length a tower of exponentials of height the number of registers.
	It also holds for pushdown automata, and for all transition systems which have some kind of pumping lemma.
\end{remark}

\begin{lemma}
	\label{lem:short-local-runs}
	There exists a function $\towerfun(n, e)$ in $O(\repexp{n}{e})$ such that, for every protocol $\prot$ with $r$ registers per process, for every "local run" $\localrun: (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ in $\prot$, there exists $\localrun': (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ such that $\length{\localrun'} \leq \towerfun(\size{\prot})(r)$ and $\Input{\localrun'}$ is a subword of $\Input{\localrun}$. 
%  with an "input" $I$.
% 	Let $u_1, u_2, u_3$ be such that $u=u_1u_2u_3$.
% 	If $\size{u_2} > TOWER$, then there exists $u'_2$ with $|u_2'| \leq \towerfun(\prot)$ such that $u_1u'_2u_3$ is a local run of $\prot$ with smaller "input" than $u$. 
\end{lemma}

\ifproofs
\begin{proof}

% In the following proof, we consider for simplicity protocols with internal transitions, \emph{i.e.}, transitions with no labeled action that can be taken without condition. 
Given a "local run" $\localrun$, register $i$ is ""active"" in $\localrun$ if at least one $\quotemarks{\enregact}$ step on register $i$ is performed in $\localrun$. Also, let $n:=\size{\prot}$.

We prove the following statement:
for every $\localrun: (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ with $k$ "active registers" such that $\length{\localrun} > \towerfun(|\prot|,k)$, $\localrun$ can be shortened into a local run $\localrun': (q_i, \localdata_i) \step{*} (q_f, \localdata_f)$ whose "schedule" is a strict subsequence of the one of $\localrun$. Note that if the "schedule" of $\localrun'$ is a subsequence of the one of $\localrun$ then $\Input{\localrun'}$ is a subsequence of $\Input{\localrun}$.

We proceed by induction on the number $k$ of "active registers" in the "local run". If $k=0$, then registers keep their values throughout $\localrun$. Therefore, if $\localrun$ goes through the same state once, all steps in between may be removed, and it suffices to take $\towerfun(\size{\prot}, 0) := |\prot| + 1 \geq |Q| +1$.  

Suppose that the property is true for any protocol with $\leq k$ "active registers", and consider a run $\localrun: (q_i,\localdata_i) \step{*} (q_f,\localdata_f)$ with $k+1$ "active registers" such that $\length{\localrun} > \towerfun(n)(k+1)$.

First, if there exists an infix "local run" $\localrun_i: (q_1, \localdata_1) \step{*} (q_2, \localdata_2)$ of $\localrun$ of length $\towerfun(n)(k)+1$ with only $k$ active registers, then by induction hypothesis $\localrun_i$ can be shortened thus $\localrun$ can be shortened as well.

Suppose now that there exists no such infix "local run".
Let $I \subseteq \nset{1}{r}$ the set of "active registers" in $\localrun$, $|I| = k+1$. Let $M:= \towerfun(n)(k){+}1$. 
In any sequence of $M$ "local steps" in a row in $\localrun$, 
there is a $\quotemarks{\enregact}$ transition on every register in $I$. Let $\towerfun(n)(k+1) := n^{M}+M$ and suppose that $\length{\localrun} > \towerfun(n)(k+1)$. For every $i$, let $\atrans_i$ the $i$-th transition in $\localrun$.
 For every $i \in \nset{1}{n^M+1}$, we write $s_i$ the sequence $\delta_i, \delta_{i+1}, \cdots, \delta_{M{+}i}$.
By Pigeonhole principle two of the sequences $s_i$ are equal (there are $|\transitions|^{M}$ distinct such sequences and $|\transitions| \leq n$). 
There exist $(q, \localdata_1)$, $(q, \localdata_3)$ appearing in $\localrun$ in this order (but not consecutively) such that both "local configurations" are followed by the same sequence $s$ of transitions in $\localrun$, with $s$ of length $M$. Note that the states of the two "local configurations" are equal as it must be the source state of the first transition in $s$. Let $\locallabel = \locallabel^1, \dots, \locallabel^M$ the sequence of labels of the $M$ local steps following $(q, \localdata_1)$, and $\locallabel' = \locallabel'^1, \dots, \locallabel'^M$ the sequence of labels of the $M$ local steps following $(q, \localdata_3)$. The underlying sequences of transitions of $\locallabel$ and $\locallabel'$ are both equal to $s$; however, it could be that the values $\aval$ of the "external broadcasts" are not equal in $\locallabel$ and $\locallabel'$, hence we cannot directly shorten $\localrun $ by replacing $\locallabel$ by $\locallabel'$. 	

We write $\localrun_a: (q, \localdata_1) \step{\locallabel} (q', \localdata_2)$ and $\localrun_b: (q, \localdata_3) \step{\locallabel} (q', \localdata_4)$ the corresponding infux "local runs". 
We build a "local run" $\localrun_s: (q, \localdata_1) \step{*} (q', \localdata_4)$ of length $M$ whose underlying sequence of transitions is also $s$. To do so, we identify, for every active register $i \in I$, the index $k_i \in \nset{1}{M}$ of the first $\quotemarks{\enregact}$ transitions about register $i$ in $s$, which exists by hypothesis: in any sequence of $M$ "local steps" in a row in $\localrun$, 
there is a $\quotemarks{\enregact}$ transition on every register in $I$. 

We build $\localrun_s$ step by step. We denote, for every $j \in \nset{1}{M+1}$, by $\localrun_a(j)$, $\localrun_b(j)$ and $\localrun_s(j)$ the $j$-th "local configurations" in the corresponding "local run". Because we guarantee by construction of $\localrun_s$ that its underlying sequence of transitions is $s$, for every $j \in \nset{1}{M+1}$, $\localrun_a(j), \localrun_b(j)$ and $\localrun_s(j)$ has the same state and the same data value for registers in $\nset{1}{\regnum} \setminus I$ (because these registers has the same values thourghout $\localrun$).
 We maintain the following property: for every $i \in I$, $\localrun_s(j)$ shares value of register $i$ with $\localrun_a(j)$ if $j \leq k_i$, and with $\localrun_b(j)$ if $j > k_i$. We achieve this by mimicking in $\localrun_s$ ????
















	We will show the following result, which directly implies the lemma:
	Let $\prot$ be a protocol with $r$ registers, let $u$ be a "local run" of $\prot$ from "local configuration" $(q_0, \nu_0)$ to $(q_{end}, \nu_{end})$ with an input $I$. If $\size{u} \geq TOWER$, then there exists a shorter local run $u'$ from $(q_0, \nu_0)$ to $(q_{end}, \nu_{end})$, with a smaller "input" and such that the sequence of local actions in $u'$ is a subword of the one in $u$.
	We proceed by induction on $r$.
	
	If $r=0$ then if $\size{u} > TOWER = \size{Q}$ then $u$ visits twice the same state, hence the same local configuration as there are no registers, and the sequence between those two moments can be deleted, yielding the result.
	
	Let $r>0$, suppose the proposition holds for $r-1$.
	Let $u$ be a run of $\prot$, a protocol with $r$ registers, with $\size{u} > TOWER$.
	
	\begin{itemize}
		\item If there exists $i \in [1,r]$ such that $u$ has a factor $u_f$ in which the value of register $i$ does not change and with $\size{u_f} > TOWER$, then let $\Tilde{\prot}$ be $\prot$ where every operation $op$ over $i$ has been replaced with a local action $a_{op}$. Note that $\Tilde{\prot}$ only uses $r-1$ registers. 
		Let $\Tilde{u_f}$ be the run following $u_f$ in $\prot$, where every transition $q \xrightarrow{op} q'$ with an operation on $i$ has been replaced with $q \xrightarrow{a_{op}} q'$.
		
		By induction hypothesis we have that there exists $\Tilde{u'_f}$ shorter than $\Tilde{u_f}$, with the same start and end local configurations, a smaller input, and a sequence of local actions that is a subword of the one of $\Tilde{u_f}$.
		
		We conclude that the corresponding sequence of transitions $u_f'$ in $\prot$ is a local run with the same initial and final local configurations as $u_f$, as the value of register $i$ stays the same throughout both runs. By replacing $u_f$ with $u_f'$ in $u$, we obtain a shorter local run $u'$ of $\prot$. Let $v$ be the value that register $i$ keeps through $u_f$, the $v$-input of $u'$ 
		
		\item If no register keeps the same value for more than $TOWER$ steps, then any run $u$ of length at least $M_{r-1} ((\size{\Delta})^{M_{r-1}} +1)$ can be split into $(\size{\Delta})^{M_{r-1}} +1$ segments of size $M_{r-1}$. There are $\size{\Delta}^{M_{r-1}}$ different sequences of transitions, thus by the pigeonhole principle we have $u = \pi_1 \sigma_1 \pi_2 \sigma_2 \pi_3$ with $\size{\sigma_1} = \size{\sigma_2} = M_{r-1}$ and such that  $\sigma_1$ and $\sigma_2$ have the same sequence of transitions.
		
		Furthermore as all registers change their values every $M_{r-1}$ steps, we know that $\sigma_1$ and $\sigma_2$ contain operations of the form $\rec{m}{i}{\enregact}$ for all $i \in [1,r]$.
		
		Let $(q_1, \nu_1)$ be the local configuration at the beginning of $\sigma_1$, $(q_2, \nu_2)$ the one at the end of $\sigma_2$.
		\cortoin{TO FINISH}
	\end{itemize}
	
\end{proof}
\fi 

\iffalse
\begin{proof}
	For this proof we will allow our protocols to execute local actions from a finite alphabet $\Sigma$.
	We proceed by induction on $r$.
	
	If $r=0$ then if $\size{u} > Tower_{\size{Q}}(r+1) = \size{Q}$ then $u$ visits twice the same local configuration, and can thus be decomposed as $u_1 u_2 u_3$ where $u_2$ starts and ends in the same state, yielding the result. 
	
	Let $r>0$, suppose the proposition holds for $r-1$.
	Let $u$ be a run of $\prot$, a protocol with $r$ registers, with $\size{u} > Tower_{\size{Q}}(r+1)$.
	
	\begin{itemize}
		\item If there exists $i \in [1,r]$ such $u$ has a factor $u_f$ in which the value of register $i$ does not change and with $\size{u_f} > Tower_{\size{Q}}(r)$, then let $\Tilde{\prot}$ be $\prot$ where every operation $op$ over $i$ has been replaced with a local action $a_{op}$. Note that $\Tilde{\prot}$ only uses $r-1$ registers. 
		Let $\Tilde{u_f}$ be the run following $u_f$ in $\prot$, where every transition $q \xrightarrow{op} q'$ with an operation on $i$ has been replaced with $q \xrightarrow{a_{op}} q'$.
		
		By induction hypothesis we have that $\Tilde{u_f} = \Tilde{u_{f,1}} \Tilde{u_{f,2}}\Tilde{u_{f,3}}$ such that  $\Tilde{u_{f,1}}\Tilde{u_{f,3}}$ is a run of $\Tilde{\prot}$ with the same initial and final local configurations as $\Tilde{u_f}$. 
		
		We conclude that the corresponding sequence of transitions $u_{f,1}u_{f,3}$ in $\prot$ is a local run with the same initial and final local configurations as $u_f$, as the value of register $i$ stays the same throughout both runs.
		
		\item If no register keeps the same value for more than $M_{r-1}$ steps, then any run $u$ of length at least $M_{r-1} ((\size{\Delta})^{M_{r-1}} +1)$ can be split into $(\size{\Delta})^{M_{r-1}} +1$ segments of size $M_{r-1}$. There are $\size{\Delta})^{M_{r-1}}$ different sequences of transitions, thus by the pigeonhole principle we have $u = \pi_1 \sigma_1 \pi_2 \sigma_2 \pi_3$ with $\size{\sigma_1} = \size{\sigma_2} = M_{r-1}$ and such that  $\sigma_1$ and $\sigma_2$ have the same sequence of transitions.
		
		Furthermore as all registers change their values every $M_{r-1}$ steps, we know that $\sigma_1$ and $\sigma_2$ contain operations of the form $\rec{m}{i}{\enregact}$ for all $i \in [1,r]$.   
	\end{itemize}
\end{proof}
\fi

\begin{lemma}
	Let $\node$ be a node of a "tree unfolding", $u_\node$ its local run.
	Let $u$ be the local run of its father, and $u_1, \ldots, u_\ell$ the runs of its "follower" children.
	Then if $\size{u_\node} \geq \towerfun(\size{\prot})(r) \cdot (1+ \size{u}+ \sum_{j=1}^{\ell} \size{u_j})$ then there exists a smaller tree unfolding with the same root specification label.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

\begin{definition}
	We define the ""altitude"" of a node $\node$, written $\altitude{\node}$, in a "tree unfolding" recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$
		
		\item The altitude of a "boss node" is the altitude of its father minus one
		
		\item The altitude of a "follower node" is the altitude of its father plus one.
	\end{itemize}
\end{definition}

\begin{lemma}
	\label{lem:bound-length-at-height-h}
	Let $\prot$ be a protocol, $bw$ a "boss specification".
	 
	If there exists a "tree unfolding" over $\prot$ satisfying $bw$ then we can change its node labels to obtain a new "tree unfolding" such that for all node $\node$, 
	\[
		\size{\localrunlabel{\node}} \leq \size{bw} \Big[(\size{\messages}+2) \towerfun(\size{\prot})(r)\Big]^{altmax-\altitude{\node}}
	\] 
\end{lemma}

\ifproofs
\begin{proof}
	We prove this by induction on $altmax-\altitude{\node}$.
	
	If $\altitude{\node} = altmax$ then $\node$ has no "follower nodes" as children and is either the root or a "follower node" (otherwise its father would have a greater height).
	
	If $\node$ is the root 
\end{proof}
\fi

\begin{lemma}
	\label{lem:bound-max-height}
	The maximal altitude in a minimal tree unfolding is bounded by $f_1(\size{\prot})$ where $f_1$ is a function of the class $F_{\omega^\omega}$.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

\begin{corollary}
	The local run associated with the root of a minimal tree unfolding is bounded by $f_2(\size{\prot})$ where $f_2$ is a function of the class $F_{\omega^\omega}$.
\end{corollary}

\ifproofs
\begin{proof}
	Consequence of Lemmas~\ref{lem:bound-length-at-height-h} and~\ref{lem:bound-max-height} as $F_{\omega^\omega}$ is closed by composition with primitive recursive functions.
\end{proof}
\fi

\begin{lemma}
	\label{lem:bound-min-height}
	The absolute value of the minimal altitude in a minimal tree unfolding is bounded by $f_3(\size{\prot})$ where $f_3$ is a function of the class $F_{\omega^\omega}$.
\end{lemma}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi


\begin{corollary}
	\label{lem:bound-node-size}
	The length of a local run associated with a node of a minimal tree unfolding is bounded by $f_4(\size{\prot})$ where $f_4$ is a function of the class $F_{\omega^\omega}$.
\end{corollary}

\ifproofs
\begin{proof}
	Consequence of Lemmas~\ref{lem:bound-length-at-height-h}, \ref{lem:bound-max-height} and \ref{lem:bound-min-height} as $F_{\omega^\omega}$ is closed by composition with primitive recursive functions.
\end{proof}
\fi


\begin{proposition}
	In a minimal "tree unfolding" satisfying a given specification, the length of a branch is bounded by a function of $F_{\omega^\omega}$.
\end{proposition}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi
%\begin{lemma}
%	Given a protocol $\prot$, one can construct in polynomial time a protocol $\prot'$ with no $*$ operation satisfying the same specifications as $\prot$.
%\end{lemma}
%
%\begin{proof}
%	Let $r$ be the number of registers of $\prot$.
%	We simply add a register $r+1$ to $\prot$ and turn all $\rec{m}{i}{*}$ transitions into $\rec{m}{r+1}{\enregact}$. 
%	An easy induction shows that for all local run of $\prot$ there exists a local run of $\prot'$ with the same input and output, and vice-versa.
%\end{proof}





\begin{theorem}
	The BNRA coverability problem is decidable in $F_{\omega^\omega}$ and there is no $\alpha < \omega^\omega$ such that this problem ca be solved in $F_{\alpha}$.
	The upper bound holds even with multiple operations on messages.
	The lower bound holds even with two registers.
\end{theorem}

\ifproofs
\begin{proof}
	\cortoin{TODO}
\end{proof}
\fi

