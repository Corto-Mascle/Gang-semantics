\section{Cover decidability}
\label{sec:cover-decidability}

This section is dedicated to the proof of the main result of this paper:

\begin{restatable}{theorem}{decidablecover}
\label{thm:decidable-cover}
\COVER for \BNRA{}s is decidable. Moreover, the problem is $\Fcomplexity{\omega^\omega}$-complete.
\end{restatable}

Thanks to Proposition~\ref{prop:loc-eq-test-elimination}, we may assume that our protocols have no "local equality tests" (the complexity class $\Fomegaomega$ is stable by exponential reduction). 

The intuition of our decidability procedure is as follows. 
Consider a given run when an agent $a$ covers some state $q$; we want to understand $a$ needs from other agents in order to cover $q$. It might need to receive a sequence $w \in \messages^*$ of messages all with the same value, so that it stores the value of the first such message and tests further messages for equality.
From the other agents' perspective, they have to broadcast $w$ with the same value in every broadcast. We later call such a request a \emph{"boss specification"}.  
Agent $a$ might also broadcast messages with some value $\aval$ that it had initially, then require to receive messages with that same value. 
From the other agent's perspective, they have to broadcast a given message $(\amessage,\aval)$ after receiving $w$ with value $\aval$. We later call such a request a \emph{"follower specification"}.

The two roles identified previously are the key to the decidability procedure. Thanks to the copycat principle, we will be able to consider runs in which a given agent only plays one such role. To represent such executions, we define the notion of "unfolding trees"; an "unfolding trees" represents all such roles, dependencies between them and how they are carried out. The decidability procedure will rely on a bound of the minimum "size@@tree" of the "unfolding tree" one has to consider.

We will proceed as follows. In Section~\ref{sec:decidability-defs}, we introduce several usefuls notions. In Section~\ref{sec:decidability-tree-unfoldings}, we define the notion of "unfolding tree". In Section~\ref{sec:tree-bounds}, we bound the size of the "unfolding trees" that we have to consider; this is in fact the most technical part of this article. Finally, in Section~\ref{sec:decidability-end}, we conclude by expliciting our decidability procedure. 


\subsection{Useful definitions}
\label{sec:decidability-defs}

In this section, we define a notion of "local run"; a "local run" may be seen as the projection of a "run" onto a given agent. In this local vision, we do not consider the origin of the messages received.
	
\AP A ""local configuration"" is a pair $(q, \localdata) \in Q \times \nats^r$.  
\AP An ""internal step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$, denoted $(q,\localdata) \intstep{\atrans} (q',\localdata')$, is defined when $\localdata = \localdata'$, and $\atrans =(q, \alpha, q')$ is either a "broadcast" or a "local test" and if it is "local test" on register $i$ and $j$, $\localdata(i) \ne \localdata(j)$.  
\AP A ""reception step"" from $(q,\localdata)$ to $(q',\localdata')$ with transition $\atrans \in \transitions$ and value $\aval \in \nats$, denoted $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$, is defined when $\atrans$ is of the form $(q,\rec{m}{j}{\anact},q')$ with $\localdata(j') = \localdata'(j')$ for all $j' \neq j$ and one of the following cases holds:
	
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\dummyact}$ 
			and $\localdata(j) = \localdata'(j)$
			\item $\anact = \quotemarks{\enregact}$ and $\localdata'(j) = v$
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{6cm}
		\begin{itemize}
			\item $\anact = \quotemarks{\eqtestact}$ and $\localdata(j) = \localdata'(j)= v$
			\item $\anact = \quotemarks{\diseqtestact}$ and $\localdata(j) = \localdata'(j) \ne v$.
		\end{itemize}
	\end{minipage}
	

	%Said otherwise, $(q,\localdata) \extbr{\atrans}{\aval} (q',\localdata')$ when an agent in $(q,\localdata)$ may perform $\atrans$ upon receiving a message of type $\amessage$ and of value $\aval$.
	\AP A ""local step"" $(q,\localdata) \step{} (q',\localdata')$ is either an "reception step" or an "internal step". 
	\AP A ""local run"" is a sequence $\localrun$ of "local steps" $(q_0, \nu_0) \step{\locallabel_1} (q_1, \nu_1) \step{\locallabel_2} \cdots \step{\locallabel_k} (q_k, \nu_k)$ where, for all $i$, $\locallabel_i \in \set{\extlabel{\atrans}{\aval} \mid \atrans \in \transitions, \aval \in \nats} \cup \set{\intlabel{\atrans} \mid \atrans \in \transitions}$. 
	For $\aval \in \nats$ appearing in $\localrun$, $\aval$ is ""initial"" if its appears in $\nu_0$ and ""non-initial"" otherwise. 

	Finally, the ""input"" $\Input{\localrun} \in (\messages \times \nats)^*$ of a "local run" $\localrun$ is the sequence of messages of its "reception steps". Its ""output"" $\Output{\localrun} \in (\messages \times \nats)^*$ is the sequence of messages broadcast in $\localrun$. The $\aval$-input $\vinput{\aval}{\localrun}$ (resp. $\val$-output $\voutput{\aval}{\localrun}$) is the sequence containing message types of "reception steps" (resp. broadcast steps) of $\localrun$ with value $\val$. Formally, $\vinput{\aval}{\localrun}$ (resp. $\voutput{\aval}{\localrun}$) is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ (resp. $\Output{\localrun}$) on $\messages \times \set{\aval}$. 
 
	A ""decomposition"" is a tuple $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ with $w_0, \ldots, w_\ell \in \messages^*$, and $m_1, \cdots, m_\ell \in \messages$, with $m_i \neq m_j$ for all $i\neq j$. In particular we have $\ell \leq \size{\messages}$. 
	$w \in \messages^*$ ""admits decomposition"" $\decsymb = (w_0, m_1, \ldots, m_\ell, w_\ell)$ if $w \subword w'_0 w'_1 \cdots w'_\ell$ where for all $j$, $w'_j$ can be obtained from $w_j$ by adding letters from $\set{m_1, \ldots, m_{j-1}}$. 
	We denote by $\langdec{\decsymb}$ the language of words that admit decomposition $\decsymb$. 
	The idea of this definition is as follows: the message $m_i$ is broadcast by some agent that we are able to duplicate, but this agent needs to receive $w_{i-1}$ first; therefore, once $w_i$ has been broadcast, $m_i$ can be bradcast at will. The subword condition encoded the idea that messages may be lost. 

%	The ""input"" of a "local run" $\localrun$ is the sequence $\Input{\localrun} \in (\messages \times \nats)^*$ containing messages types and values of its "reception steps".
%	Similarly, its ""output"", which we denote by $\Output{\localrun} \in (\messages \times \nats)^*$, is the sequence of messages of (internal) broadcast steps made in $\localrun$.
%	Given a value $v \in \nats $, the $v$-input $\vinput{\aval}{\localrun} $(resp. the $v$-output $\voutput{\aval}{\localrun}$) of $\localrun$ is defined as the sequence of messages of $\Input{\localrun}$ (resp. $\Output{\localrun}$) that have value $\aval$. Formally, $\vinput{\aval}{\localrun}$ is the word $m_0 \cdots m_{\ell} \in \messages^*$ such that $(m_0, \aval) \cdots (m_{\ell}, \aval)$ is the projection of $\Input{\localrun}$ on $\messages \times \set{\aval}$. 
%	


\subsection{Unfolding trees}
\label{sec:decidability-tree-unfoldings}

An \emph{unfolding tree} is a description of a run achieving some goal. Each node is assigned a local run and a specification of the role of this local run. There are \emph{boss specifications} and \emph{follower specifications}. A ""boss specification"" consists of a word $\bossspec \in \messages^*$ describing a sequence of message types that should be broadcast all with the same value. A ""follower specification"" consists of a pair $(\followwordspec, \followmessagespec) \in \messages^*\times \messages$, meaning that sequence of message types $\followwordspec$ is broadcast with a common value $v$, one must be able to broadcast $\followmessagespec$ with that same value. 

We first provide the formal definition "unfolding trees". We then explain this definition and prove that the notion of "unfolding tree" is relevant for \COVER. 

\AP An ""unfolding tree"" $\tree$ over $\prot$ is
a finite tree where each node $\node$ has three labels:
\begin{itemize}
	\item a "local run" of $\prot$, written $\localrunlabel{\node}$;
	
	\item a value in $\nats$, written $\valuelabel{\node}$;
	
	\item a ""specification"" $\speclabel{\node}$, which is either a word $\bosslabel{\node} \in \messages^*$ ("boss specification") or a pair $(\followlabelword{\node}, \followlabelmessage{\node}) \in \messages^* \times \messages$ ("follower specification"). In the first case we say that the node is a ""boss node"", otherwise it is a ""follower node"".
\end{itemize} 
Moreover, all nodes $\node$ in an "unfolding tree" must satisfy the four following conditions:
\begin{enumerate}[label= (\roman*), ref=(\roman*)]
	\item \label{item:condition1_non_initial_value} For every non-initial value $\aval \ne \valuelabel{\node}$ of $\localrun$, $\node$ has a child $\node'$ which is a "boss node" such that $\vinput{\aval}{\localrun}$ is a subword of $\bosslabel{\node'}$.
	
	\item \label{item:condition2_initial_value} For every initial value $\aval$ appearing in $\localrun$, there is a "decomposition" $\decsymb =$ \\ $(w_0, m_1, w_1, \ldots, m_{\ell}, w_{\ell})$~such~that:
	\begin{itemize}
		\item $\localrun$ may be split into successive "local runs" $\localrun_0, \dots, \localrun_{\ell}$ where, for all $i \in \nset{1}{\ell}$, $w_i \subword \voutput{\aval}{\localrun_i}$ and $\vinput{\aval}{\localrun_i} \in \set{m_1, \dots, m_{i-1}}^*$,
		\item for all $i \in [1,\ell]$, $\node$ has a child $\node_i$ which is a "follower node" such that $\followlabelmessage{\node_i} = m_i$ and $\followlabelword{\node_i} \in\langdec{\decsymb_i}$ where $\decsymb_i = (w_0, m_1, w_1, \ldots, m_{i-1}, w_{i-1})$.	\end{itemize}
	
	\item \label{item:condition3_follower_node} If $\node$ is a "follower node" then $\valuelabel{\node}$ is not an initial value of $\localrun$, $\vinput{\valuelabel{\node}}{\localrun} = \followlabelword{\node}$ and 
	$\voutput{\valuelabel{\node}}{\localrun}$ contains $\followlabelmessage{\node}$.

	\item \label{item:condition4_boss_node} If $\node$ is a "boss node", then $\valuelabel{\node}$ is an "initial value" of $\localrunlabel{\node}$ and the "decomposition" $\decsymb$ of \ref{item:condition2_initial_value} for $\valuelabel{\node}$ satisfies that $\bosslabel{\node} \in \langdec{\decsymb}$.
\end{enumerate}

Lastly, given $\tree$ an "unfolding tree", we define its ""size@@tree"" by $\size{\tree} := \sum_{\node \in \tree} \size{\localrunlabel{\node}} + \size{\speclabel{\node}}$. Note that the "size@@tree" of $\tree$ also takes into account the size of its nodes, so that a tree $\tree$ can be stored in space $O(\size{\tree})$ (renaming the values appearing in $\tree$ if needed). 

%A node represents a "local run" witnessing that some "role" can be carried out. The role is represented with its "specification" and its value is necessary to check that the "local run" is a valid witness.\lu{pas sure de cette phrase..}
%The root node should have a "local run" reaching the final state to cover. It should be seen as a boss node, however its value nor its exact specification (the word $\bosslabel{\node}$) are relevant as they shall not be used.\lu{dire plus de choses là dessus ?}

We now explain this definition. Let $\node$ be a "node" of an "unfolding tree" $\tree$ and let $\localrun := \localrunlabel{\node}$. $\localrun$ encodes the "local run" of a given agent; $\speclabel{\node}$ encodes the specification that this "local run" carries out; $\valuelabel{\node}$ encodes the value for which the "specification" is carried out.

Conditions \ref{item:condition1_non_initial_value} to \ref{item:condition4_boss_node} state two things. First, that the "specifications" of its children are witnesses that messages received in the "local run" $\localrun$ can be broadcast by other agents (conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value})
Second, that $\node$ is a witness that its "specification" is carried out (conditions \ref{item:condition3_follower_node} and \ref{item:condition4_boss_node}).

Condition \ref{item:condition1_non_initial_value} is the easiest to understand. It states that, for every "non-initial value" $\aval$ of $\localrun$ (values not in $\localrun$ at the start), $\node$ must have a "boss" child witnessing that $\vinput{v}{\localrun}$ can indeed be received. Because $\aval$ was initially stored in $\localrun$, it can be replaced by any other value as long as the sequence received contains $\vinput{v}{\localrun}$, therefore we do not impose anything about the values of this "boss" child. 

Let us now explain condition \ref{item:condition2_initial_value}. Let $v$ be an initial value of $\localrun$. Suppose that $\localrun$ is the "local run" of agent $a$. Any other agent that broadcasts with value $v$ has first received and stored it. Therefore, such agents can be duplicated; if some agent other than $a$ broadcasts $(m,v)$, then from this point on we may suppose that we have an unlimited supply of messages $(m,v)$.
Intuitively, we split $\localrun$ into $u_0,\dots,u_\ell$ according to the first point where each type of message is received with value $v$. For every $i$, the set of messages available during $u_i$ is $\voutput{v}{u_i}$ where symbols from $\set{m_1,\dots, m_{i-1}}$ can be freely added thanks to the copycat behavior stated above. Therefore, the child $\node_i$ responsible for the broadcast of $m_i$ may first have received with value $v$ a subword of $w_0' \cdot w_1' \cdot w_{i-1}'$ where, for all $j \leq i-1$, $w_j$ is obtained from $\voutput{v}{u_i}$ by adding symbols from $\set{m_1, \dots, m_{j-1}}$. This explains why we have the condition $\followlabelword{\node_i} \in \langdec{\decsymb_i}$.   

Condition \ref{item:condition3_follower_node} directly expresses that a "follower node" $\node$ encodes an agent that, after receiving word $\followlabelword{\node}$ with value $\valuelabel{\node}$, broadcasts message $(\followlabelmessage{\node}, v)$. Condition \ref{item:condition4_boss_node} expresses that a "boss node" is witness of the ability to broadcast a sequence of messages $\bosslabel{\node}$. However, in the broadcast sequence, some messages may not come from this agent but from subsequent ones encoded in "follower" children, which is why we have the condition that $\bosslabel{\node} \in \langdec{\decsymb}$, with $\decsymb$ corresponding to $\valuelabel{\node}$, and not $\bosslabel{\node} = \voutput{\valuelabel{\node}}{\localrun}$. 



%fact that it can be a tree = non-obvious

\begin{figure}
	\begin{center}
		\input{Figures/tree-example1}
	\end{center}
	\caption{Example of an unfolding tree}\label{fig-ex-unfolding-tree}
\end{figure}

\begin{example}
	In \cref{fig-ex-unfolding-tree}~we display an "unfolding tree" obtained from the run of \cref{ex:example-1}. Each node is labelled with a local run, a specification, and a value (we omit the labels of the root). Local configurations are displayed as a state among with its two registers' values. For instance, the local run of the node at the root of the tree is \begin{multline*}
	(q_0, (x_1,y_1)) \intstep{(q_0, \br{m_1}{1},q_1)} (q_1, (x_1, y_1)) \extbr{(q_1, \rec{m_4}{2}{\enregact}, q_4)}{y_2} (q_4, (x_1, y_2)) \\ \extbr{(q_4, \rec{m_6}{1}{\eqtestact}, q_7)}{x_1} (q_7, (x_1, y_2)) \end{multline*}
	
	We explain why conditions \ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value} are satisfied at the root $\node_1$ of the tree. Let $\localrun$ its local run.
	The only non-initial value in $\localrun$ is $y_2$, and $\vinput{y_2}{\localrun} = m_4$, hence it simply needs a boss child with a "boss specification" containing $m_4$ and condition \ref{item:condition1_non_initial_value} is satisfied at the root. 
	For initial value $y_1$, condition~\ref{item:condition2_initial_value} is trivially satisfied as $\localrun$ never receives a message with value $y_1$. For $x_1$, consider the decomposition $\decsymb := (m_2, m_6, \epsilon)$. The root indeed has one "follower" child (its right child)  with "follower specification" $(\mathbf{fm}, \mathbf{fw})$ such that $\mathbf{fm} = m_1$ and $\mathbf{fw} \in \langdec{\decsymb_1}$ where $\decsymb_1 = (m_2)$, proving that condition~\ref{item:condition2_initial_value} is satisfied at $\node_1$. We do not illustrate conditions~\ref{item:condition1_non_initial_value} and \ref{item:condition2_initial_value} for the other nodes. 
	
	Condition \ref{item:condition3_follower_node} only applies to $\node_3$; it is satisfied as $\localrunlabel{\node_3}$ broadcasts $(m_6,x_1)$; note that, to do so, it receives $(m_2,x_1)$ with needing a child to broadcast it. 
	As for condition \ref{item:condition4_boss_node}, \nico{a continuer} we can check that values of the boss nodes are indeed initial values of the "local runs" and the conditions on the decomposition described on condition \ref{item:condition2_initial_value}. As we said, we are not interested in the specification of the boss node and so we can choose any subword of the input (of the initial chosen value) of the local run.\lu{mal dit..} For all other boss nodes, we argue that their decomposition of a value is the single word made of the input of the value. For the bottom left node its input on $x_3$ is $m_2$ and as $m_2 \in \langdec{(m_2)}$, this satisfies the condition. For the left middle node, its input on $y_2$ is $m_4$ and so for the same reasons the condition is satisfied.
	
	
%	\luin{ici explications sur chacune des conditions}
	
	
	Note that if one wants to build a concrete execution of the protocol of Figure \ref{fig:ex1}~from the tree of Figure \ref{fig-ex-unfolding-tree}, the build execution should be over 4 agents (one agent per node). Each agent will play the role of a node of the tree. The agent playing the role of the bottom left node should broadcast its value among with message $m_2$ and stop. This message should be received by the agent playing the role of the boss node with value $y_2$, it will reach $q_5$ and store the value $x_3$ in its first register. It will then broadcast message $m_4$ among with value $y_2$ and stop. The latter broadcast should be received by the agent playing the role of the root node. This agent has broadcast messages $m_2$ before and reached $q_1$. When he broadcast message $m_2$ among with its value $x_1$, the message has been received by the agent playing role of the right node.
	The right node received $m_2$ among with $x_1$, it can then broadcast $m_2$ (which shall not be received) and reach $q_4$. From $q_4$ it can send message $m_6$ among with $x_1$. The message is reiceived by the agent playing the root node role, allowing him to reach $q_7$.
	
	
	

\end{example}


Our aim is to prove that we can study the \COVER problem directly on "unfolding trees". To do so, consider the following definition: 

\begin{definition}
\label{def:cov_witness}
We define a ""coverability witness"" as an "unfolding tree" whose root is a "boss node" whose local run covers $q_f$. 
\end{definition}

The following proposition expresses that this definition is sound, as indeed a "coverability witness" is a witness that \COVER is positive.
The proof can be found in Appendix~\ref{app:trees-sound-complete}.


\begin{restatable}{proposition}{treessoundcomplete}
\label{prop:trees-sound-complete}
An instance of $\COVER$ $(\prot,q_f)$ is positive if and only if there exists a "coverability witness" for that instance.
\end{restatable}

\begin{proof}[Proof sketch]
The translation from run to tree works by induction on the length of the run. We consider a run $\run$ achieving some specification and isolate a well-chosen agent $a$ (if it is a boss specification, the one with the value initially, if it is a follower one, the first agent to broadcast the given message). We consider, for each value appearing in its local run, the specification expressing what this agent needs to receive with that value in order to be able to satisfy the original specification. 
Each of those is satisfied by a strict prefix of $\run$ (except for a particular case where it is $\run$ itself which can only happen when going from a boss specification to a follower specification, which still allows the induction).

We construct a tree by labelling the root with the specification and the local run of $a$, and attaching to it subtrees obtained by induction hypothesis from the prefix runs.

The translation from tree to run consists in an induction on the tree. A key concept is the one of ``partial run'', which is a run in which some receptions have no broadcast, and thus the run needs to be completed with some broadcasts from another set of agents.
 Let $\tau$ be an unfolding tree. We show that if its root is labelled by a boss specification $\bossspec$ then there is a run in which $\bossspec$ is broadcast with a constant value. If it is labelled by a follower specification $(\followwordspec, \followmessagespec)$ then there is a ``partial run'' which requires a sequence of broadcasts of $\followwordspec$ over a constant value to broadcast $\followmessagespec$ itself with that same value.
 The induction then works by considering the runs obtained from the children of the root by induction hypothesis and then constructing a run using a parallel composition of those runs with the local run label of the root to eliminate the receptions without broadcasts and output the required sequence of messages. 
\end{proof}



\subsection{Bounding the size of the "unfolding tree"}
\label{sec:tree-bounds}

Our aim is now to provide bounds on the size of the "unfolding tree" that one has to consider for \COVER. To do so, we start with two simple observations. First, for "boss specifications", the longer the word broadcast, the better: if a word $\bossspec$ can be broadcast with a single value, then any subword of $\bossspec$ can also be received. 
% Therefore, if a branch of our tree has node $\node$ with "boss specification" $w$ and below has node $\node'$ "boss specification" $w'$ such that $w \subword w'$, then $\node'$ is better than $\node$ and one can shorten the tree by replacing $\node$ by $\node'$. 
For "follower specifications", it goes in the opposite direction: for a fixed $\followmessagespec$, the shorter the requirement $\followwordspec$, the better. The following lemma provides thus provides two ways of shortening an "unfolding tree". Its proof can be found in Appendix~\ref{app:proofs-reduction-branches}.

\begin{restatable}{lemma}{lemShorteningBranches} 
\label{lem:shortening-branches}
	Let $\tree$ be a "unfolding tree" whose root's local run covers $q_f$.
	Let $\node, \node'$ be two nodes of tree such that $\node$ is an ancestor of $\node'$. If:
	\begin{itemize}
	\item $\node$ and $\node'$ are "boss nodes" and $\bosslabel{\node} \subword \bosslabel{\node'}$; or
	\item $\node$ and $\node'$ are "follower nodes", $\followlabelword{\node'} \subword \followlabelword{\node}$ and $\followlabelmessage{\node'}=\followlabelmessage{\node}$
	\end{itemize}
	then there exists a smaller "unfolding tree" $\tree'$ whose root's local run covers $q_f$. 
\end{restatable}


We now show that there is a computable bound on the size of the "unfolding tree" achieving a given specification and labelled with a "protocol" $\prot$. Lemma~\ref{lem:shortening-branches} leads us towards an application of the "Length function theorem". 
However, this theorem cannot be simply applied on a branch of the tree, for several reasons: First there is no reason to think that the sizes of the labels of the children of a node can be bounded with respect to the label of that node, especially the "follower" ones.  Second, we can reduce the tree if we find either an \emph{increasing} pair of "boss" nodes or a \emph{decreasing} pair of "follower" ones. This is a problem as a branch can alternate between sequences of "bosses" and of "followers", making it impossible to apply the theorem.

In order to bound the size of the nodes, we use the following result, which essentially states that if there is a local run between two configurations $(q, \nu)$ and $(q', \nu')$ then there is one of length bounded by a primitive recursive function, and which does not require larger inputs than the previous one.

\begin{restatable}{lemma}{lemShortLocalRuns}
	\label{lem:short-local-runs}
	There exists a primitive recursive function $\towerfun(n,r)$ such that, for every protocol $\prot$ with $r$ registers per agent, for every "local run" $\localrun: (q, \localdata) \step{*} (q', \localdata')$ in $\prot$, for every $V \subseteq \nats$ finite such that $V$ contains all message values appearing in $\localrun$,  for every $\Vinit \subseteq V$, there exists a "local run" $\localrun': (q, \localdata) \step{*} (q', \localdata')$ such that we have $\length{\localrun'} \leq \towerfun(\size{\prot} + \size{\Vinit},r)$ and:
	\begin{enumerate}
		\item \label{item:shorterrun_anyvalue} for all $\aval' \in \nats \setminus V$, there exists $\aval \in \nats \setminus \Vinit$ such that $\vinput{\aval'}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$,
		\item \label{item:shorterrun_oldvalues} for all $\aval \in V$, $\vinput{\aval}{\localrun'}$ is a subword of $\vinput{\aval}{\localrun}$. 
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	First, we prove that any long portion of $\localrun$ must change the value of every register at least once; otherwise we can shorten the run using an induction on the number of registers. Once we have proven this, we manage to prove that, if $\localrun$ includes twice the same sequence of transitions of sufficient length, then we can cut off anything in the middle and glue back together the ends. While shortening the run we may end up adding some fresh values to the run (see Figure~\ref{fig:pumping} in the appendix), which is not a problem as we ensure that they are always less constraining than the ones that were in the original run. The set $W$ should be thought of as the set of initial values of the run we are trying to shorten, which we do not want new value to mimic for technical reasons.
	The full proof can be found in Appendix~\ref{app:tower-lemma}.
\end{proof}




\begin{remark}
The function $\towerfun(n,k)$ defined above is actually a tower of exponentials of height $k$ where each floor is a polynomial in $n$. Perhaps surprinsingly, this bound is tight in the sense that one may need a "local run" as large as a tower of exponentials to reach a given "local configuration" while being allowed to receive sequences of messages of same value from a given fixed set. 
\end{remark}

% \begin{remark}
% 	The function $\towerfun$ above is a tower of exponentials of height $\regnum$. Perhaps surpringly, this tower bound is tight in the sense that one can find a family of protocols and of "local runs" such that the best $\towerfun$ possible is a tower of exponentials of height linear in $\regnum$. Suppose that we have a protocol $\prot$ and a state $q_f$ such that $q_f$ may only be reached by going exactly $N$ times through some state $q_r$. From $\prot$, we build a "protocol" $\prot'$ with two extra registers $r_0$ and $r_1$; $\prot'$ uses $\prot$ to consider sequences of messages of length $N$ (duplicate $q_r$ into $q_r'$ and $q_r''$ and add transitions in between). Words received by $r_0$ and $r_1$ are of length $N$ with the same value, we see those as binary encodings using $\mathsf{0}, \mathsf{1} \in \messages$. $\prot'$ first requires that $r_0$ receives a word of length $N$ encoding $0$, then iteratively requires that $r_{1-i}$ receives a message encoding value $m+1$ where $m$ is the value last received in $r_i$ (to be able to compare, the words received are of the form $w \#w$ with $w$ of length $N$; the comparison requires to be able to store the value of $i$, whether there is a carry,... which can be done using a third register to avoid a multiplicative factor between sizes of $\prot$ and $\prot'$). We only cover $q_f'$ when word $\mathsf{1}^N$ is received, which is only possible after going exactly $N'$ times through $q_r'$ steps with $N'$ exponential in $N$.
% \nico{à réduire / passer en annexe, idéalement décrire le protocole pour de vrai en annexe avec une figure mais long à faire}
% \end{remark}

\begin{figure}[h]
	\input{Figures/rearrangement-tree}
	\caption{Rearrangement of the tree}
	\label{fig:rearrange-tree}
\end{figure}


Instead, we observe that a node demands input from its "boss" children while it sends output to its "follower" children. We thus rearrange the tree as in Figure~\ref{fig:rearrange-tree}, to make it so that long sequences of messages are sent upwards. We formalize this with the notion of altitude:



\begin{definition}
	We define the ""altitude"" of a node $\node$, written $\altitude{\node}$, in a "unfolding tree" recursively as follows:
	\begin{itemize}
		\item The altitude of the root is $0$
		
		\item The altitude of a "boss node" is the altitude of its father minus one
		
		\item The altitude of a "follower node" is the altitude of its father plus one.
	\end{itemize}
\end{definition}

We now use the previous lemma to bound the label of each node $\node$ with respect to its neighbours of higher altitude, i.e., its "follower" children and its father if it is a "boss node". The idea is that those are the nodes that define the messages that $\localrunlabel{\node}$ should output to satisfy the tree conditions.

\begin{restatable}{lemma}{lemBoundSuccessorHeight}
	\label{lem:bound-successor-height}
	Let $\prot$ be a "protocol" over $\regnum$ registers, let $\node$ be a node of an "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $\bossspec$.
	Let $K$ be such that for all "follower" child $\node_f$ of $\node$, $\size{\followlabelword{\node_f}} \leq K$.
	We have the following properties:
	
	\begin{enumerate}				
		\item  If $\node$ is a "boss node" then 
		\begin{itemize}
			\item If $\node$ is the root of $\tree$ then $\bosslabel{\node} = w$, otherwise $\size{\bosslabel{\node}} \leq \size{\localrunlabel{\node'}}$ with $\node'$ its father
			
			\item In both cases $\size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) + 1)\Big[ \size{\bosslabel{\node}} + \size{\messages}rK \Big]$
		\end{itemize}
		
		\item If $\node$ is a "follower node" then 
		\begin{itemize}			
			\item $\size{\followlabelword{\node}} \leq \size{\localrunlabel{\node}} \leq (\towerfun(\size{\prot},r) +1)\Big[ 1 + \size{\messages}rK \Big]$
			
		\end{itemize}
	\end{enumerate}
\end{restatable}

\begin{proof}[Proof sketch]
	A node $\node$ has at most $\size{\messages}$ "follower" children for each initial value, hence at most $\size{\messages}r$ in total, each one of them requires at most $K$ messages. The node $\node$ may have to output $\bosslabel{\node}$ extra messages to satisfy its specification if it is a "boss node", or just one $\followlabelmessage{\node}$ otherwise.
	
	In all cases we obtain a bound on the number of messages $\localrunlabel{\node}$ needs to broadcast. We mark the positions at which $\localrunlabel{\node}$ sends them and use Lemma~\ref{lem:short-local-runs} to bound the sections of run between two of those broadcasts by $\towerfun(\size{\prot},r)$, yielding the bounds above.
\end{proof}

This lemma lets us bound the labels of the nodes of maximal altitude, and then by applying it inductively we can bound the labels of all nodes at a given altitude $i$ depending on its difference with the maximal one $\altmax-i$ (Lemma~\ref{lem:bound-length-at-height-h}). We then use those results to bound the size of the tree.

 
\begin{restatable}{proposition}{PropBoundTreeSize}
	\label{prop:bound-tree-size}
	There exists a function $f$ of the class $\Ffunction{\omega^{\size{\messages}+1}}$ such that for all "protocol" $\prot$, for all "unfolding tree" $\tree$ of minimal size labelled by $\prot$ satisfying a "boss specification" $w$, the size of $\tree$ is bounded by $f(\size{\prot} + \size{w}+1)$.
\end{restatable}

\begin{proof}[Proof sketch]
	We consider a branch reaching maximal altitude: we mark along that branch all the nodes that have a greater altitude than all the previous ones (see Figure~\ref{fig:max-height-bound}). They are necessarily "follower" nodes as "boss" nodes are below their father. This sequence (reversed) is so that the $i$th term is at altitude $\altmax-i$ and we can bound its size with respect to $i$ with the previous arguments. Along with Lemma~\ref{lem:shortening-branches}, this allows us to apply the "Length function theorem" on that sequence to bound its length, hence we bound the maximal altitude (Lemma~\ref{lem:bound-max-height}).
	
	This yields in turn a bound on the root label, as its altitude ($0$) has a bounded difference with the maximal one. Another application of the "Length function theorem", this time with "boss nodes" lets us bound the minimal altitude of a node of this tree (Lemma~\ref{lem:bound-min-height}).
	
	Once we have bounded both the maximal and minimal altitudes, we can infer a bound on the size of all node labels (Lemma~\ref{lem:bound-node-size}), and then on branches as we can shorten branches as soon as they have two nodes with the same specification.
	The bound on the size of the tree then follows from the observation that as nodes have bounded local runs, they only see a bounded amount of values and thus need a bounded amount of children.
\end{proof}


\subsection{Decidability}
\label{sec:decidability-end}

We have shown that "unfolding trees" were a sound and complete abstraction for coverability in Section~\ref{sec:decidability-tree-unfoldings} and proven that there was a computable bound (of the class $\Ffunction{\omega^\omega}$) on the size of a minimal "unfolding tree" witnessing coverability, if it exists, in Sections~\ref{sec:tree-bounds}. Essentially, we then obtain decidability of the problem via the procedure computing that bound and then enumerating all trees below that size, checking for each one of them whether it is a valid "unfolding tree" witnessing coverability. We are skipping some details here, which are treated in the proof in Appendix~\ref{app:decidability}

\decidablecover*


