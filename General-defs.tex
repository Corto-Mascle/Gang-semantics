\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Definitions of the model}
A ""Broadcast Network of Register Automata"" (BNRA) \cite{DelzannoST13} is a model describing a network of agents with local registers communicating by broadcasts. It is represented by a finite transition system describing the behaviour of an agent, which can broadcast and receive messages with integer values, store them in local registers, or make equality tests. 
We consider that when a message is broadcast by an agent, each other agent independently may or may not receive it. 
We study the set of runs of an arbitrary number of agents communicating this way.

\begin{definition}[Protocols]
	A ""protocol"" with $\regnum$ registers is a tuple $\prot = (Q, \messages, \transitions, q_0)$  with $Q$ a finite set of states, $q_0 \in Q$ an initial state, $\messages$ a finite set of ""messages""  and $\transitions \subseteq Q \times \operations \times Q$ a finite set of transitions, with 
	\begin{multline*}
	\operations = \set{\br{\amessage}{i}, \rec{\amessage}{i}{\dummyact}, \rec{\amessage}{i}{\enregact}, \rec{\amessage}{i}{\eqtestact}, \rec{\amessage}{i}{\diseqtestact} \mid \amessage \in \messages, 1 \leq i \leq \regnum} \\ \cup  
	\set{\loc{i}{j}{\eqtestact}, \loc{i}{j}{\diseqtestact} \mid 1 \leq i,j \leq \regnum}
	\end{multline*}
	the set of operations.
	
	Transitions labelled with $\brsymb$ are ""broadcasts"", transitions labelled with $\recsymb$ are ""receptions"" and transitions labelled with $\locsymb$ are ""local tests"".
	Given a reception $\rec{\amessage}{i}{\anact}$ or a local test $\loc{i}{j}{\anact}$, $\anact$ is the ""action"" of the reception (resp. local test). 
The set of actions is $\actions := \set{\eqtestact, \diseqtestact, \enregact, \dummyact}$, where 
$\quotemarks{\eqtestact}$ is an equality test, $\quotemarks{\diseqtestact}$ is a disequality test, $\quotemarks{\enregact}$ is a store action and $\quotemarks{\dummyact}$ is a dummy action with no effect.
The size of $\prot$, written $\size{\prot}$, is defined as $\size{Q} + \size{\messages} + \size{\transitions} + r$.
\end{definition}



We now define the semantics of those systems. Essentially, we have a finite set of agents, each with their own registers, which initially all contain distinct values. A step of a run consists in either one agent executing a local action, or one agent broadcasting a message and some of the other agents receiving it.

\begin{definition}[Semantics]
	Let $(Q,\messages, \transitions, q_0)$ be a "protocol" of $\regnum$ registers, and $\agents \subseteq \nats$ a finite set of \emph{agents}.
	A ""configuration"" over a set of agents $\agents$ is a labelling function $\config : \agents \to Q \times \nats^{\regnum}$, mapping each agent to a state and ""register values"" for each of its registers. 
	We write $\st{\config}$ for the state component of $\config$ and $\data{\config}$ for its register component.
	An \emph{initial configuration} $\config$ is one where for all $a \in \agents$, $\st{\config}(a) = q_0$ and for all $a, a' \in \agents$, $i, i' \in \nset{1}{\regnum}$, if $\data{\config}(a, i) = \data{\config}(a', i')$ then $a=a'$ and $i=i'$.
	
	\AP We denote by $\configs{\agents}$ the set of configurations over $\agents$, and by $\allconfigs := \cup_{\agents \subseteq \nats \text{ finite }} \configs{\agents}$ the set of all configurations. Given a configuration $\config$, we denote by $\agentsof{\config}$ the set of agents of $\config$.
	
	\AP Given two configurations $\config, \config' \in \configs{\agents}$, a ""step"" $\config \step{} \config'$ is defined when one of the two following conditions is satisfied:
	\begin{itemize}
		\item there exists $a \in \agents$ and a "local test" $(\st{\config}(a), \loc{i}{j}{\anact}, \st{\config'}(a)) \in \transitions$ such that for all $a'\neq a$, $\config(a') = \config'(a')$ and
		\begin{itemize}
			\item either $\anact = \quotemarks{\eqtestact}$ and $\data{\config}(a,i) = \data{\config}(a,j)$
			
			\item or $\anact = \quotemarks{\diseqtestact}$ and $\data{\config}(a,i) \neq \data{\config}(a,j)$
		\end{itemize}
		
		\item there exist $\amessage \in \messages$, $a_0 \in \agents$ and $i \in \nset{1}{r}$ such that $(\st{\config}(a_0),\br{\amessage}{i}, \st{\config'}(a_0)) \in \transitions$, $\data{\config}(a_0) = \data{\config'}(a_0)$ and for all $a \in \agents\setminus \set{a_0}$, either $\config'(a) = \config(a)$ or there exists a transition $(\st{\config}(a),\rec{m}{j}{\anact},\st{\config'}(a))$
		such that $\data{\config'}(a, j') = \data{\config}(a, j')$ for all $j' \neq j$ and one of the following cases holds:
		\begin{itemize}
				\item $\anact = \quotemarks{\dummyact}$ 
				and $\data{\config'}(a,j) = \data{\config}(a,j)$
				\item $\anact = \quotemarks{\enregact}$ and $\data{\config'}(a,j) = \data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\eqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) =\data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\diseqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) \ne \data{\config}(a_0,i)$
			\end{itemize}
		\end{itemize}
	
	\AP A ""path"" is a sequence of steps $\apath : \config_0 \step{} \config_1 \step{} \cdots \step{} \config_k$. 
	We write $\config_0 \step{*} \config_k$ when there exists such a path.
	A ""run"" is a path whose first configuration is an "initial configuration"; runs are denoted with the letter $\run$.  
	Given such a "run" $\run$, we write $\agentsof{\run}$ its set of agents, $\statesin{\run}:= \set{q \in Q \mid \exists i, \exists a, \st{\config_i}(a) = q}$ the set of states appearing in $\run$ and $\valsof{\run} := \set{\aval \in \nats \mid \exists i,j, a, \data{\config_i}(a,j) = \aval}$.  
% We write $\Runs{\prot}$ for the set of runs of $\prot$.
	% with current definition, every run is initial
	
	\AP A run $\run: \config_0 \step{*} \config_f$ ""covers"" a state $q \in Q$ when there exists $a \in \agents$ such that $\st{\config_f}(a) = q$. 
\end{definition}
\begin{example}\label{example-1}
	We give an example of a "protocol" with 2 registers in Figure \ref{fig:ex1}. Its set of states is $\{q_i\}_{0 \leq i \leq 6}$, and the initial state is $q_0$. Let $\agents = \{a_1, a_2, a_3, a_4\}$ and let $(x_i, y_i)_{1 \leq i \leq 4} \in \mathbb{N}$ be 8 different integers. The function $\config_0$ associating to each agent $a_i$ the element $(q_0, (x_i, y_i))$ is an initial configuration over $\agents$. There exists a run covering $q_6$: from $\config_0$, let agent $a_1$ broadcast message $m_1$ among with its value $x_1$, the reached configuration $\config_1$ should be such that: $\st{\config_1}(a_1)= q_1$, $\st{\config_1}(a_3)= q_2$, $\data{\config_1}(a_1)(1) = \data{\config_1}(a_3)(1) = x_1$. Let now agent $a_2$ broadcast message $m_2$ among with its value $x_2$ and let agent $a_4$ receives the message. The resulting configuration $\config_2$ is such that $\st{\config_2}(a_2)= q_1$, $\st{\config_2}(a_4)= q_5$, $\data{\config_2}(a_2)(1) = \data{\config_2}(a_4)(1) = x_2$. From $\config_2$, agent $a_1$ can broadcast message $m_3$ among with its value $x_1$, let agent $a_4$ receives its value, as $\data{\config_2}(a_4)(1) = x_2 \ne x_1 = \data{\config_2}(a_1)(1)$, agent $a_4$ can take the reception transition leading to $q_6$. Hence, the resulting configuration $\config_3$ is such that $\st{\config_3}(a_4)= q_6$. 
\end{example}

\begin{figure}
	\input{Figures/fig-ex1}
	\caption{Example of a "protocol".}\label{fig:ex1}
\end{figure}
	
	
The following remark formalizes the intuition that, because the only way to take a new register value is to receive another agent's value, no new register values are created in a "run".
\begin{remark}
	\label{rem:run_no_new_register_values}
	Because a register may only change its value to one that is broadcast from another register, we have that for all $\run: \config_0 \step{*} \config_f$, $\valsof{\run} = \set{\aval \in \nats \mid \exists a, \, \data{\config_0}(a) = \aval}$.
\end{remark}

\begin{remark}
	\label{rem:copycat-principle}
	We make the following observation: from a "run" $\run : \config_0 \step{\ast} \config$, we can build a run in which each agent of $\run$ has as a clone in the same state but with different registers' values. 
%	For instance, we proved in Example \ref{example-1} that there exists a run covering state $q_6$, take the same execution with 8 agents, 
	
	Starting with the initial configuration with each agent of $\run$ and their clones, original agents from $\run$ perform the sequences of steps of $\rho$. Then, the set of clones perform the same sequence. 
	Note that original agents and cloned agents do not share any registers' value. As a consequence, the copy of the run only allow us to copy some agents in a certain state but not their registers' values. We will refer to this notion as the ""copycat principle"": if a certain state is coverable, then for any integer $n$ there exists an execution which puts $n$ agents on the coverable state (each agent has $n$ clones), however, none of this $n$ agents share the same register values.
	
%	In the "protocol" of Example \ref{example-1}, take a run with two agents, one broadcasts message $m_2$ among with its first register value which is received by the second agent which stores the value in its first register. The first agent is in $q_1$ and the second in $q_5$. The second agent then broadcasts message $m_4$ among with the value of its second register, received by the first agent which stores it in its second register. The wo agents are in $q_4$ and share the same registers' values. We can copy the "run": consider four agents, the two first agents perform the described sequence and reach a configuration in which two agents are in $q_4$ and share same registers' values and the two other agents  
	
%	 \lu{faire un parall√®le avec l'exemple?}
	
	
\end{remark}

	
	\begin{definition}
		We define a preorder over the set of configurations $\allconfigs$ as follows: $\config \lessthan \config'$ if there exists an injective function $\pi: \agentsof{\config} \rightarrow \agentsof{\config'}$ such that, for all $a \in \agentsof{\config}$, $\config(a) = \config'(\pi(a))$. 
	\end{definition}
	
%	\begin{definition}
%		A ""query"" $\query$ is a finite set of formulas of the form $\quotemarks{q(\var{z})}$, $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z}')}$, $\quotemarks{R_j(\var{z}) \neq R_{j'}(\var{z}')}$, with $\var{z}, \var{z}'$ taken in a set of variables $\varset$ and $j,j' \in \nset{1}{r}$.
%		It is \emph{satisfied} by a "configuration" $\config$ if there is a valuation $\nu : \varset \to \agentsof{\config}$ such that:
%		\begin{itemize}
%			\item for all $\quotemarks{q(\var{z})} \in \query$, $\st{\config}(\nu(\var{z})) = q$,
%			
%			\item for all $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z'})} \in \query$, $\data{\config}(\nu(\var{z}))(j) = \data{\config}(\nu(\var{z'}))(j')$,
%			
%			\item for all $\quotemarks{R(\var{z}) \neq R(\var{z'})} \in \query$, $\data{\config}(\nu(\var{z}))(j) \neq \data{\config}(\nu(\var{z'}))(j')$.
%		\end{itemize}
%		
%		\AP The ""query coverability problem"" is to determine, given a "protocol" and a "query", whether there is a "run" of this protocol whose last "configuration" satisfies the query.
%	\end{definition}
\begin{definition}

	\AP The ""cover problem"" is to determine, given a "protocol" and a state $q_f$, whether there is a "run" of this protocol whose last "configuration" satisfies the "query" with the single formula $\quotemarks{q_f(\var{z})}$.
	
	\AP The ""target reachability problem"" is to determine, given a "protocol" and a state $q$, whether there is a "run" of this protocol with a non-empty set of agents whose last "configuration" $\config$ is such that $\st{\config}(\agentsof{\gamma}) = \{q_f\}$, i.e all agents reached $q_f$.
	
%	\begin{remark}
%		\label{rem:bigger_config_query}
%		If some "configuration" $\config$ satisfies a "query" $\query$, then every configuration $\config'$ such that $\config \lessthan \config'$ satisfies $\query$. 
%	\end{remark}
	
	%We say that it is ""initial@@run"" if $\config_0$ is an initial configuration.
\end{definition}

\begin{example}\label{example-2}\lu{feel free to reformuler}
	In \cref{example-1}~we gave an example of an execution covering $q_6$, however, as an agent on $q_1$ should never be able to reach $q_6$, the protocol displayed in Figure \ref{fig:ex1}~among with state $q_6$ is not a positive instance of the "target reachability problem". However it would be if the final state were $q_1$: from an initial configuration all agents broadcast $m_1$ one-by-one and the message is never received. Note as well that some state might not be coverable: take for instance $q_3$, in order to reach $q_3$, we must reach a configuration $\config$ in which some agent $a$ is on $q_2$, some agent $a'$ is on $q_5$ and they both share the same value on their first register. First register's value of agent $a$ is herited from a an agent who broadcast message $m_1$ whereas first register's value of agent $a'$ is herited from a an agent who broadcast message $m_2$. Observe that one agent can not send $m_1$ and $m_2$, therefore, it must be that the two messages have been sent by two different agents as in the execution we gave in \cref{example-1}. As a consequence, their first registers' values can not be the same.
\end{example}

\begin{remark}
	In \cite{DelzannoST13}, the authors considered ``queries'', which are conjunctions of formulas of the form $\quotemarks{q(\var{z})}$, $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z}')}$, $\quotemarks{R_j(\var{z}) \neq R_{j'}(\var{z}')}$, with $\var{z}, \var{z}'$ taken in a set of variables $\varset$, $q$ a state and $j,j' \in \nset{1}{r}$. A configuration satisfies a query $\query$ if we can assign agents to each of the variables of $\query$ so that all conjuncts are satisfied.
	In this paper we will only study the "cover problem", but we argue here that we can reduce from the query satisfaction problem to it:
	
	Given a "protocol" $\prot$ with $r$ registers and a "query" $\query$ with $k$ variables, we can construct a "protocol" $\prot'$ with $\size{\prot}^k$ states and $kr$ registers that allows each agent to simulate $k$ agents of the previous system (by taking as states $k$-tuples of states of $\prot$, using the $kr$ registers to store the values of the registers of the $k$ agents and adapting the transitions accordingly).
	There is a run of the first BNRA satisfying $\query$ if and only if there is a run of the second in which one agent simulates the $k$ agents satisfying $\query$, which can be checked locally by that agent, which enters a special state $q_f$. if it happens. 
	
	This reduction is exponential, but this does not hinder our complexity result as we are concerned with a complexity class stable by exponential reductions.
	
	In the case of one register, we even have a polynomial-time reduction: We add a transition from every state to a sink state allowing an agent to stop at any moment and send its local configuration (state and register value) in a single broadcast.
	Also, at any moment, an agent may enter a series of transitions in which it receives the configurations of $k$ agents and checks that they satisfy the query, then enters a special state $q_f$. An agent can reach $q_f$ if and only if some agents could reach a configuration satisfying $\query$ in the first BNRA.
\end{remark}

In fact, we may get rid of "local equality tests" at the cost of an exponential blowup in the number of states.

\begin{restatable}{proposition}{SimpleReduction}
	\label{prop:loc-eq-test-elimination}
	There is an exponential-time reduction from the general "coverability problem" to the coverability problem on protocols with no "local equality tests" $\loc{i}{j}{=}$.
\end{restatable}
The intuition is as follows: from a protocol $\prot$, we build a protocol $\prot'$ whose registers are used to store values of multiple registers of $\prot$ at the same time, so that equality of two registers of $\prot$ correspond to a condition on the states in $\prot'$. To do so, one must store in any state of $\prot'$ which register of $\prot$ is mapped to which register of $\prot'$, hence the exponential blowup. The full proofs may be found in Appendix~\ref{sec:proof-lol-eq-test-elim}.
%\ifbasic
%\section{Basic properties}

%\begin{lemma}[Weak copycat]\label{lem:weak_copycat}
%	Let $q \in Q$ and  $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ such that $\st{\config_f}(a_m) = q$. There exists $\agents' \subseteq \nats$ finite s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \agents'$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents'$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ end the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in\nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f}(a_m) = \st{\config_f'}(a_c)$.
%	\end{itemize}
%\end{lemma}


%\ifproofs
%\begin{proof}
%	Let $\agents' \subseteq \nats$ such that $|\agents'|= |\agents|$ and $\agents \cap \agents' = \emptyset$.
%	There exists a bijection $\psi: \agents \mapsto \agents'$. Let $\config_0'$ an initial configuration over $\agents \cup \agents'$ which is equal to $\config_0$ on every agent of $\agents$. 
%	The constructed "run" $\run'$ starts on configuration $\config_0'$ and is composed of two parts. 
%	The first part consists in mimicking the sequence of steps of $\run$ with agents of $\agents$, while agents in $\agents'$ remain idle. This defines a run $\run_p' : \config_0' \step{*}  \config_m'$.  
%	The second part consists in a path $\apath': \config_m' \step{*} \config_f'$ which replicates the sequence of actions of $\run$ but on agents of $\agents'$: if an agent $a \in \agents$ takes a transition at step $i$ of $\run$, we make $\psi(a)$ take that transition at step $i$ of $\apath'$. As $\apath'$ is identical to $\run_p'$ up to renaming of the agents and values, a straightforward induction shows that this is always a valid transition.
%	In this second part, agents of $\agents$ are left idle. $\run'$ is obtained by concatenating $\run_p'$ and $\apath'$. Since agents of $\agents$ behave the same in $\run$ and $\run'$, for all $a \in \agents$, $\config_f(a) = \config_f'(a')$. Also, $\psi(a_m)$ took the same transitions as $a_m$ hence $\st{\config_f}(\psi(a_m)) = q$. Finally, thanks to Lemma~\ref{prop:run_no_new_register_values}, the register values of agents of $\agents'$ are in the set $\data{\config_0'}(\agents')(\nset{1}{r})$ while the register values of agents of $\agents$ are in $\data{\config_0'}(\agents)(\nset{1}{r})$; both sets are disjoint as $\config_0'$ is initial and thus for all $a \in \agents, a' \in \agents'$, $j,j' \in \nset{1}{r}$, $\data{\config_f'}(a) \ne \data{\config_f'}(a'_q)$.
%\end{proof}
%\fi

%\begin{lemma}[Strong copycat]\label{lem:strong_copycat}
%	Let $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ and register $j_m \in \nset{1}{r}$ such that $\data{\config_f}(a_m)(j_m) \ne \data{\config_0}(a_m)(j_m)$. % note that this condition may be relaxed to : a_m's register value did not stay the same throughout all of $\run$. 
%	There exist $\agents' \subseteq \nats$ s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \nats\setminus (\agents \cup \agents')$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents' \cup \set{a_c}$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ behave the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in \nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f'}(a_c) = \st{\config_f'}(a_m)$ and $\data{\config_f'}(a_c)(j_m) = \data{\config_f'}(a_m)(j_m)$.
%	\end{itemize}
%\end{lemma}
%\begin{proof}
%	Write $\aval := \data{\config_f}(a_m)(j_m)$. 
%	
%	
%	Since $a_m$ does not start with $v$ in register $j_m$, $a_m$ does a $\quotemarks{\enregact}$ action in $\run$.
%	Decompose $\run$ into $\run_p: \config_0 \step{*} \config_{m,1}$, $\path_i: \config_{m,1} \step{} \config_{m,2}$ and $\path_s: \config_{m,2} \step{*} \config_f$ where $\path_i$ is the step where $a_m$ does a $\quotemarks{\enregact}$ action for the last time; write $(q,\rec{\amessage}{\enregact},q') \in\transitions$ the transition taken by $a_m$ in $\path_i$. By applying the weak copycat (Lemma~\ref{lem:weak_copycat}) on $\run_p : \config_0 \step{*} \config$, we add an agent $a_c$ on state $q$ at the cost of adding a set of agents $\agents'$ whose data is disjoint from  the one of agents in $\agents$. Agents of $\agents'$ are left idle in subsequent steps. We make $a_c$ take the $\quotemarks{\enregact}$ transition at the same time as $a_m$, so that they are both on $q'$ with value $v$. We finally make $a_c$ mimick $a_m$ throughout $\path_s$: to do so, whenever $a_m$ takes a reception transition, we make $a_c$ take the same transition in the same step (which is possible as they have the same register value). When $a_m$ broadcasts, we duplicate the broadcast step to make $a_c$ broadcast immediately after, although no agent receives $a_c$'s broadcast. We end up with $a_m$ and $a_c$ on the same state with the same register value, which concludes the proof. 
%\end{proof}
%
%\begin{corollary}
%	\label{cor:removing_diseq_tests}
%	Let $(\prot, \query)$ an instance of the "query coverability problem". This instance is positive if and only if $(\tilde{\prot}, \query)$ is positive, where $\tilde{\prot}$ is equal to $\prot$ where every disequality test $\quotemarks{\diseqtestact}$ is replaced by dummy action $\quotemarks{\dummyact}$.  
%\end{corollary}
%
%\ifproofs
%\begin{proof}
%	First, if $(\prot, \query)$ is positive then so is $(\tilde{\prot}, \query)$, as one can easily lift any "run" in $\prot$ to an equivalent "run" in $\tilde{\prot}$ (transitions are less guarded  in $\tilde{\prot}$ that in $\prot$). 
%	
%	Suppose now that $(\tilde{\prot}, \query)$ is a positive instance of the "query coverability problem". There exists a "run" $\tilde{\run}: \tilde{\config}_0 \step{*} \tilde{\config}$ in $\tilde{\prot}$ that satisfies $\query$. We prove by induction on the length of $\tilde{\run}$ that there exists a "run" $\run$ reaching a configuration $\config$ such that $\tilde{\config} \lessthan \config$ (Remark~\ref{rem:bigger_config_query} then allows us to conclude). 
%	
%	If $\config = \config_0$ then $\run = \tilde{\run}$ suffices. Suppose that $\tilde{\run}$ has length $k \geq 1$, and that the result if true for "runs" of length $k-1$. Decompose $\tilde{\run}$ into $\tilde{\run_{k-1}}: \tilde{\config_0} \step{*} \tilde{\config_{k-1}}$ of length $k-1$ and a final step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. 
%	By induction hypothesis, there exists $\run_{k-1}: \config_0 \step{*} \config_{k-1}$ such that $\tilde{\config_{k-1}} \lessthan \config_{k-1}$: there exists an injective function $\pi : \tilde{\agents} \rightarrow \agents$
%	such that, for all $a \in \tilde{\agents}$, $\tilde{\config_{k-1}}(a) = \config_{k-1}(\pi(a))$, where $\tilde{\agents} := \agentsof{\tilde{\run}}$ and $\agents := \agentsof{\run}$. If $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ involves no reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$, then we directly lift this step into a step appended at the end of $\run_{k-1}$ (making $\pi(a)$ take a transition whenever $a$ does so in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$). Otherwise, write $\tilde{\agents}_{\diseqtestact}$ the subset of $\tilde{agents}$ corresponding to agents taking in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ a reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$ . Write $(q, \br{m}, q') \in \transitions$ the broadcast transition used in this step.  Using Lemma~\ref{lem:copycat}, we add to $\config_{k-1}$ a fresh agent $a_{\mathsf{new}}$ with state $q$ and a register value that do not appear in $\config_{k-1}$. 
%	We first mimick this broadcast step at the end of $\run_{k-1}$, making any agent $\pi(a) \in \pi(\tilde{\agents} \setminus \tilde{\agents}_{\diseqtestact})$ take the transition that $a$ takes in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. We then add a new step where $a_{\mathsf{new}}$ broadcasts using transition $(q, \br{m}, q')$, and every agent $\pi(a) \in \pi(\tilde{\agents}_{\diseqtestact})$ takes the transition corresponding to the transition taken by $a$ in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. Such a transition is a reception with action $\quotemarks{\diseqtestact}$ in $\prot$; however, because $a_{\mathsf{new}}$ does not share its register value with any process from $\tilde{\agents}$, all disequality conditions are satisfied and this step is valid. In this end, every agent $\pi(a) \in \pi(\tilde{\agents})$ has taken the transition in $\prot$ corresponding to the one $a$ took in $\tilde{\prot}$ in step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$, hence the configuration $\config_k$ reached by the constructed run is such that $\tilde{\config_k} \lessthan \config_k$. 
%\end{proof}
%\fi
%
%Thanks to Corollary~\ref{cor:removing_diseq_tests}, we shall from now on assume that all considered protocols have no disequality tests. 
%
%\begin{definition}
%	Given a set of states $K \subseteq Q$, we say that a pair $\config, \aval$ with  $\config$ a "configuration" over a set of agents $\agents$ and $\aval \in \nats$ satisfies $K$ if for all $q \in K$, there exists $a \in \agents$ such that $\config(a) = (q,\aval)$.
%	A configuration $\config$ satisfies $K$ if there exists $\aval \in \nats$ such that $\config, \aval $ satisfies $K$. 
%	A "run" satisfies $K$ if its final configuration does.
%\end{definition}
%Note that if a "run" satisfies $K$, then it covers every state in $K$. The converse is not true as, in order to satisfy $K$, one needs to have agents of every state of $K$ that all share the same register value. See for instance the example below.
%
%\begin{example}
%	Consider the "protocol" displayed in Figure~\ref{fig:no-clique}.
%	We can obtain configurations satisfying $\set{1,2}$, $\set{2,3}$ or $\set{1,3}$, but we cannot obtain one satisfying $\set{1,2,3}$.
%	
%	\begin{figure}[h]
%		\input{Figures/fig-no-clique}
%		\caption{An illustrating example}
%		\label{fig:no-clique}
%	\end{figure}
%\end{example}
%
%
%
%\begin{definition}
%	We say that a "query" $\query$ is ""contradictory"" if either:
%	\begin{itemize}
%		\item there exists $\varz$ and $q \neq q' \in Q$ such that $\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$ or
%		
%		\item there exist $\var{z_1}, \ldots, \var{z_k} \in \varset$ and $j_1, \ldots, j_k$ with $k\geq 1$ such that $\quotemarks{R_{j_i}(\varz_{i}) = R_{j_{i+1}}(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R_{j_k}(\varz_k) \neq R_{j_1}(\varz_1)} \in \query$.
%	\end{itemize}
%\end{definition}
%
%\begin{proposition}
%	A "query" $\query$ is "contradictory" if and only if there exists no configuration satisfying $\query$. Additionnaly, one may decide whether $\query$ is contradictory in time polynomial in $\size{\prot} + \size{\query}$. 
%\end{proposition}
%
%\ifproofs
%\begin{proof}
%	Suppose first that $\query$ is "contradictory". If there exist $q \ne q'$ such that
%	$\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$,  then a "configuration" satisfying $\query$ would need to have a single agent in two distinct states. If there exist $\var{z_1}, \ldots, \var{z_k}$ distinct variables with $k\geq 1$ such that $\quotemarks{R(\varz_{i}) = R(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R(\varz_k) \neq R(\varz_1)} \in \query$, then in any configuration satisfying $\query$,  the registers associated with $\varz_k$ and $\varz_1$ must have the same register value but also distinct register values, which is a contradiction. 
%	
%	Suppose now that the $\query$ is not "contradictory" and show that there exists some configuration satisfying $\query$.
%	
%	We consider the graph $G$ whose vertices are variables of $\varset$ appearing in $\query$ and with an edge between $\varz$ and $\varz'$ if and only if $R(\varz) = R(\varz') \in \query$. Since $\query$ is not "contradictory", for any $\varz, \varz'$ in the same connected component of $G$, $\quotemarks{R(\varz) \ne R(\varz')} \notin \query$. We construct a configuration satisfying $\query$ with an agent $a_\varz$ for every $\varz$ such that:
%	\begin{itemize}
%		\item if $\quotemarks{q(\varz)} \in \query$ then $a_\varz$ is in state $q$,
%		\item the agents of the variables of a connected component of $G$ have all the same register value.  
%	\end{itemize}
%	The built configuration satisfies $\query$, which concludes the proof. 
%\end{proof}
%\fi
%
%\begin{lemma}
%	\label{lem:query-decomposition}
%	Let $\query$ a  "non-contradictory" "query". There exist $K_1, \ldots, K_p \subseteq Q$ with $p \leq \size{\query}$ with the following property: there exists a "run" satisfying $\query$ if and only if for all $i \in \set{1,\ldots, p}$, there is a run satisfying $K_i$. Moreover,such sets $K_1, \dots, K_p$ may be computed in time polynomial in $\size{\prot}$. 
%\end{lemma}
%
%
%\ifproofs
%\begin{proof}
%	
%	We consider the same graph $G$ as in the previous proof. We decompose $G$ into connected components $C_1, \ldots, C_p$. 
%	For each $C_i$ we define $K_i = \set{q \in Q \mid \exists \varz \in C_i, q(\varz) \in \query}$. Note that $K_i$ may be empty when there is no constraints on the states of the variables in $C_i$. An empty set is satisfied by any "run". This is coherent with the fact that, when $K_i = \emptyset$, it suffices to assign all variables in $C_i$ to an agent that stays in $q_0$ for the whole "run".
%	
%	Suppose there is a "run" satisfying $\query$, let $\config$ be its final configuration, let $\nu$ be a valuation witnessing the satisfaction of $\query$ by $\config$.
%	Let $i \in \set{1,\ldots, p}$, we show that $\config$ satisfies $K_i$. For all $\varz \in C_i$, let $(q_\varz,\aval_\varz) = \config(\nu(\varz))$. As $C_i$ is a connected component of $G$ and $\config$ satisfies $\query$, all $\nu(\varz)$ with $\varz \in C_i$ have the same register value, which we call $\aval$. 
%	For all $q \in K_i$, there exists $\varz \in C_i$ such that $q(\varz) \in \query$ and thus $q_\varz =q$ and $\aval_\varz =\aval$, thus $C_i$ is satisfied.
%	
%	For the converse implication, suppose for all $i$ we have a run $\run_i$ over a set of agents $\agents_i$ satisfying $K_i$. We rename agents so that the $\agents_i$ are pairwise disjoint, we introduce fresh agents $a_1, \ldots, a_p$ and we set $\agents = \set{a_1, \ldots, a_p} \sqcup \bigsqcup_{i=1}^p \agents_i$. We consider $\run: \config_0 \step{*} \config$ a "run" in which the sequences of actions of each $\run_i$ are executed sequently by agents from $\agents_i$. In $\run$, agents $a_1$ to $a_p$ are left idle on $q_0$. We build the valuation $\nu$ witnessing that $\run$ satisfies $\query$ as follows. Let $i \in \nset{1}{p}$. If $K_i = \emptyset$ then $\nu$ assigns $a_i$ to every variable of $C_i$. Otherwise, we know that $\config|_{\agents_i}$ satisfies $K_i$ because the final configuration of $\run_i$ does: there exists $\aval_i \in \nats$ such that, for all $q \in K_i$, some agent $a_{i,q}$ has state $q$ and register value $\aval_i$ in $\config$. Let $\varz \in C_i$. If, for some $q \in Q$, $\quotemarks{q(\varz)} \in \query$, $\nu$ assigns agent $a_{i,q}$ to $\varz$ ($q$ is unique as $\query$ is not "contradictory"). If $\query$ has no constraint about the state of $\varz$, $\nu$ assigns to $\varz$ some $a_{i,q}$ with $q \in k_i$ arbitrary. 
%	
%	% We define a valuation $\nu$ as follows. Let $\varz \in \varset$ and $i$ so that $C_i$ is the connected component of $\varz$ in $G$. If  for some $q$, then this $q$ is unique as $\query$ is not "contradictory". We set $\nu(\varz) = a_q^i$.
%	% If there is no $q(\varz)$ for any $q \in Q$ in $\query$ but there is one of the form $q'(\varz')$ with $\varz' \in C_i$, then we set $\nu(\varz) = \nu(\varz')$.
%	% Otherwise we set $\nu(\varz) = a_i$.
%	% This fully defines our valuation $\nu$.
%	
%	Clearly all formulas of the form $q(\varz)$ or $R(\varz) = R(\varz')$ are satisfied.
%	For the formulas of the form $R(\varz) \neq R(\varz')$, we observe that as $\query$ is not "contradictory", $\varz$ and $\varz'$ are not in the same connected component of $G$. Because the runs $\run_i$ worked with disjoint sets of register values ($\config_0$ is initial), the agents assigned to $\varz$ and $\varz'$ end the run with distinct register values.
%	Hence $\data{\config}(\nu(\varz)) \neq \data{\config}(\nu(\varz'))$. As a result, $\query$ is satisfied by $\run$.
%\end{proof}
%\fi
%\fi


\subsection{Classical definitions}
\luin{here comes definitions of complexity classes, wqo and anything not related to our model}

\paragraph*{Fast-growing hierarchy}

For $\alpha$ an ordinal in Cantor normal form, we will denote by $\Ffunction{\alpha}$ the class of functions corresponding to level $\alpha$ in the Fast-Growing Hierarchy. We will moreover denote by $\Fcomplexity{\alpha}$ the associated complexity class and use the notion of $\Fcomplexity{\alpha}$-completeness. All these notions are defined in \cite{Schmitz16}. We will specifically work with complexity class $\Fcomplexity{\omega^{\omega}}$. For readers unfamiliar with these notions, $\Fcomplexity{\omega^{\omega}}$-complete problems are problems which are decidable but with very high complexity (they are non-primitive recursive, and even hyper-Ackermannian). 

We highlight that our main result is the decidability of the problem. In fact, proving that the problem lies in $\Fcomplexity{\omega^{\omega}}$ does not complicate our decidability proof significantly. Moreover, this result fits nicely into the landscape of high-complexity problems arising from well quasi-orders. 

\paragraph*{Well-quasi orders}

In order to prove our main decidability result, we rely on the theory of well quasi-orders in the context of the subword ordering.
Let $\Sigma$ be a finite alphabet, $w_1, w_2 \in \Sigma^*$, $w_1$ is a ""subword"" of $w_2$, denoted $w_1 \subword w_2$, when $w_1$ can be obtained from $w_2$ by erasing some letters. 
A sequence of words $w_0, w_1, \ldots$ is ""good"" if there exist $i<j$ such that $w_i \subword w_j$, and ""bad"" otherwise. Higman's lemma \cite{Higman52} states that every "bad" sequence of words over a finite alphabet is finite.
However, this will not suffice us as we will need a bound the length of a "bad" sequence. In order to obtain such a bound, it is necessary to bound the growth of the sequence of words. 
We will use the following result, known as the "Length function theorem" \cite{SchmitzS2011upperHigman}:

\begin{theorem}[Length function theorem \cite{SchmitzS2011upperHigman}]
	\label{thm:lengthfcttheorem}
	Let $\Sigma$ be a finite alphabet, let $g : \nats \to \nats$ be a primitive recursive function, $n\in \nats$.
	Then there exists a function $f \in \Ffunction{\omega^{\size{\Sigma} - 1}}$ such that every "bad sequence" $w_0, w_1, \ldots$ such that $\size{w_i} \leq g^{(i)}(n)$ for all $i$ is of length at most $f(n)$. 
\end{theorem}



\subsection{Link with LCS}

""Lossy channel systems"" ("LCS") are systems where finite-state processes communicate via sending messages from a finite alphabet through unbounded FIFO channels through which messages may be lost. The reachability problem asks whether a given control state of the system may be covered. Unlike in the non-lossy case \cite{BZ83}, reachability is decidable for "lossy channel systems" \cite{AbdullaK95,AbdullaJ1996undec}, but is proven to have non-primitive recursive complexity \cite{Schnoebelen2002verifying} and is in fact $\Fcomplexity{\omega^{\omega}}$-complete \cite{ChambartS08ordinal}.

We argue that the "coverability problem" in BNRA is at least as hard as the reachability problem for "LCS", even with two registers. The reduction can be found in Appendix~\ref{app:reduction-lcs}; we provide here some intuition. Given a LCS $\los$, we build a protocol $\prot$ with two registers. For each agent, the first register should never be modified and can be seen as an identifier. At the beginning of the execution, each agent receives a foreigner identifier and stores it in its second register; in the latter, it should only accepts messages sent by this identifer (using an $\quotemarks{\eqtestact}$ on every reception). This way, agents will form chains where messages propagate in one direction only, with the property that an agent has at most one predecessor in the chain. Each agent of the chain will simulate a step of an execution of $\los$: an agent received from its predecessor a configuration of $\los$, chooses the next configuration of $\los$ and broadcasts it, sending first the location of $\los$ then, letter by letter, the content of the channel. Note that some letters of the channel might not be received, hence the lossiness. 
% Note that one special agent has to start the execution, and send the initial configuration before receiving anything. The final state is the final state of the "LCS" and if one agent reaches it, one can argue that there is an execution of the "LCS" described by the sent messages in the chain of agent starting with an agent sending the initial configuration.

\begin{restatable}{proposition}{propReductionLCS}
	\label{prop:reduction-LCS}
	The "coverability problem" for BNRAs is $\Fcomplexity{\omega^\omega}$-hard.
\end{restatable}

%The proof is in Appendix~\ref{app:reduction-lcs}.

\begin{remark}
	The reduction presented in the proof of Proposition~\ref{prop:reduction-LCS} can be adapted to show that the repeat coverability problem is undecidable for BNRA, as it is for LCS.
\end{remark}

