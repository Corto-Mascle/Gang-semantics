\section{Preliminaries}

\subsection{Definitions of the model}
A ""Broadcast Network of Register Automata"" (BNRA) \cite{DST2013} is a model describing a network of agents with local registers communicating by broadcasts. It is represented by a finite transition system describing the behaviour of an agent, which can broadcast and receive messages with integer values, store them in local registers, or make equality tests. 
We consider that when a message is broadcast by an agent, each other agent independently may or may not receive it. 
We study the set of runs of an arbitrary number of agents communicating this way.

\begin{definition}[Protocols]
	A ""protocol"" with $\regnum$ registers is a tuple $\prot = (Q, \messages, \transitions, q_0, \regnum)$  with $Q$ a finite set of states, $q_0 \in Q$ an initial state, $\messages$ a finite set of ""messages""  and $\transitions \subseteq Q \times \operations \times Q$ a finite set of transitions, with 
	\begin{multline*}
	\operations = \set{\br{\amessage}{i}, \rec{\amessage}{i}{\dummyact}, \rec{\amessage}{i}{\enregact}, \rec{\amessage}{i}{\eqtestact}, \rec{\amessage}{i}{\diseqtestact} \mid \amessage \in \messages, 1 \leq i \leq \regnum} \\ \cup  
	\set{\loc{i}{j}{\eqtestact}, \loc{i}{j}{\diseqtestact} \mid 1 \leq i,j \leq \regnum}
	\end{multline*}
	the set of operations.
	
	Transitions labelled with $\brsymb$ are ""broadcasts"", transitions labelled with $\recsymb$ are ""receptions"" and transitions labelled with $\locsymb$ are ""local tests"".
	Given a reception $\rec{\amessage}{i}{\anact}$ or a local test $\loc{i}{j}{\anact}$, $\anact$ is the ""action"" of the reception (resp. local test). 
The set of actions is $\actions := \set{\eqtestact, \diseqtestact, \enregact, \dummyact}$, where 
$\quotemarks{\eqtestact}$ is an equality test, $\quotemarks{\diseqtestact}$ is a disequality test, $\quotemarks{\enregact}$ is a store action and $\quotemarks{\dummyact}$ is a dummy action with no effect.
\end{definition}

We now define the semantics of those systems. Essentially, we have a finite set of agents, each with their own registers, which initially all contain distinct values. A step of a run consists in either one agent executing a local action, or one agent broadcasting a message and some of the other agents receiving it.

\begin{definition}[Semantics]
	Let $(Q,\messages, \transitions, q_0)$ be a "protocol", and $\agents \subseteq \nats$ a finite set of \emph{agents}.
	A ""configuration"" over a set of agents $\agents$ is a labelling function $\config : \agents \to Q \times \nats^{\regnum}$, mapping each agent to a state and ""register values"" for each of its registers. 
	We write $\st{\config}$ for the state component of $\config$ and $\data{\config}$ for its register component.
	An \emph{initial configuration} $\config$ is one where for all $a \in \agents$, $\st{\config}(a) = q_0$ and for all $a, a' \in \agents$, $i, i' \in \nset{1}{\regnum}$, if $\data{\config}(a, i) = \data{\config}(a', i')$ then $a=a'$ and $i=i'$.
	
	\AP We denote by $\configs{\agents}$ the set of configurations over $\agents$, and by $\allconfigs := \cup_{\agents \subseteq \nats \text{ finite }} \configs{\agents}$ the set of all configurations. Given a configuration $\config$, we denote by $\agentsof{\config}$ the set of agents of $\config$.
	
	\AP Given two configurations $\config, \config' \in \configs{\agents}$, a ""step"" $\config \step{} \config'$ is defined when one of the two following conditions is satisfied:
	\begin{itemize}
		\item there exists $a \in \agents$ and a "local test" $(\st{\config}(a), \loc{i}{j}{\anact}, \st{\config'}(a)) \in \transitions$ such that for all $a'\neq a$, $\config(a') = \config'(a')$ and
		\begin{itemize}
			\item either $\anact = \quotemarks{\eqtestact}$ and $\data{\config}(a,i) = \data{\config}(a,j)$
			
			\item or $\anact = \quotemarks{\diseqtestact}$ and $\data{\config}(a,i) \neq \data{\config}(a,j)$
		\end{itemize}
		
		\item there exist $\amessage \in \messages$, $a_0 \in \agents$ and $i \in \nset{1}{r}$ such that $(\st{\config}(a_0),\br{\amessage}{i}, \st{\config'}(a_0)) \in \transitions$, $\data{\config}(a_0) = \data{\config'}(a_0)$ and for all $a \in \agents\setminus \set{a_0}$, either $\config'(a) = \config(a)$ or there exists a transition $(\st{\config}(a),\rec{m}{j}{\anact},\st{\config'}(a))$
		such that $\data{\config'}(a, j') = \data{\config}(a, j')$ for all $j' \neq j$ and one of the following cases holds:
		\begin{itemize}
				\item $\anact = \quotemarks{\dummyact}$ 
				and $\data{\config'}(a,j) = \data{\config}(a,j)$
				\item $\anact = \quotemarks{\enregact}$ and $\data{\config'}(a,j) = \data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\eqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) =\data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\diseqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) \ne \data{\config}(a_0,i)$
			\end{itemize}
		\end{itemize}
	
	\AP A ""path"" is a sequence of steps $\apath : \config_0 \step{} \config_1 \step{} \cdots \step{} \config_k$. 
	We write $\config_0 \step{*} \config_k$ when there exists such a path.
	A ""run"" is a path whose first configuration is an "initial configuration"; runs are denoted with the letter $\run$.  
	Given such a "run" $\run$, we write $\agentsof{\run}$ its set of agents, $\statesin{\run}:= \set{q \in Q \mid \exists i, \exists a, \st{\config_i}(a) = q}$ the set of states appearing in $\run$ and $\valsof{\run} := \set{\aval \in \nats \mid \exists i,j, a, \data{\config_i}(a,j) = \aval}$.  
% We write $\Runs{\prot}$ for the set of runs of $\prot$.
	% with current definition, every run is initial
	
	\AP A run $\run: \config_0 \step{*} \config_f$ ""covers"" a state $q \in Q$ when there exists $a \in \agents$ such that $\st{\config_f}(a) = q$. 
	

	
	
The following remark formalizes the intuition that, because the only way to take a new register value is to receive another agent's value, no new register values are created in a "run".
\begin{remark}
	\label{rem:run_no_new_register_values}
	Because a register may only change its value to one that is broadcast from another register, we have that for all $\run: \config_0 \step{*} \config_f$, $\valsof{\run} = \set{\aval \in \nats \mid \exists a, \, \data{\config_0}(a) = \aval}$.
\end{remark}

\luin{- transformer les lemmes de copycat comme des paragraphes avec intuitions
	
	- mettre le weak copycat dans la partie 2}
	
	\begin{definition}
		We define a preorder over the set of configurations $\allconfigs$ as follows: $\config \lessthan \config'$ if there exists an injective function $\pi: \agentsof{\config} \rightarrow \agentsof{\config'}$ such that, for all $a \in \agentsof{\config}$, $\config(a) = \config'(\pi(a))$. 
	\end{definition}
	
	\begin{definition}
		A ""query"" $\query$ is a finite set of formulas of the form $\quotemarks{q(\var{z})}$, $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z}')}$, $\quotemarks{R_j(\var{z}) \neq R_{j'}(\var{z}')}$, with $\var{z}, \var{z}'$ taken in a set of variables $\varset$ and $j,j' \in \nset{1}{r}$.
		It is \emph{satisfied} by a "configuration" $\config$ if there is a valuation $\nu : \varset \to \agentsof{\config}$ such that:
		\begin{itemize}
			\item for all $\quotemarks{q(\var{z})} \in \query$, $\st{\config}(\nu(\var{z})) = q$,
			
			\item for all $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z'})} \in \query$, $\data{\config}(\nu(\var{z}))(j) = \data{\config}(\nu(\var{z'}))(j')$,
			
			\item for all $\quotemarks{R(\var{z}) \neq R(\var{z'})} \in \query$, $\data{\config}(\nu(\var{z}))(j) \neq \data{\config}(\nu(\var{z'}))(j')$.
		\end{itemize}
		
		\AP The ""query coverability problem"" is to determine, given a "protocol" and a "query", whether there is a "run" of this protocol whose last "configuration" satisfies the query.
	\end{definition}

	\AP The ""cover problem"" is to determine, given a "protocol" and a state $q_f$, whether there is a "run" of this protocol whose last "configuration" satisfies the "query" with the single formula $\quotemarks{q_f(\var{z})}$.
	
	\AP The ""target reachability problem"" is to determine, given a "protocol" and a state $q$, whether there is a "run" of this protocol whose last "configuration" $\config$ is such that $\st{\config}(\agentsof{\gamma}) = \{q_f\}$, i.e all agents reached $q_f$.
	
	\begin{remark}
		\label{rem:bigger_config_query}
		If some "configuration" $\config$ satisfies a "query" $\query$, then every configuration $\config'$ such that $\config \lessthan \config'$ satisfies $\query$. 
	\end{remark}
	
	%We say that it is ""initial@@run"" if $\config_0$ is an initial configuration.
\end{definition}

\begin{remark}
	Given a "protocol" $\prot$ with $r$ registers and a "query" $\query$ with $k$ variables, we can construct a "protocol" $\prot'$ with $\size{\prot}^k$ states and $kr$ registers that allows each agent to simulate $k$ agents of the previous system (by taking as states $k$-tuples of states of $\prot$, using the $kr$ registers to store the values of the registers of the $k$ agents and adapting the transitions accordingly).
	There is a run of the first BNRA satisfying $\query$ if and only if there is a run of the second in which one agent simulates the $k$ agents satisfying $\query$, which can be checked locally by that agent, which enters a special state $q_f$. if it happens. 
	
	This reduction is exponential, but this does not hinder our complexity result as we are concerned with a complexity class stable by exponential reductions.
	
	In the case of one register, we even have a polynomial-time reduction: We add a transition from every state to a sink state allowing an agent to stop at any moment and send its local configuration (state and register value) in a single broadcast.
	Also, at any moment, an agent may enter a series of transitions in which it receives the configurations of $k$ agents and checks that they satisfy the query, then enters a special state $q_f$. An agent can reach $q_f$ if and only if some agents could reach a configuration satisfying $\query$in the first BNRA.
\end{remark}

	
\ifbasic
\section{Basic properties}

%\begin{lemma}[Weak copycat]\label{lem:weak_copycat}
%	Let $q \in Q$ and  $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ such that $\st{\config_f}(a_m) = q$. There exists $\agents' \subseteq \nats$ finite s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \agents'$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents'$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ end the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in\nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f}(a_m) = \st{\config_f'}(a_c)$.
%	\end{itemize}
%\end{lemma}


%\ifproofs
%\begin{proof}
%	Let $\agents' \subseteq \nats$ such that $|\agents'|= |\agents|$ and $\agents \cap \agents' = \emptyset$.
%	There exists a bijection $\psi: \agents \mapsto \agents'$. Let $\config_0'$ an initial configuration over $\agents \cup \agents'$ which is equal to $\config_0$ on every agent of $\agents$. 
%	The constructed "run" $\run'$ starts on configuration $\config_0'$ and is composed of two parts. 
%	The first part consists in mimicking the sequence of steps of $\run$ with agents of $\agents$, while agents in $\agents'$ remain idle. This defines a run $\run_p' : \config_0' \step{*}  \config_m'$.  
%	The second part consists in a path $\apath': \config_m' \step{*} \config_f'$ which replicates the sequence of actions of $\run$ but on agents of $\agents'$: if an agent $a \in \agents$ takes a transition at step $i$ of $\run$, we make $\psi(a)$ take that transition at step $i$ of $\apath'$. As $\apath'$ is identical to $\run_p'$ up to renaming of the agents and values, a straightforward induction shows that this is always a valid transition.
%	In this second part, agents of $\agents$ are left idle. $\run'$ is obtained by concatenating $\run_p'$ and $\apath'$. Since agents of $\agents$ behave the same in $\run$ and $\run'$, for all $a \in \agents$, $\config_f(a) = \config_f'(a')$. Also, $\psi(a_m)$ took the same transitions as $a_m$ hence $\st{\config_f}(\psi(a_m)) = q$. Finally, thanks to Lemma~\ref{prop:run_no_new_register_values}, the register values of agents of $\agents'$ are in the set $\data{\config_0'}(\agents')(\nset{1}{r})$ while the register values of agents of $\agents$ are in $\data{\config_0'}(\agents)(\nset{1}{r})$; both sets are disjoint as $\config_0'$ is initial and thus for all $a \in \agents, a' \in \agents'$, $j,j' \in \nset{1}{r}$, $\data{\config_f'}(a) \ne \data{\config_f'}(a'_q)$.
%\end{proof}
%\fi

%\begin{lemma}[Strong copycat]\label{lem:strong_copycat}
%	Let $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ and register $j_m \in \nset{1}{r}$ such that $\data{\config_f}(a_m)(j_m) \ne \data{\config_0}(a_m)(j_m)$. % note that this condition may be relaxed to : a_m's register value did not stay the same throughout all of $\run$. 
%	There exist $\agents' \subseteq \nats$ s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \nats\setminus (\agents \cup \agents')$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents' \cup \set{a_c}$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ behave the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in \nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f'}(a_c) = \st{\config_f'}(a_m)$ and $\data{\config_f'}(a_c)(j_m) = \data{\config_f'}(a_m)(j_m)$.
%	\end{itemize}
%\end{lemma}
%\begin{proof}
%	Write $\aval := \data{\config_f}(a_m)(j_m)$. 
%	
%	
%	Since $a_m$ does not start with $v$ in register $j_m$, $a_m$ does a $\quotemarks{\enregact}$ action in $\run$.
%	Decompose $\run$ into $\run_p: \config_0 \step{*} \config_{m,1}$, $\path_i: \config_{m,1} \step{} \config_{m,2}$ and $\path_s: \config_{m,2} \step{*} \config_f$ where $\path_i$ is the step where $a_m$ does a $\quotemarks{\enregact}$ action for the last time; write $(q,\rec{\amessage}{\enregact},q') \in\transitions$ the transition taken by $a_m$ in $\path_i$. By applying the weak copycat (Lemma~\ref{lem:weak_copycat}) on $\run_p : \config_0 \step{*} \config$, we add an agent $a_c$ on state $q$ at the cost of adding a set of agents $\agents'$ whose data is disjoint from  the one of agents in $\agents$. Agents of $\agents'$ are left idle in subsequent steps. We make $a_c$ take the $\quotemarks{\enregact}$ transition at the same time as $a_m$, so that they are both on $q'$ with value $v$. We finally make $a_c$ mimick $a_m$ throughout $\path_s$: to do so, whenever $a_m$ takes a reception transition, we make $a_c$ take the same transition in the same step (which is possible as they have the same register value). When $a_m$ broadcasts, we duplicate the broadcast step to make $a_c$ broadcast immediately after, although no agent receives $a_c$'s broadcast. We end up with $a_m$ and $a_c$ on the same state with the same register value, which concludes the proof. 
%\end{proof}

\begin{corollary}
	\label{cor:removing_diseq_tests}
	Let $(\prot, \query)$ an instance of the "query coverability problem". This instance is positive if and only if $(\tilde{\prot}, \query)$ is positive, where $\tilde{\prot}$ is equal to $\prot$ where every disequality test $\quotemarks{\diseqtestact}$ is replaced by dummy action $\quotemarks{\dummyact}$.  
\end{corollary}

\ifproofs
\begin{proof}
	First, if $(\prot, \query)$ is positive then so is $(\tilde{\prot}, \query)$, as one can easily lift any "run" in $\prot$ to an equivalent "run" in $\tilde{\prot}$ (transitions are less guarded  in $\tilde{\prot}$ that in $\prot$). 
	
	Suppose now that $(\tilde{\prot}, \query)$ is a positive instance of the "query coverability problem". There exists a "run" $\tilde{\run}: \tilde{\config}_0 \step{*} \tilde{\config}$ in $\tilde{\prot}$ that satisfies $\query$. We prove by induction on the length of $\tilde{\run}$ that there exists a "run" $\run$ reaching a configuration $\config$ such that $\tilde{\config} \lessthan \config$ (Remark~\ref{rem:bigger_config_query} then allows us to conclude). 
	
	If $\config = \config_0$ then $\run = \tilde{\run}$ suffices. Suppose that $\tilde{\run}$ has length $k \geq 1$, and that the result if true for "runs" of length $k-1$. Decompose $\tilde{\run}$ into $\tilde{\run_{k-1}}: \tilde{\config_0} \step{*} \tilde{\config_{k-1}}$ of length $k-1$ and a final step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. 
	By induction hypothesis, there exists $\run_{k-1}: \config_0 \step{*} \config_{k-1}$ such that $\tilde{\config_{k-1}} \lessthan \config_{k-1}$: there exists an injective function $\pi : \tilde{\agents} \rightarrow \agents$
	such that, for all $a \in \tilde{\agents}$, $\tilde{\config_{k-1}}(a) = \config_{k-1}(\pi(a))$, where $\tilde{\agents} := \agentsof{\tilde{\run}}$ and $\agents := \agentsof{\run}$. If $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ involves no reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$, then we directly lift this step into a step appended at the end of $\run_{k-1}$ (making $\pi(a)$ take a transition whenever $a$ does so in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$). Otherwise, write $\tilde{\agents}_{\diseqtestact}$ the subset of $\tilde{agents}$ corresponding to agents taking in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ a reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$ . Write $(q, \br{m}, q') \in \transitions$ the broadcast transition used in this step.  Using Lemma~\ref{lem:copycat}, we add to $\config_{k-1}$ a fresh agent $a_{\mathsf{new}}$ with state $q$ and a register value that do not appear in $\config_{k-1}$. 
	We first mimick this broadcast step at the end of $\run_{k-1}$, making any agent $\pi(a) \in \pi(\tilde{\agents} \setminus \tilde{\agents}_{\diseqtestact})$ take the transition that $a$ takes in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. We then add a new step where $a_{\mathsf{new}}$ broadcasts using transition $(q, \br{m}, q')$, and every agent $\pi(a) \in \pi(\tilde{\agents}_{\diseqtestact})$ takes the transition corresponding to the transition taken by $a$ in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. Such a transition is a reception with action $\quotemarks{\diseqtestact}$ in $\prot$; however, because $a_{\mathsf{new}}$ does not share its register value with any process from $\tilde{\agents}$, all disequality conditions are satisfied and this step is valid. In this end, every agent $\pi(a) \in \pi(\tilde{\agents})$ has taken the transition in $\prot$ corresponding to the one $a$ took in $\tilde{\prot}$ in step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$, hence the configuration $\config_k$ reached by the constructed run is such that $\tilde{\config_k} \lessthan \config_k$. 
\end{proof}
\fi

Thanks to Corollary~\ref{cor:removing_diseq_tests}, we shall from now on assume that all considered protocols have no disequality tests. 

\begin{definition}
	Given a set of states $K \subseteq Q$, we say that a pair $\config, \aval$ with  $\config$ a "configuration" over a set of agents $\agents$ and $\aval \in \nats$ satisfies $K$ if for all $q \in K$, there exists $a \in \agents$ such that $\config(a) = (q,\aval)$.
	A configuration $\config$ satisfies $K$ if there exists $\aval \in \nats$ such that $\config, \aval $ satisfies $K$. 
	A "run" satisfies $K$ if its final configuration does.
\end{definition}
Note that if a "run" satisfies $K$, then it covers every state in $K$. The converse is not true as, in order to satisfy $K$, one needs to have agents of every state of $K$ that all share the same register value. See for instance the example below.

\begin{example}
	Consider the "protocol" displayed in Figure~\ref{fig:no-clique}.
	We can obtain configurations satisfying $\set{1,2}$, $\set{2,3}$ or $\set{1,3}$, but we cannot obtain one satisfying $\set{1,2,3}$.
	
	\begin{figure}[h]
		\input{Figures/fig-no-clique}
		\caption{An illustrating example}
		\label{fig:no-clique}
	\end{figure}
\end{example}



\begin{definition}
	We say that a "query" $\query$ is ""contradictory"" if either:
	\begin{itemize}
		\item there exists $\varz$ and $q \neq q' \in Q$ such that $\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$ or
		
		\item there exist $\var{z_1}, \ldots, \var{z_k} \in \varset$ and $j_1, \ldots, j_k$ with $k\geq 1$ such that $\quotemarks{R_{j_i}(\varz_{i}) = R_{j_{i+1}}(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R_{j_k}(\varz_k) \neq R_{j_1}(\varz_1)} \in \query$.
	\end{itemize}
\end{definition}

\begin{proposition}
	A "query" $\query$ is "contradictory" if and only if there exists no configuration satisfying $\query$. Additionnaly, one may decide whether $\query$ is contradictory in time polynomial in $\size{\prot} + \size{\query}$. 
\end{proposition}

\ifproofs
\begin{proof}
	Suppose first that $\query$ is "contradictory". If there exist $q \ne q'$ such that
	$\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$,  then a "configuration" satisfying $\query$ would need to have a single agent in two distinct states. If there exist $\var{z_1}, \ldots, \var{z_k}$ distinct variables with $k\geq 1$ such that $\quotemarks{R(\varz_{i}) = R(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R(\varz_k) \neq R(\varz_1)} \in \query$, then in any configuration satisfying $\query$,  the registers associated with $\varz_k$ and $\varz_1$ must have the same register value but also distinct register values, which is a contradiction. 
	
	Suppose now that the $\query$ is not "contradictory" and show that there exists some configuration satisfying $\query$.
	
	We consider the graph $G$ whose vertices are variables of $\varset$ appearing in $\query$ and with an edge between $\varz$ and $\varz'$ if and only if $R(\varz) = R(\varz') \in \query$. Since $\query$ is not "contradictory", for any $\varz, \varz'$ in the same connected component of $G$, $\quotemarks{R(\varz) \ne R(\varz')} \notin \query$. We construct a configuration satisfying $\query$ with an agent $a_\varz$ for every $\varz$ such that:
	\begin{itemize}
		\item if $\quotemarks{q(\varz)} \in \query$ then $a_\varz$ is in state $q$,
		\item the agents of the variables of a connected component of $G$ have all the same register value.  
	\end{itemize}
	The built configuration satisfies $\query$, which concludes the proof. 
\end{proof}
\fi

\begin{lemma}
	\label{lem:query-decomposition}
	Let $\query$ a  "non-contradictory" "query". There exist $K_1, \ldots, K_p \subseteq Q$ with $p \leq \size{\query}$ with the following property: there exists a "run" satisfying $\query$ if and only if for all $i \in \set{1,\ldots, p}$, there is a run satisfying $K_i$. Moreover,such sets $K_1, \dots, K_p$ may be computed in time polynomial in $\size{\prot}$. 
\end{lemma}


\ifproofs
\begin{proof}
	
	We consider the same graph $G$ as in the previous proof. We decompose $G$ into connected components $C_1, \ldots, C_p$. 
	For each $C_i$ we define $K_i = \set{q \in Q \mid \exists \varz \in C_i, q(\varz) \in \query}$. Note that $K_i$ may be empty when there is no constraints on the states of the variables in $C_i$. An empty set is satisfied by any "run". This is coherent with the fact that, when $K_i = \emptyset$, it suffices to assign all variables in $C_i$ to an agent that stays in $q_0$ for the whole "run".
	
	Suppose there is a "run" satisfying $\query$, let $\config$ be its final configuration, let $\nu$ be a valuation witnessing the satisfaction of $\query$ by $\config$.
	Let $i \in \set{1,\ldots, p}$, we show that $\config$ satisfies $K_i$. For all $\varz \in C_i$, let $(q_\varz,\aval_\varz) = \config(\nu(\varz))$. As $C_i$ is a connected component of $G$ and $\config$ satisfies $\query$, all $\nu(\varz)$ with $\varz \in C_i$ have the same register value, which we call $\aval$. 
	For all $q \in K_i$, there exists $\varz \in C_i$ such that $q(\varz) \in \query$ and thus $q_\varz =q$ and $\aval_\varz =\aval$, thus $C_i$ is satisfied.
	
	For the converse implication, suppose for all $i$ we have a run $\run_i$ over a set of agents $\agents_i$ satisfying $K_i$. We rename agents so that the $\agents_i$ are pairwise disjoint, we introduce fresh agents $a_1, \ldots, a_p$ and we set $\agents = \set{a_1, \ldots, a_p} \sqcup \bigsqcup_{i=1}^p \agents_i$. We consider $\run: \config_0 \step{*} \config$ a "run" in which the sequences of actions of each $\run_i$ are executed sequently by agents from $\agents_i$. In $\run$, agents $a_1$ to $a_p$ are left idle on $q_0$. We build the valuation $\nu$ witnessing that $\run$ satisfies $\query$ as follows. Let $i \in \nset{1}{p}$. If $K_i = \emptyset$ then $\nu$ assigns $a_i$ to every variable of $C_i$. Otherwise, we know that $\config|_{\agents_i}$ satisfies $K_i$ because the final configuration of $\run_i$ does: there exists $\aval_i \in \nats$ such that, for all $q \in K_i$, some agent $a_{i,q}$ has state $q$ and register value $\aval_i$ in $\config$. Let $\varz \in C_i$. If, for some $q \in Q$, $\quotemarks{q(\varz)} \in \query$, $\nu$ assigns agent $a_{i,q}$ to $\varz$ ($q$ is unique as $\query$ is not "contradictory"). If $\query$ has no constraint about the state of $\varz$, $\nu$ assigns to $\varz$ some $a_{i,q}$ with $q \in k_i$ arbitrary. 
	
	% We define a valuation $\nu$ as follows. Let $\varz \in \varset$ and $i$ so that $C_i$ is the connected component of $\varz$ in $G$. If  for some $q$, then this $q$ is unique as $\query$ is not "contradictory". We set $\nu(\varz) = a_q^i$.
	% If there is no $q(\varz)$ for any $q \in Q$ in $\query$ but there is one of the form $q'(\varz')$ with $\varz' \in C_i$, then we set $\nu(\varz) = \nu(\varz')$.
	% Otherwise we set $\nu(\varz) = a_i$.
	% This fully defines our valuation $\nu$.
	
	Clearly all formulas of the form $q(\varz)$ or $R(\varz) = R(\varz')$ are satisfied.
	For the formulas of the form $R(\varz) \neq R(\varz')$, we observe that as $\query$ is not "contradictory", $\varz$ and $\varz'$ are not in the same connected component of $G$. Because the runs $\run_i$ worked with disjoint sets of register values ($\config_0$ is initial), the agents assigned to $\varz$ and $\varz'$ end the run with distinct register values.
	Hence $\data{\config}(\nu(\varz)) \neq \data{\config}(\nu(\varz'))$. As a result, $\query$ is satisfied by $\run$.
\end{proof}
\fi
\fi


\subsection{Classical definitions}
\luin{here comes definitions of complexity classes, wqo and anything not related to our model}

\paragraph*{Fast-growing hierarchy}

In this paper we will use the notation $\Falpha{\alpha}$, with $\alpha$ an ordinal in Cantor normal form, to denote the complexity class corresponding to level $\alpha$.
We lack space to properly define this notion, but the interested reader may find the formal definitions of those classes in \corto{ref}.

For this paper, we will only need two theorems from the literature to prove $\Falpha{\omega^\omega}$-completeness of our problem: The first one is that Lossy Channel Systems are hard for the $\Falpha{\omega^\omega}$ complexity class (for the lower bound), the second one is the "Length function theorem" recalled below (for the upper bound). 

The reader should keep in mind that our result is mainly the decidability of that problem, and that we add the completeness result because it adds a very small overhead in the proofs, and fits our work nicely in the landscape of high-complexity problems stemming from well quasi-orders.
\nicoin{Reformuler}

\paragraph*{Well-quasi orders}

In order to prove our main decidability result, we need to rely on the theory of well quasi-orders. We recall bellow some definitions and results in the context of the subword ordering.

Let $\Sigma$ be a finite alphabet, $w_1, w_2 \in \Sigma^*$, we say that $w_1$ is a ""subword"" of $w_2$ and write $w_1 \subword w_2$ when $w_1$ can be obtained by erasing some letters from $w_2$. 
A sequence of words $w_0, w_1, \ldots$ is ""good"" if there exist $i<j$ such that $w_i \subword w_j$, and ""bad"" otherwise. 

\begin{lemma}[Higman's lemma]
	Every "bad" sequence of \corto{ref} words over a finite alphabet is finite.
\end{lemma}

We, however, need a more precise result, that bounds the length of a "bad" sequence. In order to obtain such a bound, it is necessary to bound the growth of the sequence of words. 
 
We will use the following result, known as the "Length function theorem" from \cite{SchmitzS2011upperHigman}:

\begin{theorem}[Length function theorem \cite{SchmitzS2011upperHigman}]
	\label{lem:lengthfcttheorem}
	Let $\Sigma$ be a finite alphabet, let $g : \nats \to \nats$ be a primitive recursive function, $n\in \nats$.
	Then there exists a function $f \in \Falpha{\omega^{\size{\Sigma} - 1}}$ such that every "bad sequence" $w_0, w_1, \ldots$ such that $\size{w_i} \leq g^{(i)}(n)$ for all $i$ is of length at most $f(n)$. 
\end{theorem}



\subsection{Link with LCS}
\luin{here comes defintions of LCS and the reduction}


""Lossy channel systems""  are systems where finite-state processes communicate via send messages from a finite alphabet through unbounded FIFO channels through which messages may be lost. The reachability problem asks whether a given control state of the system may be covered. Unlike in the non-lossy case \cite{BZ83}, reachability is decidable for "lossy channel systems" \cite{AK95,AbdullaJ1996undec}, but is proven to have non-primitive recursive complexity \cite{Schnoebelen2002verifying} and in fact lays at level $\mathcal{F}_{\omega^{\omega}}$ in the Fast-Growing Function Hierarchy \cite{ChambartS2008ordinal}.

We now prove that the coverability problem in BNRA is at least as hard as the reachability problem for "lossy channel system", and that this already hold for $2$-BNRAs.  
\begin{proposition}
	\label{prop:reduction-LCS}
	There is a polynomial-time reduction from the coverability problem for lossy channel systems to the coverability problem for BNRA with two registers.
\end{proposition}

\ifproofs
\begin{proof}
It is sufficient to prove that it is as hard as reachability for lossy channel systems with a single channel, which corresponds to a single finite-state machine that has the ability to buffer symbols in a lossy FIFO queue \cite{Schnoebelen2002verifying}.
Let $\los := (\lstates,\Sigma)$ be a "lossy channel system", where $\lstates$ is a finite set of locations, $\Sigma$ is a finite set of symbols and $\ltransitions \subseteq \lstates \times \Sigma^* \times \set{!, ?} \times \lstates$; $\quotemarks{!}$ corresponds to a ""push"" (writing at the end of the channel) and $\quotemarks{?}$ to a ""pop"" (reading at the beginning the channel). A configuration of $\los$ is a pair of $\lstates \times \Sigma^*$ denoting the location of the system and the content of the channel. There exists a step from $(\lstate,w)$ to $(\lstate',w')$ using transition $\ltrans \in \ltransitions$, denoted $(\lstate,w) \lstep{\ltrans} (\lstate',w')$, when
\begin{itemize}
\item $\ltrans = (\lstate,u,!,\lstate')$ for some $u \in \Sigma^*$ and $w' \subword w \cdot u$ (a ""push""),
\item $\ltrans = (\lstate,u,?,\lstate')$ for some $u \in \Sigma^*$ and $u \cdot w' \subword w$ (a ""pop"")
\end{itemize}
where $\subword$ denotes the "subword relation".
This subword relation encodes the lossiness of the channel (a non-lossy channel wuld have equalities instead); intuitively, it expresses the fact that letters in the channel may get lost. 

The existence of such a transition for some $\ltrans \in \transitions$ is denoted $(\lstate,w) \lstep{} (\lstate',w')$, and its transitive closure is denoted $\lstep{*}$. The ""reachability problem@@lcs"" asks, given $\los$ and two locations $\lstate_i, \lstate_f \in \lstates$, whether there exists an execution $(\lstate_i,\epsilon) \lstep{*} (\lstate_f, w)$ for some $w$. 

We aim at constructing a $2$-BNRA $\prot$ with a distinguished state $q_f$ such that $q_f$ may be covered if and only if $(\los, q_i, q_f)$ is a positive instance of the "reachability problem@@lcs". 
The intuition of $\prot$ is the following. Agents will organize in chains so that each agent of a chain knows the identifier of its precedessor in the chain, hence is able to check that messages received come from it. Each agent of the chain is meant to encode a step of the exeuction in the "lossy channel system". 
An agent of the chain will only listen to their predecessor in the chain, from which they will obtain a location of the system and the content of the channel. It will then broadcast the new location of the system and the new content of the channel to the next agent of the chain. 

Note that the content of the channel might become big in a "lossy channel system", therefore agents will not store it but rather rebroadcast it letter by letter. An agent only applies a small modification at the beginning of the channel if it decides to encode a "pop" transition and at the end of the channel if it decides to encode a "push" transition. Messages might get lost, which is why we are able to encode "lossy channel systems" but not non-lossy ones.

In some initial phase, agents decide whether they are ""root"" (at the beginning of their chain) or ""link"". A "root" agent receives no message; it simply broadcasts its identifiers and the initial confinguration of $\los$ $(\lstate_0,\epsilon)$. To encode this option, in $\prot$, from the initial state $q_0$ one has the possibility to move to a part where the only sequence of transitions possible is $\br{\mathsf{init}}{1}, \br{\mathsf{q_0}}{1}, \br{\mathsf{\#}}{1}$ which gets to $\finstate{\lstate_0} \in Q$. The symbol $\mathsf{\#} \in \Sigma$ is the final symbol meaning that the channel was fully broadcast. 
 
A "link" agent first receives a broadcast with an identifier which it decides to be the one of its predecessor. It then broadcasts its own identifier. This construction guarantees that "link" agents have exactly one predecessor. It does not guarantee, however, than all agents are in the same chain or that any agent is the predecessor of less than one agent. In practice, there exists a sequence of transitions from $q_0$ labeled by $\rec{\mathsf{init}}{2}{\enregact}, \br{\mathsf{init}}{1}$ that gets to $\waitstate \in Q$. 

From $\waitstate$, there is, for every $\lstate \in \lstates$, a transition labeled by $\rec{\mathsf{\lstate}}{2}{\eqtestact}$ that goes to state $\startstate{\lstate} \in Q$. 
For every transition $\ltrans = (\lstate, \op, \lstate') \in \ltransitions$ in $\los$ (\emph{i.e.}, every transition of $\ltransitions$ whose source is location $\lstate$), there is a transition in $\prot$ labeled by $\br{\mathsf{\lstate'}}{1}$ that goes from $\startstate{\lstate}$ to $\transstateone{\ltrans} \in Q$. 
Transitions from $\transstateone{\ltrans}$ in $\prot$ depend on $\ltrans$:
\begin{itemize}
\item If $\ltrans=(\lstate, u,?, \lstate')$ is a "pop" then $\prot$ has a sequence of transitions from $\transstateone{\ltrans}$ to $\transstatetwo{\ltrans} \in Q$ labeled by $\rec{\mathsf{u_1}}{2}{\eqtestact}, \rec{\mathsf{u_2}}{2}{\eqtestact}, \dots, \rec{\mathsf{u_k}}{2}{\eqtestact}$ where $u = u_1 u_2 \cdots u_k$. Moreover, there is, for every $x \in \Sigma$, a loop on $\transstatetwo{\ltrans}$ labeled with sequence of actions $\rec{\mathsf{x}}{2}{\eqtestact}, \br{\mathsf{x}}{1}$. There is also a sequence of  transitions from $\transstatetwo{\ltrans}$ to $\finstate{\lstate'}$ labeled by $\rec{\mathsf{\#}}{2}{\eqtestact}, \br{\mathsf{\#}}{1}$.
\item If $\ltrans= (\lstate, u,!, \lstate')$ is a "push" then there is, for every $x \in \Sigma$, a loop on $\transstateone{\ltrans}$ labeled with sequence of actions $\rec{\mathsf{x}}{2}{\eqtestact}, \br{\mathsf{x}}{1}$. There also is a sequence of transitions from $\transstateone{\ltrans}$ to $\transstatetwo{\ltrans}$ labeled by $\br{\mathsf{u_1}}{1}, \br{\mathsf{u_2}}{1}, \dots, \br{\mathsf{u_k}}{1}$ where $u = u_1 \cdot u_2 \cdots u_k$. From $\transstatetwo{\ltrans}$, there is  a sequence of transitions going to $\finstate{\lstate'}$ labeled by $\rec{\mathsf{\#}}{2}{\eqtestact}, \br{\mathsf{\#}}{1}$.
\end{itemize}
Finally, the objective state of our system is $q_f := \finstate{\lstate_f}$.

Note that, in this protocol, register $1$ is broadcast-only, therefore acting as a signature for message, and register $2$ is reception-only, therefore used to check the signature of messages.

We claim that $(\prot, q_f)$ is a positive instance of \COVER if and only if $(\los, \lstate_f)$ is a positive instance of the reachability problem for "lossy channel systems".
First, suppose that there exists $w \in \Sigma^*$ such that $(\lstate_0, \epsilon) \lstep{*} (\lstate_f, w)$. Decompose the witness into $(\lstate_0, w_0) \lstep{} (\lstate_1, w_1) \lstep{} (\lstate_2, w_2) \cdots \lstep{} (\lstate_n,w_n)$ with $\lstate_n = \lstate_f$ and $w_n =w$. 
We build an execution of $\prot$ that covers $q_f$ as follows. It has set of agents $\agents := \set{0,\dots, n}$. Agent $0$ becomes the "root" and for all $i \geq 1$, agent $i$ becomes a "link" with predecessor agent $i-1$. By induction on $i$, we build an execution using agents $0$ to $i$ such that agent $i$ ends on state $\finstate{\ltrans_i}$ and the sequence of messages sent by agent $i$ admits as subword $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_i \cdot \mathsf{\#}$. For $i=0$, this condition is met as agent $0$ becomes "root". When the construction has been done up until agent $i$, we make agent $i+1$ do the following. It first places itself after agent $i$ in the chain and goes to $\waitstate$. It then received from agent $i$ state $l_i$ and goes to $\startstate{l_i}$. It then moves to $\transstateone{\ltrans}$ where $\ltrans = (\lstate_i, \op, \lstate_{i+1})$ is the transition of step $(\lstate_i, w_i) \lstep{} (\lstate_{i+1}, w_{i+1})$. Doing so, it broadcasts $\mathsf{\lstate_{i+1}}$. Its behavior then depends on $\ltrans$.
\begin{itemize}
\item if $\ltrans =(\lstate_i, u,!, \lstate_{i+1})$ is a "push" then $w_{i+1} \subword w_i \cdot u$; write $w_{i+1} = w_{i}' \cdot u'$ where $w_i' \subword w_i$ and $u' \subword u$. Agent $i+1$ receives every message in $w_i'$ and rebroadcasts it while looping on $\transstateone{\ltrans}$. It then broadcasts $u$ to get to $\transstatetwo{\ltrans}$. It finally receives $\mathsf{\#}$ from agent $i$ and rebroadcasts it, going to state $\finstate{\lstate_{i+1}}$. Overall the word broadcast by agent $i+1$ is $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w'_i \cdot u \cdot \mathsf{\#}$ which admits as subword $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_{i+1} \cdot \mathsf{\#}$.
\item if $\ltrans =(\lstate_i, u,?, \lstate_{i+1})$ is a "pop" then $u \cdot w_{i+1} \subword w_i$; write $w_{i} = u' \cdot w_{i+1}'$ where $w_{i+1} \subword w_{i+1}'$ and $u \subword u'$. Overall, agent $i+1$ receives from agent $i$ sequence of messages $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot u \cdot w_{i+1}' \cdot \mathsf{\#}$ (some messages get lost). 
From $\transstateone{\ltrans}$, agent $i+1$ receives $u$ and goes to $\transstatetwo{\ltrans}$. It then receives every message in $w_{i+1}'$ and rebroadcasts it while looping on $\transstatetwo{\ltrans}$. It finally received $\mathsf{\#}$ from agent $i$ and rebroadcasts it, going to state $\finstate{\lstate_{i+1}}$. Overall the word broadcast by agent $i+1$ is $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_{i+1}'  \cdot \mathsf{\#}$ which admits as subword $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot w_{i+1} \cdot \mathsf{\#}$.
\end{itemize}
This concludes the induction step.
When applied to $i=n$, this builds an execution where agent $n$ ends on $\finstate{\lstate_n}$, which is a witness that $(\prot, q_f)$ is positive.

Suppose now that $(\prot, q_f)$ is positive. Let $\run: \aconfig_0 \step{*} \aconfig_f$ where $\config_f$ covers $q_f$. 
Write $\agents$ the set of agents in $\run$. Observe that, in $\prot$, one may never change the value of register $1$. 
Moreover, any agent either keeps its original value in register $2$ or changes it exactly once to take the value of some other agent's register $1$. Therefore, we define a function $\predfun: \agents \rightarrow \agents \cup \set{\bot}$ that associates to every agent $a$ the agent $\agentbr$ whose initial value in register $1$ eventually becomes the value in register $2$ of $a$ (and $\bot$ if such an agent does not exist). Consider $a_f$ the agent that first covers $q_f$ in $\config_f$. Let $a_1, \dots ,a_n$ the sequence of agents such that $a_f = a_n$, $\predfun(a_{i+1}) = a_i$ for all $i \in \nset{0}{n-1}$ and $\predfun(a_0) = \bot$. 
Because $a_n$ covers $\finstate{\lstate_f}$, for all $i$, agent $i$ eventually broadcasts $\mathsf{\#}$ and it ends on some $\finstate{l_i}$ for $l_i \in \lstates$. Because $\predfun(a_0) = \bot$, $a_0$ has taken the "root" branch and therefore broadcasts sequence $\mathsf{init} \cdot \mathsf{\lstate_0} \cdot \mathsf{\#}$. 
By structure of the protocol, because agent $i$ ends of $\finstate{\lstate_i}$, its broadcast sequence is of the form $\mathsf{init} \cdot \mathsf{\lstate_i} \cdot \mathsf{w_i} \cdot \mathsf{\#}$ where $w_i \in \Sigma^*$. 
We prove by induction that, for every $i$, $(\lstate_i, w_i) \lstep{\ltrans_{i+1}} (\lstate_{i+1}, w_{i+1})$ where $\ltrans_{i+1}$ is such that agent $a_{i+1}$ goes through states $\transstateone{\ltrans_{i+1}}$ and $\transstatetwo{\ltrans_{i+1}}$ ($\ltrans_{i+1}$ is unique by construction of $\prot$).
 By construction, $\ltrans_{i+1}$ has source $\lstate_i$ (it is the value broadcast by $a_i$) and destination $\lstate_{i+1}$ ($a_{i+1}$ ends on $\finstate{\lstate_{i+1}$}). 
 Moreover, in order to get through $\transstateone{\ltrans_{i+1}}$ and $\transstatetwo{\ltrans_{i+1}}$, $a_{i+1}$ must indeed apply on the channel the "push" or "pop" that corresponds to transition $\ltrans_{i+1}$; because it receives stack $w_i$ from $a_i$, we have $(\lstate_i, w_i) \lstep{\ltrans_{i+1}} (\lstate_{i+1}, w_{i+1})$. 
 Since $w_0 = \epsilon$, we have proven that $(\lstate_0, \epsilon) \lstep{*} (\lstate_f, w_n)$ and the instance of $\los$ is positive. 
\end{proof}
\fi

\begin{remark}
	The reduction presented in the proof of Proposition~\ref{prop:reduction-LCS} can be adapted to show that the repeat coverability problem is undecidable for BNRA, as it is for LCS.
\end{remark}

