\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Definitions of the model}
A ""Broadcast Network of Register Automata"" (BNRA) \cite{DelzannoST13} is a model describing a network of agents with local registers communicating by broadcasts. It is represented by a finite transition system describing the behavior of an agent; an agent can broadcast and receive messages with integer values, store them in local registers and perform equality tests. 
There are arbitrarily many agents and for any message broadcast by an agent, each other agent independently may or may not receive it. 

\begin{definition}[Protocols]
	A ""protocol"" with $\regnum$ registers is a tuple $\prot = (Q, \messages, \transitions, q_0)$  with $Q$ a finite set of states, $q_0 \in Q$ an initial state, $\messages$ a finite set of ""message types""  and $\transitions \subseteq Q \times \operations \times Q$ a finite set of transitions, with a set of operations 
	\begin{multline*}
	\operations = \set{\br{\amessage}{i}, \rec{\amessage}{i}{\dummyact}, \rec{\amessage}{i}{\enregact}, \rec{\amessage}{i}{\eqtestact}, \rec{\amessage}{i}{\diseqtestact} \mid \amessage \in \messages, 1 \leq i \leq \regnum} \\ \cup  
	\set{\loc{i}{j}{\eqtestact}, \loc{i}{j}{\diseqtestact} \mid 1 \leq i,j \leq \regnum}
	\end{multline*}	
	Transitions labelled with $\brsymb$ are ""broadcasts"", transitions labelled with $\recsymb$ are ""receptions"" and transitions labelled with $\locsymb$ are ""local tests"".
	Given a reception $\rec{\amessage}{i}{\anact}$ or a local test $\loc{i}{j}{\anact}$, $\anact$ is the ""action"" of the reception (resp. local test). 
The set of actions is $\actions := \set{\eqtestact, \diseqtestact, \enregact, \dummyact}$, where 
$\quotemarks{\eqtestact}$ is an ""equality test"", $\quotemarks{\diseqtestact}$ is a ""disequality test"", $\quotemarks{\enregact}$ is a ""store action"" and $\quotemarks{\dummyact}$ is a ""dummy action"" with no effect.
The ""size"" of $\prot$ is $\size{\prot} := \size{Q} + \size{\messages} + \size{\transitions} + r$.
\end{definition}

We now define the semantics of those systems. Essentially, we have a finite set of agents with $r$ registers each; all registers initially contain distinct values. A step is either an agent performing a local action or an agent broadcasting a message received by some other agents.

\begin{definition}[Semantics]
	Let $(Q,\messages, \transitions, q_0)$ be a "protocol" with $\regnum$ registers, and $\agents \subseteq \nats$ a finite non-empty set of ""agents"".
	A ""configuration"" over a set of agents $\agents$ is a function $\config : \agents \to Q \times \nats^{\regnum}$ mapping each agent to a state and ""register values"". 
	We write $\st{\config}$ for the state component of $\config$ and $\data{\config}$ for its register component.
	An \emph{initial configuration} $\config$ is one where for all $a \in \agents$, $\st{\config}(a) = q_0$ and $\data{\config}(a, i) \neq \data{\config}(a', i')$ for all $(a,i) \neq (a', i')$.
	
	\AP We denote by $\configs{\agents}$ the set of configurations over $\agents$, and by $\allconfigs := \cup_{\agents \subseteq \nats \text{ finite }} \configs{\agents}$ the set of all configurations. Given a configuration $\config \in \allconfigs$, we denote by $\agentsof{\config}$ the set of agents of $\config$.
	
	\AP Given a finite set of agents $\agents$ and two configurations $\config, \config' \in \configs{\agents}$, a ""step"" $\config \step{} \config'$ is defined when one of the two following conditions is satisfied:
	\begin{itemize}
		\item there exists $a \in \agents$ and a "local test" $(\st{\config}(a), \loc{i}{j}{\anact}, \st{\config'}(a)) \in \transitions$ such that for all $a'\neq a$, $\config(a') = \config'(a')$, $\data{\config'}(a,i') = \data{\config}(a,i')$ for all $i'$ and
		\begin{itemize}
			\item either $\anact = \quotemarks{\eqtestact}$ and $\data{\config}(a,i) = \data{\config}(a,j)$
			
			\item or $\anact = \quotemarks{\diseqtestact}$ and $\data{\config}(a,i) \neq \data{\config}(a,j)$
		\end{itemize}
		
		\item there exist $\amessage \in \messages$, $a_0 \in \agents$ and $i \in \nset{1}{r}$ such that $(\st{\config}(a_0),\br{\amessage}{i}, \st{\config'}(a_0)) \in \transitions$, $\data{\config}(a_0) = \data{\config'}(a_0)$ and for all $a \in \agents\setminus \set{a_0}$, either $\config'(a) = \config(a)$ or there exists a transition $(\st{\config}(a),\rec{m}{j}{\anact},\st{\config'}(a))$
		such that $\data{\config'}(a, j') = \data{\config}(a, j')$ for all $j' \neq j$ and one of the following cases holds:
		\begin{itemize}
				\item $\anact = \quotemarks{\dummyact}$ 
				and $\data{\config'}(a,j) = \data{\config}(a,j)$
				\item $\anact = \quotemarks{\enregact}$ and $\data{\config'}(a,j) = \data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\eqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) =\data{\config}(a_0,i)$
				\item $\anact = \quotemarks{\diseqtestact}$ and $\data{\config'}(a,j) = \data{\config}(a,j) \ne \data{\config}(a_0,i)$
			\end{itemize}
		\end{itemize}
	
	\AP A ""path"" is a sequence of steps $\apath : \config_0 \step{} \config_1 \step{} \cdots \step{} \config_k$. 
	We write $\config_0 \step{*} \config_k$ when there exists such a path.
	A "path" is a  ""run"" when $\config_0$ is an "initial configuration".  
	\AP A run $\run: \config_0 \step{*} \config_f$ ""covers"" a state $q \in Q$ when there exists $a \in \agents$ such that $\st{\config_f}(a) = q$. 
\end{definition}
\begin{remark}
\label{rem:several_values_per_message}
In our model, agents may only send one value per message. Indeed, \cite{DelzannoST13} establishes undecidability of "coverability" if agents can broadcast two values at once.
\end{remark}

\begin{example}\label{ex:example-1}
	We give an example of a "protocol" with 2 registers in Figure \ref{fig:ex1}. 
	Let $\agents = \{a_1, a_2\}$. We denote a configuration $\config$ over $\agents$ by $\tuple{(\st{\config}(a_1), \data{\config}(a_1)), (\st{\config}(a_2),\data{\config}(a_2))}$. The following sequence is a "run", where $x_1,y_1,x_2,y_2$ are distinct natural integers:
	\begin{multline*}
	\tuple{(q_0, (x_1,y_1)), (q_0,(x_2,y_2))} \step{} \tuple{(q_1, (x_1,y_1)), (q_5,(x_1,y_2))} \step{} \\ \tuple{(q_4, (x_1,y_2)), (q_4,(x_1,y_2))} \step{} \tuple{(q_7, (x_1,y_2)), (q_4,(x_1,y_2))} \step{} \tuple{(q_7, (x_1,y_2)), (q_4,(x_1,y_2))}
	\end{multline*}
	The broadcast messages are: $(m_2,x_1)$ by $a_1$, $(m_4,y_2)$ by $a_2$, $(m_6,x_1)$ by $a_1$ and $(m_7,x_1)$ by $a_1$. Each broadcast is received by the other agent. 
\end{example}

\begin{figure}[h]
	\input{Figures/fig-ex1}
	\caption{Example of a "protocol".}\label{fig:ex1}
\end{figure}
	
	


\begin{remark}
	\label{rem:copycat-principle}
	We make the following observation: from a "run" $\run : \config_0 \step{\ast} \config$, we can build a run in which each agent of $\run$ has  a clone in the same state but with different register values. To obtain this, it suffices to add new agents that mimick $\run$ in parallel; they will not share any register values with the original agents.  We will refer to this notion as the ""copycat principle"": if state $q$ is coverable, then for all $n$ there exists a "run" which puts $n$ agents on $q$.
\end{remark}

	
\begin{definition}

	\AP The ""coverability problem"" \COVER asks, given a "protocol" $\prot$ and a state $q_f$, whether there is a "run" of $\prot$ that "covers" $q_f$.
	
	\AP The ""target reachability problem"" \TARGET asks, given a "protocol" $\prot$ and a state $q_f$, whether there is a "run" $\config_0 \step{*} \config_f$ of $\prot$ such that $\st{\config_f}(\agentsof{\gamma}) = \{q_f\}$, i.e all agents end on $q_f$.
\end{definition}

\begin{example}\label{example-2}
	Let $\prot$ the "protocol" of Example~\ref{fig:ex1}. As proven in Example~\ref{ex:example-1}, $(\prot,q_7)$ is a positive instance of \COVER. However, $(\prot,q_7)$ is a negative instance of \TARGET: for an agent to reach $q_7$, there must be an agent staying on $q_4$ to broadcast $m_6$. Meanwhile, $(\prot,q_1)$ is a positive instance of \TARGET: all agents can broadcast $m_1$ to get to $q_1$. Also, $(\prot, q_3)$ is a negative instance of \COVER: we would need one agent on $q_2$ and one on $q_5$ with the same value in their first registers, hence we need a broadcast $(m_1,v)$ and a broadcast $(m_2,v)$ for some $v$. However, an agent broadcasting message $(m_1,v)$ or $(m_2,v)$ has $v$ as initial value; it cannot come back to $q_0$ thus cannot broadcast both $(m_1,v)$ and $(m_2,v)$ in the same "run". 
\end{example}

\begin{remark}
	In \cite{DelzannoST13}, the authors considered ``queries'', which are conjunctions of formulas of the form $\quotemarks{q(\var{z})}$, $\quotemarks{R_j(\var{z}) = R_{j'}(\var{z}')}$, $\quotemarks{R_j(\var{z}) \neq R_{j'}(\var{z}')}$, with $\var{z}, \var{z}'$ taken in a set of variables $\varset$, $q\in Q$ and $j,j' \in \nset{1}{r}$. A configuration satisfies a query if we can assign an agent to each variable so that all conjuncts are satisfied.
	This problem reduces to \COVER.
	Given a "protocol" $\prot$ with $r$ registers and a query $\query$ with $k$ variables, we can construct a "protocol" $\prot'$ with $O(\size{\prot}^k + \size{\query})$ states and $kr$ registers that allows each agent to simulate $k$ agents of the previous system.
	There is a run of the first BNRA satisfying $\query$ if and only if there is a run of the second in which one agent simulates the $k$ agents satisfying $\query$; in order to cover $q_f$, this agent must check locally that $\query$ is satisfied by the $k$ agents it encodes.
	This reduction is exponential, which does not hinder our complexity result as we obtain a complexity class ($\Fcomplexity{\omega^{\omega}}$) stable by exponential reductions.
	
	In the case of one register, we even have a polynomial-time reduction. To do so, we extend the "protocol" so that any agent can share its local configuration in a single broadcast (going to some sink state).
	In order to reach $q_f$, an agent must perform a sequence of transitions in which it receives the configurations of $k$ agents and checks that they satisfy the query.
\end{remark}

In fact, we may get rid of "local equality tests" at the cost of an exponential blow-up.

\begin{restatable}{proposition}{SimpleReduction}
	\label{prop:loc-eq-test-elimination}
	There is an exponential-time reduction from \COVER to \COVER with no "local equality tests" $\loc{i}{j}{=}$.
\end{restatable}
% \cortoin{En annexe ? Seulement utile pout TOWER}
The intuition is as follows: from a "protocol" $\prot$, we build a "protocol" $\prot'$ whose registers are used to store values of multiple registers of $\prot$, so that equality of two registers of $\prot$ is encoded in the states of $\prot'$. To do so, a state of $\prot'$ stores which register of $\prot$ is mapped to which register of $\prot'$, hence the exponential blowup. The full proof can be found in Appendix~\ref{sec:proof-lol-eq-test-elim}.
%\ifbasic
%\section{Basic properties}

%\begin{lemma}[Weak copycat]\label{lem:weak_copycat}
%	Let $q \in Q$ and  $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ such that $\st{\config_f}(a_m) = q$. There exists $\agents' \subseteq \nats$ finite s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \agents'$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents'$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ end the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in\nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f}(a_m) = \st{\config_f'}(a_c)$.
%	\end{itemize}
%\end{lemma}


%\ifproofs
%\begin{proof}
%	Let $\agents' \subseteq \nats$ such that $|\agents'|= |\agents|$ and $\agents \cap \agents' = \emptyset$.
%	There exists a bijection $\psi: \agents \mapsto \agents'$. Let $\config_0'$ an initial configuration over $\agents \cup \agents'$ which is equal to $\config_0$ on every agent of $\agents$. 
%	The constructed "run" $\run'$ starts on configuration $\config_0'$ and is composed of two parts. 
%	The first part consists in mimicking the sequence of steps of $\run$ with agents of $\agents$, while agents in $\agents'$ remain idle. This defines a run $\run_p' : \config_0' \step{*}  \config_m'$.  
%	The second part consists in a path $\apath': \config_m' \step{*} \config_f'$ which replicates the sequence of actions of $\run$ but on agents of $\agents'$: if an agent $a \in \agents$ takes a transition at step $i$ of $\run$, we make $\psi(a)$ take that transition at step $i$ of $\apath'$. As $\apath'$ is identical to $\run_p'$ up to renaming of the agents and values, a straightforward induction shows that this is always a valid transition.
%	In this second part, agents of $\agents$ are left idle. $\run'$ is obtained by concatenating $\run_p'$ and $\apath'$. Since agents of $\agents$ behave the same in $\run$ and $\run'$, for all $a \in \agents$, $\config_f(a) = \config_f'(a')$. Also, $\psi(a_m)$ took the same transitions as $a_m$ hence $\st{\config_f}(\psi(a_m)) = q$. Finally, thanks to Lemma~\ref{prop:run_no_new_register_values}, the register values of agents of $\agents'$ are in the set $\data{\config_0'}(\agents')(\nset{1}{r})$ while the register values of agents of $\agents$ are in $\data{\config_0'}(\agents)(\nset{1}{r})$; both sets are disjoint as $\config_0'$ is initial and thus for all $a \in \agents, a' \in \agents'$, $j,j' \in \nset{1}{r}$, $\data{\config_f'}(a) \ne \data{\config_f'}(a'_q)$.
%\end{proof}
%\fi

%\begin{lemma}[Strong copycat]\label{lem:strong_copycat}
%	Let $\run : \config_0 \step{*} \config_f$ a "run" over set of agents $\agents$ with some distinguished agent $a_m \in \agents$ and register $j_m \in \nset{1}{r}$ such that $\data{\config_f}(a_m)(j_m) \ne \data{\config_0}(a_m)(j_m)$. % note that this condition may be relaxed to : a_m's register value did not stay the same throughout all of $\run$. 
%	There exist $\agents' \subseteq \nats$ s.t. $\agents \cap \agents' = \emptyset$, $a_c \in \nats\setminus (\agents \cup \agents')$ and a "run" $\run': \config_0' \step{*} \config_f'$ over $\agents \cup \agents' \cup \set{a_c}$ such that:
%	\begin{itemize}
%		\item for all $a \in \agents$, $\config_f'(a) = \config_f(a)$ (agents of $\agents$ behave the same in $\run$ and $\run'$),
%		\item for all $a \in \agents$, $a' \in \agents'$, $j, j' \in \nset{1}{r}$, $\data{\config_f}(a)(j) \ne \data{\config_f'}(a')(j')$,
%		\item $\st{\config_f'}(a_c) = \st{\config_f'}(a_m)$ and $\data{\config_f'}(a_c)(j_m) = \data{\config_f'}(a_m)(j_m)$.
%	\end{itemize}
%\end{lemma}
%\begin{proof}
%	Write $\aval := \data{\config_f}(a_m)(j_m)$. 
%	
%	
%	Since $a_m$ does not start with $v$ in register $j_m$, $a_m$ does a $\quotemarks{\enregact}$ action in $\run$.
%	Decompose $\run$ into $\run_p: \config_0 \step{*} \config_{m,1}$, $\path_i: \config_{m,1} \step{} \config_{m,2}$ and $\path_s: \config_{m,2} \step{*} \config_f$ where $\path_i$ is the step where $a_m$ does a $\quotemarks{\enregact}$ action for the last time; write $(q,\rec{\amessage}{\enregact},q') \in\transitions$ the transition taken by $a_m$ in $\path_i$. By applying the weak copycat (Lemma~\ref{lem:weak_copycat}) on $\run_p : \config_0 \step{*} \config$, we add an agent $a_c$ on state $q$ at the cost of adding a set of agents $\agents'$ whose data is disjoint from  the one of agents in $\agents$. Agents of $\agents'$ are left idle in subsequent steps. We make $a_c$ take the $\quotemarks{\enregact}$ transition at the same time as $a_m$, so that they are both on $q'$ with value $v$. We finally make $a_c$ mimick $a_m$ throughout $\path_s$: to do so, whenever $a_m$ takes a reception transition, we make $a_c$ take the same transition in the same step (which is possible as they have the same register value). When $a_m$ broadcasts, we duplicate the broadcast step to make $a_c$ broadcast immediately after, although no agent receives $a_c$'s broadcast. We end up with $a_m$ and $a_c$ on the same state with the same register value, which concludes the proof. 
%\end{proof}
%
%\begin{corollary}
%	\label{cor:removing_diseq_tests}
%	Let $(\prot, \query)$ an instance of the "query coverability problem". This instance is positive if and only if $(\tilde{\prot}, \query)$ is positive, where $\tilde{\prot}$ is equal to $\prot$ where every disequality test $\quotemarks{\diseqtestact}$ is replaced by dummy action $\quotemarks{\dummyact}$.  
%\end{corollary}
%
%\ifproofs
%\begin{proof}
%	First, if $(\prot, \query)$ is positive then so is $(\tilde{\prot}, \query)$, as one can easily lift any "run" in $\prot$ to an equivalent "run" in $\tilde{\prot}$ (transitions are less guarded  in $\tilde{\prot}$ that in $\prot$). 
%	
%	Suppose now that $(\tilde{\prot}, \query)$ is a positive instance of the "query coverability problem". There exists a "run" $\tilde{\run}: \tilde{\config}_0 \step{*} \tilde{\config}$ in $\tilde{\prot}$ that satisfies $\query$. We prove by induction on the length of $\tilde{\run}$ that there exists a "run" $\run$ reaching a configuration $\config$ such that $\tilde{\config} \lessthan \config$ (Remark~\ref{rem:bigger_config_query} then allows us to conclude). 
%	
%	If $\config = \config_0$ then $\run = \tilde{\run}$ suffices. Suppose that $\tilde{\run}$ has length $k \geq 1$, and that the result if true for "runs" of length $k-1$. Decompose $\tilde{\run}$ into $\tilde{\run_{k-1}}: \tilde{\config_0} \step{*} \tilde{\config_{k-1}}$ of length $k-1$ and a final step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. 
%	By induction hypothesis, there exists $\run_{k-1}: \config_0 \step{*} \config_{k-1}$ such that $\tilde{\config_{k-1}} \lessthan \config_{k-1}$: there exists an injective function $\pi : \tilde{\agents} \rightarrow \agents$
%	such that, for all $a \in \tilde{\agents}$, $\tilde{\config_{k-1}}(a) = \config_{k-1}(\pi(a))$, where $\tilde{\agents} := \agentsof{\tilde{\run}}$ and $\agents := \agentsof{\run}$. If $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ involves no reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$, then we directly lift this step into a step appended at the end of $\run_{k-1}$ (making $\pi(a)$ take a transition whenever $a$ does so in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$). Otherwise, write $\tilde{\agents}_{\diseqtestact}$ the subset of $\tilde{agents}$ corresponding to agents taking in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$ a reception transition from $\tilde{\prot}$ whose corresponding transition in $\prot$ has action $\quotemarks{\diseqtestact}$ . Write $(q, \br{m}, q') \in \transitions$ the broadcast transition used in this step.  Using Lemma~\ref{lem:copycat}, we add to $\config_{k-1}$ a fresh agent $a_{\mathsf{new}}$ with state $q$ and a register value that do not appear in $\config_{k-1}$. 
%	We first mimick this broadcast step at the end of $\run_{k-1}$, making any agent $\pi(a) \in \pi(\tilde{\agents} \setminus \tilde{\agents}_{\diseqtestact})$ take the transition that $a$ takes in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. We then add a new step where $a_{\mathsf{new}}$ broadcasts using transition $(q, \br{m}, q')$, and every agent $\pi(a) \in \pi(\tilde{\agents}_{\diseqtestact})$ takes the transition corresponding to the transition taken by $a$ in $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$. Such a transition is a reception with action $\quotemarks{\diseqtestact}$ in $\prot$; however, because $a_{\mathsf{new}}$ does not share its register value with any process from $\tilde{\agents}$, all disequality conditions are satisfied and this step is valid. In this end, every agent $\pi(a) \in \pi(\tilde{\agents})$ has taken the transition in $\prot$ corresponding to the one $a$ took in $\tilde{\prot}$ in step $\tilde{\config_{k-1}} \step{} \tilde{\config_k}$, hence the configuration $\config_k$ reached by the constructed run is such that $\tilde{\config_k} \lessthan \config_k$. 
%\end{proof}
%\fi
%
%Thanks to Corollary~\ref{cor:removing_diseq_tests}, we shall from now on assume that all considered protocols have no disequality tests. 
%
%\begin{definition}
%	Given a set of states $K \subseteq Q$, we say that a pair $\config, \aval$ with  $\config$ a "configuration" over a set of agents $\agents$ and $\aval \in \nats$ satisfies $K$ if for all $q \in K$, there exists $a \in \agents$ such that $\config(a) = (q,\aval)$.
%	A configuration $\config$ satisfies $K$ if there exists $\aval \in \nats$ such that $\config, \aval $ satisfies $K$. 
%	A "run" satisfies $K$ if its final configuration does.
%\end{definition}
%Note that if a "run" satisfies $K$, then it covers every state in $K$. The converse is not true as, in order to satisfy $K$, one needs to have agents of every state of $K$ that all share the same register value. See for instance the example below.
%
%\begin{example}
%	Consider the "protocol" displayed in Figure~\ref{fig:no-clique}.
%	We can obtain configurations satisfying $\set{1,2}$, $\set{2,3}$ or $\set{1,3}$, but we cannot obtain one satisfying $\set{1,2,3}$.
%	
%	\begin{figure}[h]
%		\input{Figures/fig-no-clique}
%		\caption{An illustrating example}
%		\label{fig:no-clique}
%	\end{figure}
%\end{example}
%
%
%
%\begin{definition}
%	We say that a "query" $\query$ is ""contradictory"" if either:
%	\begin{itemize}
%		\item there exists $\varz$ and $q \neq q' \in Q$ such that $\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$ or
%		
%		\item there exist $\var{z_1}, \ldots, \var{z_k} \in \varset$ and $j_1, \ldots, j_k$ with $k\geq 1$ such that $\quotemarks{R_{j_i}(\varz_{i}) = R_{j_{i+1}}(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R_{j_k}(\varz_k) \neq R_{j_1}(\varz_1)} \in \query$.
%	\end{itemize}
%\end{definition}
%
%\begin{proposition}
%	A "query" $\query$ is "contradictory" if and only if there exists no configuration satisfying $\query$. Additionnaly, one may decide whether $\query$ is contradictory in time polynomial in $\size{\prot} + \size{\query}$. 
%\end{proposition}
%
%\ifproofs
%\begin{proof}
%	Suppose first that $\query$ is "contradictory". If there exist $q \ne q'$ such that
%	$\quotemarks{q(\varz)}, \quotemarks{q'(\varz)} \in \query$,  then a "configuration" satisfying $\query$ would need to have a single agent in two distinct states. If there exist $\var{z_1}, \ldots, \var{z_k}$ distinct variables with $k\geq 1$ such that $\quotemarks{R(\varz_{i}) = R(\varz_{i+1})} \in \query$ for all $i \in \set{1,\ldots,k-1}$ and $\quotemarks{R(\varz_k) \neq R(\varz_1)} \in \query$, then in any configuration satisfying $\query$,  the registers associated with $\varz_k$ and $\varz_1$ must have the same register value but also distinct register values, which is a contradiction. 
%	
%	Suppose now that the $\query$ is not "contradictory" and show that there exists some configuration satisfying $\query$.
%	
%	We consider the graph $G$ whose vertices are variables of $\varset$ appearing in $\query$ and with an edge between $\varz$ and $\varz'$ if and only if $R(\varz) = R(\varz') \in \query$. Since $\query$ is not "contradictory", for any $\varz, \varz'$ in the same connected component of $G$, $\quotemarks{R(\varz) \ne R(\varz')} \notin \query$. We construct a configuration satisfying $\query$ with an agent $a_\varz$ for every $\varz$ such that:
%	\begin{itemize}
%		\item if $\quotemarks{q(\varz)} \in \query$ then $a_\varz$ is in state $q$,
%		\item the agents of the variables of a connected component of $G$ have all the same register value.  
%	\end{itemize}
%	The built configuration satisfies $\query$, which concludes the proof. 
%\end{proof}
%\fi
%
%\begin{lemma}
%	\label{lem:query-decomposition}
%	Let $\query$ a  "non-contradictory" "query". There exist $K_1, \ldots, K_p \subseteq Q$ with $p \leq \size{\query}$ with the following property: there exists a "run" satisfying $\query$ if and only if for all $i \in \set{1,\ldots, p}$, there is a run satisfying $K_i$. Moreover,such sets $K_1, \dots, K_p$ may be computed in time polynomial in $\size{\prot}$. 
%\end{lemma}
%
%
%\ifproofs
%\begin{proof}
%	
%	We consider the same graph $G$ as in the previous proof. We decompose $G$ into connected components $C_1, \ldots, C_p$. 
%	For each $C_i$ we define $K_i = \set{q \in Q \mid \exists \varz \in C_i, q(\varz) \in \query}$. Note that $K_i$ may be empty when there is no constraints on the states of the variables in $C_i$. An empty set is satisfied by any "run". This is coherent with the fact that, when $K_i = \emptyset$, it suffices to assign all variables in $C_i$ to an agent that stays in $q_0$ for the whole "run".
%	
%	Suppose there is a "run" satisfying $\query$, let $\config$ be its final configuration, let $\nu$ be a valuation witnessing the satisfaction of $\query$ by $\config$.
%	Let $i \in \set{1,\ldots, p}$, we show that $\config$ satisfies $K_i$. For all $\varz \in C_i$, let $(q_\varz,\aval_\varz) = \config(\nu(\varz))$. As $C_i$ is a connected component of $G$ and $\config$ satisfies $\query$, all $\nu(\varz)$ with $\varz \in C_i$ have the same register value, which we call $\aval$. 
%	For all $q \in K_i$, there exists $\varz \in C_i$ such that $q(\varz) \in \query$ and thus $q_\varz =q$ and $\aval_\varz =\aval$, thus $C_i$ is satisfied.
%	
%	For the converse implication, suppose for all $i$ we have a run $\run_i$ over a set of agents $\agents_i$ satisfying $K_i$. We rename agents so that the $\agents_i$ are pairwise disjoint, we introduce fresh agents $a_1, \ldots, a_p$ and we set $\agents = \set{a_1, \ldots, a_p} \sqcup \bigsqcup_{i=1}^p \agents_i$. We consider $\run: \config_0 \step{*} \config$ a "run" in which the sequences of actions of each $\run_i$ are executed sequently by agents from $\agents_i$. In $\run$, agents $a_1$ to $a_p$ are left idle on $q_0$. We build the valuation $\nu$ witnessing that $\run$ satisfies $\query$ as follows. Let $i \in \nset{1}{p}$. If $K_i = \emptyset$ then $\nu$ assigns $a_i$ to every variable of $C_i$. Otherwise, we know that $\config|_{\agents_i}$ satisfies $K_i$ because the final configuration of $\run_i$ does: there exists $\aval_i \in \nats$ such that, for all $q \in K_i$, some agent $a_{i,q}$ has state $q$ and register value $\aval_i$ in $\config$. Let $\varz \in C_i$. If, for some $q \in Q$, $\quotemarks{q(\varz)} \in \query$, $\nu$ assigns agent $a_{i,q}$ to $\varz$ ($q$ is unique as $\query$ is not "contradictory"). If $\query$ has no constraint about the state of $\varz$, $\nu$ assigns to $\varz$ some $a_{i,q}$ with $q \in k_i$ arbitrary. 
%	
%	% We define a valuation $\nu$ as follows. Let $\varz \in \varset$ and $i$ so that $C_i$ is the connected component of $\varz$ in $G$. If  for some $q$, then this $q$ is unique as $\query$ is not "contradictory". We set $\nu(\varz) = a_q^i$.
%	% If there is no $q(\varz)$ for any $q \in Q$ in $\query$ but there is one of the form $q'(\varz')$ with $\varz' \in C_i$, then we set $\nu(\varz) = \nu(\varz')$.
%	% Otherwise we set $\nu(\varz) = a_i$.
%	% This fully defines our valuation $\nu$.
%	
%	Clearly all formulas of the form $q(\varz)$ or $R(\varz) = R(\varz')$ are satisfied.
%	For the formulas of the form $R(\varz) \neq R(\varz')$, we observe that as $\query$ is not "contradictory", $\varz$ and $\varz'$ are not in the same connected component of $G$. Because the runs $\run_i$ worked with disjoint sets of register values ($\config_0$ is initial), the agents assigned to $\varz$ and $\varz'$ end the run with distinct register values.
%	Hence $\data{\config}(\nu(\varz)) \neq \data{\config}(\nu(\varz'))$. As a result, $\query$ is satisfied by $\run$.
%\end{proof}
%\fi
%\fi


\subsection{Classical definitions}


\subparagraph*{Fast-growing hierarchy}

For $\alpha$ an ordinal in Cantor normal form, we denote by $\Ffunction{\alpha}$ the class of functions corresponding to level $\alpha$ in the Fast-Growing Hierarchy. We moreover denote by $\Fcomplexity{\alpha}$ the associated complexity class and use the notion of $\Fcomplexity{\alpha}$-completeness. All these notions are defined in \cite{Schmitz16}. We will specifically work with complexity class $\Fcomplexity{\omega^{\omega}}$. For readers unfamiliar with these notions, $\Fcomplexity{\omega^{\omega}}$-complete problems are problems which are decidable but with very high complexity (non-primitive recursive, and even non-multiply recursive). 

We highlight that our main result is the decidability of the problem. We show that the problem lies in $\Fcomplexity{\omega^{\omega}}$ as it does not complicate our decidability proof significantly, and this result fits nicely into the landscape of high-complexity problems arising from well quasi-orders. 

\subparagraph*{Well-quasi orders}

For our decidability result, we rely on the theory of well quasi-orders in the context of subword ordering.
Let $\Sigma$ be a finite alphabet, $w_1, w_2 \in \Sigma^*$, $w_1$ is a ""subword"" of $w_2$, denoted $w_1 \subword w_2$, when $w_1$ can be obtained from $w_2$ by erasing some letters. 
A sequence of words $w_0, w_1, \ldots$ is ""good"" if there exist $i<j$ such that $w_i \subword w_j$, and ""bad"" otherwise. Higman's lemma \cite{Higman52} states that every "bad" sequence of words over a finite alphabet is finite.
In order to bound the length of a "bad" sequence, one must bound the growth of the sequence of words. 
We will use the following result, known as the Length function theorem \cite{SchmitzS2011upperHigman}:

\begin{theorem}[""Length function theorem"" \cite{SchmitzS2011upperHigman}]
	\label{thm:lengthfcttheorem}
	Let $\Sigma$ be a finite alphabet, let $g : \nats \to \nats$ be a primitive recursive function.
	There exists a function $f \in \Ffunction{\omega^{\size{\Sigma} - 1}}$ such that, for all $n \in \nats$, every "bad" sequence $w_1, w_2, \ldots$ such that $\size{w_i} \leq g^{(i)}(n)$ for all $i$ is of length at most $f(n)$. 
\end{theorem}



\subsection{Link with LCS}

""Lossy channel systems"" ("LCS") are systems where finite-state processes communicate via sending messages from a finite alphabet through unbounded lossy FIFO channels. The reachability problem asks whether a given control state of the system may be covered. Unlike in the non-lossy case \cite{BZ83}, reachability is decidable for "lossy channel systems" \cite{AbdullaJ1996verif}, but is proven to have non-primitive recursive complexity \cite{Schnoebelen2002verifying} and is in fact $\Fcomplexity{\omega^{\omega}}$-complete \cite{ChambartS08ordinal}. 

We argue that \COVER in BNRA is harder than the reachability problem for "LCS". The reduction can be found in Appendix~\ref{app:reduction-lcs}; we provide here some intuition. Given an "LCS" $\los$, we build a "protocol" $\prot$ with two registers. For each agent, the first register is never modified and plays the role of a permanent identifier. At the beginning of the execution, each agent receives a foreigner identifier and stores it in its second register; it then only accepts messages with this identifer (using an equality test on every reception). This way, agents will form chains where messages propagate in one direction and where an agent has at most one predecessor. Each agent of the chain will simulate a step of an execution of $\los$: an agent received from its predecessor a configuration of $\los$, chooses the next configuration of $\los$ and broadcasts it, sending first the location of $\los$ then, letter by letter, the content of the channel. Note that some of the messages for the content of the channel might get lost, hence the lossiness. 
% Note that one special agent has to start the execution, and send the initial configuration before receiving anything. The final state is the final state of the "LCS" and if one agent reaches it, one can argue that there is an execution of the "LCS" described by the sent messages in the chain of agent starting with an agent sending the initial configuration.

\begin{restatable}{proposition}{propReductionLCS}
	\label{prop:reduction-LCS}
	The "coverability problem" for BNRAs is $\Fcomplexity{\omega^\omega}$-hard.
\end{restatable}

%The proof is in Appendix~\ref{app:reduction-lcs}.

\begin{remark}
	This reduction can be adapted to show that repeat-\COVER (whether there is an infinite run covering $q_f$ infinitely often) is undecidable for BNRA, as it is for LCS~\cite{AbdullaJ1996undec}. 
	% This highlights the fact that the abstraction presented below relies on the fact that we only have to consider finite runs for coverability.
\end{remark}

