
%To prove the \NP upper bound, we present an abstraction on configurations and runs. 
%The main ingredient of our abstraction is an extended version of the "copycat principle" presented in Remark~\ref{rem:copycat-principle}. 
%It is twofold: 
%\begin{itemize}
%	\item First, as explained in Remark~\ref{rem:copycat-principle}, if there is a run $\run$ sending an agent to a state $q$, then we can construct a run $\run'$ executing run over disjoint sets of agents (with different values) as many times as we want to obtain as many agents as we need in $q$.
%	
%	\item  Furthermore, if in a run $\run$ an agent $a$ gets in a state $q$ with a value $\aval$ that is not its initial one, it means that at some point in the run, it was in a state $q'$ and executed a transition in which it received a message with value $v$, stored it in its register and went to a state $q''$. 
%	As mentioned before, we can copy the run up to that point to have an unlimited supply of agents in $q'$, and thus an unlimited supply of agents in $q''$ with value $\aval$. We can then make all those agents copy the broadcasts of $a$ and receive the same messages so that they all reach $q$ with value $\aval$. Hence if we have an agent in a state $q$ with a value $\aval$ that is not its initial one, we can assume that we have as many agents in $q$ with value $\aval$ as we need.	
%\end{itemize}



\begin{restatable}{definition}{defGang}
	Let $(Q,\transitions, q_0)$ be a protocol.
	
	A ""gang"" is a pair $\gang = (\boss, \clique) \in (Q \cup \set{\noboss}) \times \powerset{Q}$. The element $\boss$ is the ""boss@gang"" and the set $\clique$ is the ""clique"" of the "gang". %We write $\gangconfigs$ the set of "gangs". 
	
	Let $\run = \config_0 \step{} \config_1 \step{} \cdots \step{} \config_k$ be a "run" and $\aval \in \valsof{\run}$. The "gang" of value $\aval$ in $\run$, written $\gangof{\aval}{\run}$, is the "gang" $(\boss, \clique)$ such that, 
	\begin{itemize}
		\item if there exists $a_0 \in \agentsof{\run}$ such that, 
		for every 
		$i \in \nset{0}{k}$, 
		$\data{\config_i}(a_0) = \aval$ then $\boss := \st{\config_k}(a_0)$, otherwise $\boss := \noboss$, 
		%	\nico{changement de def: pour etre le boss il faut garder sa valeur tt le long de l'execution}
		\item  $\clique := \set{q \in Q \mid \exists i \leq k, \exists a \in \agents\setminus \set{a_0}, \config_i(a) = (q,\aval)}$ %\\
		%´\nico{j'ai changé la def pour fque ça soit plus facile: ancienne def $\clique := \set{q \in Q \mid \exists a \in \agents\setminus \set{\boss}, \config_k(a) = (q,\aval)}$}
	\end{itemize}
%	Note that, if such an agent $a_0$ exists, then it is unique as $\config_0$ is initial hence this definition is sound. If there exists no agents with value $\aval$ in $\config_0$, then trivially $\gangof{\aval}{\run} = (\noboss, \emptyset)$. 
\end{restatable} 




%
%The proof can be found in Appendix~\ref{sec:one-diseq-tests}.
%\begin{example}
%	Consider the "protocol" displayed in Figure~\ref{fig:no-clique}.
%	We can obtain configurations satisfying $\set{1,2}$, $\set{2,3}$ or $\set{1,3}$, but we cannot obtain one satisfying $\set{1,2,3}$.
%	
%	\begin{figure}[h]
%		\input{Figures/fig-no-clique}
%		\caption{An illustrating example}
%		\label{fig:no-clique}
%	\end{figure}
%\end{example}

%
%We are now ready to define our abstraction. As mentioned before, it should keep track of a particular state (the state of the process with the initial register value) and a set of states in which any number of processes can be on with the same non-initial value. We name this tuple a "gang" which we define formally below.

%
%Intuitively, a "gang" corresponds to the set of agents with a given "register value". The "boss" $\boss$ represents the process that had this value at the beginning and the "clique" $\clique$ the set of states of processes who have received and stored this register value. If the original owner of this value no longer has it, then $\boss = \noboss$. Note that we define the clique as the set of states $q$ such that \emph{at some point in the run} some agent was in state $q$ with value $v$. This is because we can use the copycat principle to add a large amount of agents that are in state $q$ with value $v$, and thus we can assume that there is always one.

We can then define a natural abstract semantics based on gangs. An abstract configuration consists in a set of states $S$ (states covered so far by some agents) and a clique $(b, K)$ (the original owner of the value $v$ we are keeping track of and the states reached by other agents with that value). If the original owner of $v$ receives a new value we set $b = \bot$.

Abstract transitions are defined simply by applying transitions of the protocol while assuming that we have unlimited supplies of agents in every state of $S$ and of agents with the same value $v$ in states of $K$.
We also allow \emph{gang resets}, which maintain $S$ but reinitialise $(b,K)$ to $(q_0, \emptyset)$ (we start keeping track of a new value).

We define formally this abstraction and show its soundness and completeness in the appendix.
It is then easy to show that $S$ should grow between two gang resets (otherwise they reset to the same abstract configuration) and that there may be at most $O(\size{Q}^2)$ abstract steps between two resets (as $K$ can only increase and there are only $\size{Q}+1$ possibilities for $b$). This means that if there is an abstract run covering a state, there is one of size $O(\size{Q}^3)$, giving us polynomial-size witnesses for coverability, and thus an \NP algorithm.

The \NP lower bound follows from a reduction from 3SAT (an agent sends a sequence of messages with its identifier representing a valuation to other agents which broadcast it back to it, allowing it to check the satisfaction of a 3SAT formula).
Those results yield the main theorem of this section:


\begin{restatable}{theorem}{thmNPComplete}
	\label{thm:np-complete-query-cover}
	The "coverability problem" is \NP-complete for "protocols" with one register.
\end{restatable}

