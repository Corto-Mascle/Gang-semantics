	In this section, we only consider "protocols" with one register. Our motivation is to find a restriction that tempers the high complexity of the general case. We shall call BNRA with one register 1-BNRAs. Due to space constraints, the formal proof is not included in this section; it can be found in Appendix~\ref{app:cover-one-reg}. Meanwhile, in this section we intend to present the key observations that allow us to abstract runs into short witnesses, as well as the principle of our \NP-completeness proof.
	
	The "cover problem" is much easier in 1-BNRAs than in the general case. Intuitively, it suffices to keep track of the state of one \emph{boss} agent (the one who broadcasts its initial value), a set of states containing \emph{follower} processes with that same register value, and a set of states containing agents with any register values. This way, we can (i) compute the set of reachable states and (ii) decide if a state is coverable or not. In this section, we prove that the "cover problem" for 1-BNRAs is \NP-complete.

	We simplify notations as in this section we do not need to consider "local tests": with a single register every local equality test is satisfied and every local disequality test is not.
	Hence we can delete transitions with disequality tests and replace equality tests with internal transitions that have no effect (which may in turn be encoded in our model using broadcasts of dummy messages). 
	 
	Furthermore, the register argument in receptions and broadcasts is always $1$, hence we remove it.
	Our new set of operations is 
	$
	Op^{\messages} = \set{\brone{\amessage}, \recone{\amessage}{\dummyact}, \recone{\amessage}{\enregact}, \recone{\amessage}{\eqtestact}, \recone{\amessage}{\diseqtestact} \mid \amessage \in \messages}.
	$
	Finally, given a "configuration" $\config$, we write $\data{\config}(a)$ for $\data{\config}(a,1)$. 

		



